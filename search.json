[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n\n\n Back to top"
  },
  {
    "objectID": "src/multiple_dispatch.html",
    "href": "src/multiple_dispatch.html",
    "title": "Methods and Multiple Dispatch in Julia",
    "section": "",
    "text": "Note\n\n\n\nThis page is still under construction. For more details about methods and multiple dispatch in Julia, please refer to the official Julia Methods Documentation.\nJulia’s multiple dispatch system is a defining feature and core paradigm of the language. Multiple dispatch allows Julia to select which method to execute based on the types of all arguments provided to a function, rather than just the first one. This approach enables Julia to adaptively execute optimized methods for each specific combination of argument types, resulting in highly flexible and efficient code.",
    "crumbs": [
      "Content of the course",
      "Work in progress",
      "Methods and Multiple Dispatch"
    ]
  },
  {
    "objectID": "src/multiple_dispatch.html#what-is-multiple-dispatch",
    "href": "src/multiple_dispatch.html#what-is-multiple-dispatch",
    "title": "Methods and Multiple Dispatch in Julia",
    "section": "What is Multiple Dispatch?",
    "text": "What is Multiple Dispatch?\nIn languages with single dispatch, such as Python, Java, or C++, method selection is determined solely by the type of one object, often the first argument or the calling object (e.g., object.method()). In contrast, multiple dispatch in Julia means that methods are chosen based on all arguments, making functions truly polymorphic in response to different type combinations.\nThis behavior can be seen in Julia with the syntax:\nfunction my_function(x::Int, y::Float64)\n    println(\"Called with Int and Float64\")\nend\n\nfunction my_function(x::String, y::Int)\n    println(\"Called with String and Int\")\nend\nIn this example, Julia will dynamically determine the appropriate method based on the types of both arguments passed to my_function. This flexibility is central to Julia’s design and unlocks substantial benefits for performance and usability.\n\nWhy is Julia’s Dispatch System Powerful and Unique?\nJulia’s dispatch system is distinctive because it combines the flexibility of dynamic typing with the performance of compiled languages. With multiple dispatch, Julia compiles specialized versions of functions for specific type combinations, enabling it to achieve high performance close to that of statically compiled languages like C and Fortran. This capability solves the “two-language problem,” where developers often prototype in high-level languages (e.g., Python, R) but rewrite performance-critical parts in low-level languages for speed.\n\n\nBenefits of Multiple Dispatch\n\nPerformance: Julia’s compiler generates efficient machine code for specific type combinations, allowing function calls to avoid the overhead of type checks and branching, which are often required in other dynamically typed languages.\nCode Flexibility and Reusability: Multiple dispatch allows developers to write more modular and reusable code. Functions can be extended to handle new types by simply defining additional methods, without modifying existing code.\nCleaner, More Intuitive Code: With multiple dispatch, function definitions naturally describe the intended behavior for specific types, making code easier to read and understand. There’s no need for verbose type checking inside functions, which keeps code concise.",
    "crumbs": [
      "Content of the course",
      "Work in progress",
      "Methods and Multiple Dispatch"
    ]
  },
  {
    "objectID": "src/multiple_dispatch.html#specialization-and-method-selection",
    "href": "src/multiple_dispatch.html#specialization-and-method-selection",
    "title": "Methods and Multiple Dispatch in Julia",
    "section": "Specialization and Method Selection",
    "text": "Specialization and Method Selection\nIn Julia, you can define multiple methods for the same function, each specialized for different combinations of argument types. This is done by specifying the types of the function’s arguments using type annotations. Julia will then choose the appropriate method based on the types of the arguments passed at runtime.\n\nBasic Examples\nLet’s define a function f that handles different types of input.\n\nf(x::Int, y::Int) = println(\"($x, $y) ∈ ℤ × ℤ\")\nf(x::Float64, y::Float64) = println(\"($x, $y) ∈ ℝ × ℝ\")\nf(x::Int, y::Float64) = println(\"($x, $y) ∈ ℤ × ℝ\")\n\nf (generic function with 3 methods)\n\n\nNow, depending on the types of the arguments, Julia will dispatch the appropriate method:\n\nf(2, 3)         # Calls the method for integers\nf(2.5, 3.5)     # Calls the method for floats\nf(2, 3.5)       # Calls the mixed-type method\n\n(2, 3) ∈ ℤ × ℤ\n(2.5, 3.5) ∈ ℝ × ℝ\n(2, 3.5) ∈ ℤ × ℝ",
    "crumbs": [
      "Content of the course",
      "Work in progress",
      "Methods and Multiple Dispatch"
    ]
  },
  {
    "objectID": "src/multiple_dispatch.html#ambiguous-dispatch",
    "href": "src/multiple_dispatch.html#ambiguous-dispatch",
    "title": "Methods and Multiple Dispatch in Julia",
    "section": "Ambiguous Dispatch",
    "text": "Ambiguous Dispatch\nAmbiguous dispatch occurs when Julia cannot determine which method to call because multiple methods are applicable for the given arguments. This happens when there is overlap in the argument types of different methods, making it unclear which method should be selected.\n\nWhy Ambiguous Dispatch Can Occur?\nWhen you define multiple methods for the same function, each method is associated with specific types of arguments. Ambiguous dispatch happens when there are two or more methods that could potentially match the types of the arguments passed to the function. Julia relies on the order of method definitions and their specificity to resolve which method to dispatch, but sometimes it’s unable to make a clear decision, resulting in ambiguity.\n\n\nExample of Ambiguous Dispatch\nLet’s define methods for the function g where the ambiguity arises because of overlapping types:\n\ng(x::Real, y::Real) = println(\"($x, $y) ∈ ℝ × ℝ\")\ng(x::Integer, y::Real) = println(\"($x, $y) ∈ ℤ × ℝ\")\ng(x::Real, y::Integer) = println(\"($x, $y) ∈ ℝ × ℤ\")\n\ng (generic function with 3 methods)\n\n\nLet first call g with arguments that match only one method:\n\ng(1.0, 2.0)    # Calls the method for two floats\ng(1, 2.0)      # Calls the method for integer and float\ng(1.0, 2)      # Calls the method for float and integer\n\n(1.0, 2.0) ∈ ℝ × ℝ\n(1, 2.0) ∈ ℤ × ℝ\n(1.0, 2) ∈ ℝ × ℤ\n\n\nNow, let’s try to call g with arguments that could match both methods, like this:\n\ng(2, 3)        # Error: Ambiguous dispatch\n\n\nMethodError: g(::Int64, ::Int64) is ambiguous.\n\nCandidates:\n  g(x::Real, y::Integer)\n    @ Main In[5]:3\n  g(x::Integer, y::Real)\n    @ Main In[5]:2\n\nPossible fix, define\n  g(::Integer, ::Integer)\n\n\nStacktrace:\n [1] top-level scope\n   @ In[7]:1\n\n\n\nIn this case, the methods g(x::Integer, y::Real) and g(x::Real, y::Integer) both match, and Julia cannot decide which one to dispatch to, that is why the error occurs. To resolve this ambiguity, you can follow the advice in the error message and define another specialized method that covers the ambiguous case: g(x::Integer, y::Integer). You can also refactor the existing methods to avoid ambiguity: replace for instance Real with Float64 or Integer with Int.",
    "crumbs": [
      "Content of the course",
      "Work in progress",
      "Methods and Multiple Dispatch"
    ]
  },
  {
    "objectID": "src/multiple_dispatch.html#parametric-functions",
    "href": "src/multiple_dispatch.html#parametric-functions",
    "title": "Methods and Multiple Dispatch in Julia",
    "section": "Parametric Functions",
    "text": "Parametric Functions\nYou can define parametric functions in Julia that work with different types, which are specified using type parameters. These functions are flexible and can operate on any type that is passed to them when called.\n\nExample: Identity Function\nHere’s an example of a simple identity function id, which returns whatever value is passed to it, regardless of its type:\n\nfunction id(x::T) where T\n    return x\nend\n\nid(42)       # Integer\nid(3.14)     # Float64\nid(\"Hello\")  # String\n\njulia&gt; id(42) = 42\njulia&gt; id(3.14) = 3.14\njulia&gt; id(\"Hello\") = \"Hello\"\n\n\nIn this case, the function id works for any type T, and you can pass an Int, Float64, String, or any other type. Julia automatically infers the type of T based on the argument passed to the function. This makes id a highly flexible function.\nYou can specify the return type of a parametric function by adding a return type annotation:\n\nfunction double(x::T)::T where {T &lt;: Number}\n    return 2x\nend\n\ndouble(12) # Integer\n\n24\n\n\nYou can also force to return a specific type:\n\nfunction triple(x::T)::Float64 where {T &lt;: Real}\n    return 3x\nend\n\ntriple(12) # Float64\n\n36.0\n\n\n\n\nConstraints on Parametric Functions\nYou can also add constraints to parametric functions, ensuring that the parametric type parameter must be a subtype of a specific type. This is useful when you want the function to operate only on certain types, such as numeric types or specific structures.\n\nExample: Adding a Constraint on Numbers\nHere’s an example where we define a function add_one that only works with numeric types. The type parameter T is constrained to be a subtype of Number:\n\nfunction add_one(x::T) where T &lt;: Number\n    return x + 1\nend\n\nadd_one(3)       # Valid: 3 + 1 = 4\n\n4\n\n\n\nadd_one(3.14)    # Valid: 3.14 + 1 = 4.14\n\n4.140000000000001\n\n\n\nadd_one(\"Hello\")  # Error: String is not a subtype of Number\n\n\nMethodError: no method matching add_one(::String)\nThe function `add_one` exists, but no method is defined for this combination of argument types.\n\nClosest candidates are:\n  add_one(::T) where T&lt;:Number\n   @ Main In[11]:1\n\n\nStacktrace:\n [1] top-level scope\n   @ In[13]:1\n\n\n\nIn this case, the function add_one will only accept types that are subtypes of Number (such as Int, Float64, etc.). If you try to pass a non-numeric type like String, Julia will throw an error.\n\n\nRestricting to More Specific Types\nYou can further restrict the parametric type to more specific types. For example, you could specify that a function should only accept Int64 or a specific subtype of Number, excluding other subtypes like Float64 or Complex:\n\nfunction double(x::T) where T &lt;: Int64\n    return x * 2\nend\n\ndouble(10)    # Valid: 10 * 2 = 20\n\n20\n\n\n\ndouble(3.14)  # Error: Float64 is not a subtype of Int64\n\n6.28\n\n\n\n\n\nComparison with Type Annotations\nWhen you use type annotations, you specify a fixed type for a function argument. For example, if you want to ensure that an argument is a subtype of Number, you can use a type annotation like this:\n\nfunction display_number(x::Number)\n    println(\"The number is: \", x)\nend\n\nIn this case, x can be of any type that is a subtype of Number (such as Int, Float64, etc.). However, the type is not explicitly accessible in the function body.\nOn the other hand, parametric functions with constraints allow you to achieve the same flexibility but also give you direct access to the type parameter. For example, you can write a function with a parametric type T constrained to Number, and you will have access to the type T directly:\n\nfunction display_number_constrained(x::T) where T &lt;: Number\n    println(\"The number is of type: \", T)\n    println(\"The number is: \", x)\nend\n\nIn this parametric version, T is directly accessible inside the function body, allowing you to print the type along with the value. This provides more flexibility if you need to work with the type itself.\nBoth functions will accept any subtype of Number, but the parametric version also allows you to access and use the type parameter explicitly, while the annotated version does not.\n\n\nMultiple Constrained Arguments\nYou can also add constraints on multiple arguments to ensure that they all have the same type. This is useful when you want to perform operations on multiple variables that should all belong to the same type, but still want the flexibility of working with different types.\nHere’s an example where we define a function that accepts two arguments, both constrained to be of the same type:\n\nfunction add_numbers(x::T, y::T) where T &lt;: Number\n    return x + y\nend\n\nadd_numbers(3, 4)       # Valid: 3 + 4 = 7\n\n7\n\n\n\nadd_numbers(2.5, 3.5)   # Valid: 2.5 + 3.5 = 6.0\n\n6.0\n\n\n\nadd_numbers(3, 3.5)     # Error: Arguments have different types (Int and Float64)\n\n\nMethodError: no method matching add_numbers(::Int64, ::Float64)\nThe function `add_numbers` exists, but no method is defined for this combination of argument types.\n\nClosest candidates are:\n  add_numbers(::T, ::T) where T&lt;:Number\n   @ Main In[18]:1\n\n\nStacktrace:\n [1] top-level scope\n   @ In[20]:1\n\n\n\nIn this case, the function add_numbers will only accept two arguments that have the same type T. If you try to pass arguments of different types, such as an Int and a Float64, Julia will throw an error. This ensures that the function works with consistent types for both arguments while maintaining flexibility for different numeric types.\n\n\nParametric Arguments and Vectors\nYou can also use parametric types with multiple arguments to ensure that both the elements of a vector and the vector itself conform to a specific type. Here’s an example where we define a function that accepts a vector of a parametric type and a second parametric argument:\n\nfunction add_elements(vec::Vector{T}, value::T) where T\n    return [x + value for x in vec]\nend\n\nadd_elements([1, 2, 3], 2)  # Valid: Adds 2 to each element of the vector\n\n3-element Vector{Int64}:\n 3\n 4\n 5\n\n\n\nadd_elements([1.5, 2.5, 3.5], 1.0)  # Valid: Adds 1.0 to each element of the vector\n\n3-element Vector{Float64}:\n 2.5\n 3.5\n 4.5\n\n\n\nadd_elements([1, 2, 3], 3.14)  # Error: Vector contains Int, but value is Float64\n\n\nMethodError: no method matching add_elements(::Vector{Int64}, ::Float64)\nThe function `add_elements` exists, but no method is defined for this combination of argument types.\n\nClosest candidates are:\n  add_elements(::Vector{T}, ::T) where T\n   @ Main In[21]:1\n\n\nStacktrace:\n [1] top-level scope\n   @ In[23]:1\n\n\n\nIn this example, both the vector and the value passed to the function must have the same type T. If you try to pass a vector of Int with a Float64 value, Julia will throw an error, ensuring type consistency between the vector elements and the value being added.\n\n\nSummary\n\nParametric Functions allow you to define functions that can work with multiple types, using type parameters that are inferred when the function is called.\nType Annotations are used when you want to specify a fixed type for a function argument, but they don’t offer the same flexibility as parametric functions.\nConstraints on Parametric Functions let you restrict the type parameter to specific types or subtypes, ensuring that the function only operates on valid types.\nRestricting to More Specific Types allows you to narrow the scope of types further, offering more control over the types accepted by the function.\nMultiple Constrained Arguments ensures that two or more arguments in a function have the same type, while still providing flexibility for different types, ensuring consistency in operations with multiple parameters.\nUsing Parametric Arguments with Vectors allows you to define functions that ensure both the vector elements and the second argument match a specific type, ensuring consistency in operations.\n\n\n\nQuiz\n\n\n\n\n\n\nQuiz: Parametric Functions in Julia\n\n\n\n\n\n\n\nQuestion 1. What is a parametric function in Julia?\n\n\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        A function that can only work with a fixed type.\n    \n    \n\n\n    \n    \n    \n    \n        A function that operates only on numeric types.\n    \n    \n\n\n    \n    \n    \n    \n        A function that works with multiple types, specified by type parameters.\n    \n    \n\n\n    \n    \n    \n    \n        A function that cannot be defined without specifying a type.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 2. What does the following function id do?\n\n\n\n\nfunction id(x::T) where T\n    return x\nend\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        It returns the type of the argument.\n    \n    \n\n\n    \n    \n    \n    \n        It prints the argument.\n    \n    \n\n\n    \n    \n    \n    \n        It adds one to the argument.\n    \n    \n\n\n    \n    \n    \n    \n        It returns the argument without any modification.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 3. What happens when you call add_one(3) with the following function?\n\n\n\n\nfunction add_one(x::T) where T &lt;: Number\n    return x + 1\nend\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        It will add one to a numeric argument and throw an error for non-numeric types.\n    \n    \n\n\n    \n    \n    \n    \n        It will add one to any type.\n    \n    \n\n\n    \n    \n    \n    \n        It will add one to a string argument and return a new string.\n    \n    \n\n\n    \n    \n    \n    \n        It will throw an error for all inputs.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 4. What does the following function do?\n\n\n\n\nfunction double(x::T) where T &lt;: Int64\n    return x * 2\nend\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        It doubles the argument if it's a Float64.\n    \n    \n\n\n    \n    \n    \n    \n        It throws an error for any argument.\n    \n    \n\n\n    \n    \n    \n    \n        It adds two to the argument if it's an Int64.\n    \n    \n\n\n    \n    \n    \n    \n        It doubles the argument if it's an Int64.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 5. What is the advantage of using parametric functions with constraints?\n\n\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        They restrict the function to only accept types that meet the constraints.\n    \n    \n\n\n    \n    \n    \n    \n        They allow the function to modify the types passed to it.\n    \n    \n\n\n    \n    \n    \n    \n        They allow the function to work with any type.\n    \n    \n\n\n    \n    \n    \n    \n        They make the function less flexible but more efficient.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 6. What happens when you call add_numbers(3, 3.5) with the following function?\n\n\n\n\nfunction add_numbers(x::T, y::T) where T &lt;: Number\n    return x + y\nend\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        It will throw an error because the arguments have different types.\n    \n    \n\n\n    \n    \n    \n    \n        It will return the sum of the arguments as a string.\n    \n    \n\n\n    \n    \n    \n    \n        It will add the two numbers together.\n    \n    \n\n\n    \n    \n    \n    \n        It will add the numbers and print the result.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 7. What does the following code do?\n\n\n\n\nfunction add_elements(vec::Vector{T}, value::T) where T\n    return [x + value for x in vec]\nend\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        It multiplies each element in the vector by value.\n    \n    \n\n\n    \n    \n    \n    \n        It adds the value to each element in the vec.\n    \n    \n\n\n    \n    \n    \n    \n        It throws an error if the vector and value types don’t match.\n    \n    \n\n\n    \n    \n    \n    \n        It adds the value to the vector itself.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 8. What happens when you call add_elements([1, 2, 3], 3.14)?\n\n\n\n\nadd_elements([1, 2, 3], 3.14)\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        It will multiply each element of the vector by 3.14.\n    \n    \n\n\n    \n    \n    \n    \n        It will return an error because the vector and value types don’t match.\n    \n    \n\n\n    \n    \n    \n    \n        It will return a new vector with the elements increased by 3.14.\n    \n    \n\n\n    \n    \n    \n    \n        It will add 3.14 to each element in the vector and return the result.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 9. What happens when you call add_elements([1, 2, 3], 3.14) when the vector contains Int and the value is Float64?\n\n\n\n\nadd_elements([1, 2, 3], 3.14)\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        It will throw an error because the types don't match.\n    \n    \n\n\n    \n    \n    \n    \n        It will return a vector with elements 4.14, 5.14, 6.14.\n    \n    \n\n\n    \n    \n    \n    \n        It will return a new vector where each element is added to 3.14.\n    \n    \n\n\n    \n    \n    \n    \n        It will work because Int can be automatically converted to Float64.",
    "crumbs": [
      "Content of the course",
      "Work in progress",
      "Methods and Multiple Dispatch"
    ]
  },
  {
    "objectID": "src/syntax.html",
    "href": "src/syntax.html",
    "title": "Julia Syntax Essentials and Variable Scoping",
    "section": "",
    "text": "Julia is fundamentally an imperative programming language, where the flow of execution is defined by sequences of commands or statements that change the program’s state. Core features include:\nWhile imperative programming emphasizes how a task is accomplished (e.g., through loops, conditionals, and assignments), declarative programming focuses on what the result should be, leaving the “how” to the language or framework. Julia is versatile and can incorporate elements of declarative programming, such as high-level operations on collections and functional programming paradigms, but its foundation is firmly rooted in imperative concepts.",
    "crumbs": [
      "Content of the course",
      "Syntax Essentials and Scoping"
    ]
  },
  {
    "objectID": "src/syntax.html#basics",
    "href": "src/syntax.html#basics",
    "title": "Julia Syntax Essentials and Variable Scoping",
    "section": "Basics",
    "text": "Basics\n\nAssignment\nIn Julia, variables are assigned using the = operator:\n\nx = 5\ny = \"Hello, Julia!\"\n\nJulia is dynamically typed, which means variables do not require explicit type declarations. Types are inferred based on the assigned value.\n\ntypeof(x)\n\nInt64\n\n\n\ntypeof(y)\n\nString\n\n\nVariables act as labels pointing to values and can be reassigned without restrictions on type. This dynamic behavior is a hallmark of imperative languages.\n\n\nUnicode Characters\nJulia supports Unicode characters, enhancing code readability, especially for mathematical and scientific computations:\n\nα = 10\nβ = α + 5\nprintln(\"β = $β\")\n\nβ = 15\n\n\nUnicode symbols can be entered using \\name followed by Tab (e.g., \\alpha → α). A complete list of Unicode characters is available in the Julia Unicode documentation.\n\n\nComments\nComments are written with the # symbol. Julia also supports multiline comments with #= and =#:\n\n# This is a single-line comment\n\n#= \nThis is a \nmultiline comment \n=#\n\n\n\nPrinting Output\nFor debugging or displaying results, Julia provides the println function:\n\nprintln(\"Hello, Julia!\")  # Prints: Hello, Julia!\nprintln(\"The value of α is \", α)\n\nHello, Julia!\nThe value of α is 10\n\n\nAdditionally, the @show macro prints both variable names and values:\n\nx = 42\n@show x   # Prints: x = 42\n\nx = 42\n\n\nYou can also use @show with multiple variables or expressions:\n\na = 10\nb = 20\n@show a + b  # Prints: a + b = 30\n@show a, b   # Prints: a = 10, b = 20\n\na + b = 30\n(a, b) = (10, 20)\n\n\n\n\nComparison Operations\nJulia includes standard comparison operators for equality and order:\n\n\n\n\n\n\n\n\n\nOperator\nPurpose\nExample\nResult\n\n\n\n\n==\nEquality check\n5 == 5\ntrue\n\n\n!= or ≠\nInequality check\n5 != 3\ntrue\n\n\n&lt;, &lt;=\nLess than, or equal\n5 &lt; 10\ntrue\n\n\n===\nObject (type and value) identity check\n5 === 5.0\nfalse\n\n\n\nExamples:\n\n5 == 5     # true\n5 != 3     # true\n5 ≠ 3      # true (using Unicode)\n5 &lt; 10     # true\n10 &gt;= 10   # true\n\"Julia\" === \"Julia\"  # true (identical strings)\n5 === 5.0  # false (different types: Int vs. Float)\n\njulia&gt; 5 == 5 = true\njulia&gt; 5 != 3 = true\njulia&gt; 5 ≠ 3 = true\njulia&gt; 5 &lt; 10 = true\njulia&gt; 10 &gt;= 10 = true\njulia&gt; \"Julia\" === \"Julia\" = true\njulia&gt; 5 === 5.0 = false\n\n\nJulia’s comparison operators return Bool values (true or false). Using these operators effectively is essential for control flow and logical expressions.\nIn Julia, the === operator checks object identity, meaning it determines if two references point to the exact same memory location or the same instance. This is a stricter comparison than ==, which only checks if two values are equivalent in terms of their contents, not if they are the same instance.\nHere’s a breakdown of === in Julia:\n\nSingletons: === is often used for checking singleton objects like nothing, true, false, and other immutable types that Julia reuses rather than copying. For instance, nothing === nothing will return true, and similarly, true === true will return true.\nImmutable Types: For immutable types like Int, Float64, etc., === and == usually give the same result since identical values are often the same instance.\nPerformance: === is generally faster than == because it doesn’t need to do a value comparison, just a memory location check. This is particularly useful when checking if a value is a specific singleton (e.g., x === nothing).\n\n\na = 1\nb = 1\na === b  # true, since 1 is an immutable integer, they are identical instances\n\nx = [1, 2]\ny = x\nx === y  # true, because x and y refer to the same object in memory\n\nx == [1, 2]   # true, because the contents are the same\nx === [1, 2]  # false, because they are different instances in memory\n\njulia&gt; a = 1\njulia&gt; b = 1\njulia&gt; a === b = true\njulia&gt; x = [1, 2]\njulia&gt; y = [1, 2]\njulia&gt; x === y = true\njulia&gt; x == [1, 2] = true\njulia&gt; x === [1, 2] = false\n\n\nIn summary, === is especially useful for checking identity rather than equality, often applied to singletons or cases where knowing the exact instance matters, as it allows for efficient and clear comparisons.",
    "crumbs": [
      "Content of the course",
      "Syntax Essentials and Scoping"
    ]
  },
  {
    "objectID": "src/syntax.html#control-flows-and-logical-operators",
    "href": "src/syntax.html#control-flows-and-logical-operators",
    "title": "Julia Syntax Essentials and Variable Scoping",
    "section": "Control Flows and Logical Operators",
    "text": "Control Flows and Logical Operators\nControl flow in Julia is managed through conditional statements and loops. Logical operators allow for conditions to be combined or negated.\n\nConditional Statements\nJulia supports if, elseif, and else for conditional checks:\n\nx = 10\n\nif x &gt; 5\n    println(\"x is greater than 5\")\nelseif x == 5\n    println(\"x is equal to 5\")\nelse\n    println(\"x is less than 5\")\nend\n\nx is greater than 5\n\n\nIn Julia, blocks for if, elseif, and else are closed with end. Indentation is not required by syntax but is recommended for readability.\n\n\n\n\n\n\nTip\n\n\n\nYou can follow the Blue Style conventions for Julia code. If you want to format your code you can use the package JuliaFormatter.jl.\n\n\n\n\nTernary Operator\nFor simple conditional assignments, Julia has a ternary operator ? ::\n\ny = (x &gt; 5) ? \"Greater\" : \"Not greater\"\nprintln(y)  # Outputs \"Greater\" if x &gt; 5, otherwise \"Not greater\"\n\nGreater\n\n\n\n\nLogical Operators\nJulia includes standard logical operators, that combine or negate conditions:\n\n\n\nOperator\nPurpose\nExample\nResult\n\n\n\n\n&&\nLogical AND\ntrue && false\nfalse\n\n\n||\nLogical OR\ntrue || false\ntrue\n\n\n!\nLogical NOT\n!true\nfalse\n\n\n\n\na = true\nb = false\n\na && b\na || b\n!a\n\njulia&gt; a = true\njulia&gt; b = false\njulia&gt; a && b = false\njulia&gt; a || b = true\njulia&gt; !a = false\n\n\n\n\nLoops\nJulia provides for and while loops for iterative tasks.\nFor Loop: The for loop iterates over a range or collection:\n\nfor i in 1:5\n    println(i)\nend\n\n1\n2\n3\n4\n5\n\n\nThis loop prints numbers from 1 to 5. The range 1:5 uses Julia’s : operator to create a sequence.\n\n\n\n\n\n\nNote\n\n\n\nThe for construct can loop on any iterable object. Visit the documentation for details.\n\n\nWhile Loop: The while loop executes as long as a condition is true:\n\ncount = 1\n\nwhile count &lt;= 5\n    println(count)\n    count += 1\nend\n\n1\n2\n3\n4\n5\n\n\nThis loop will print numbers from 1 to 5 by incrementing count each time.\n\n\nBreaking and Continuing\nJulia also has break and continue for loop control.\n\nbreak exits the loop completely.\ncontinue skips the current iteration and moves to the next one.\n\n\nfor i in 1:5\n    if i == 3\n        continue  # Skips the number 3\n    end\n    println(i)\nend\n\n1\n2\n4\n5\n\n\n\nfor i in 1:5\n    if i == 4\n        break  # Exits the loop when i is 4\n    end\n    println(i)\nend\n\n1\n2\n3\n\n\nThese control flows and logical operators allow for flexibility in executing conditional logic and repeated operations in Julia.",
    "crumbs": [
      "Content of the course",
      "Syntax Essentials and Scoping"
    ]
  },
  {
    "objectID": "src/syntax.html#arithmetics",
    "href": "src/syntax.html#arithmetics",
    "title": "Julia Syntax Essentials and Variable Scoping",
    "section": "Arithmetics",
    "text": "Arithmetics\nJulia supports a variety of arithmetic operations that can be performed on numeric types. Below are some of the most commonly used operations:\n\nBasic Arithmetic Operations\nYou can perform basic arithmetic operations using standard operators:\n\nAddition: +\nSubtraction: -\nMultiplication: *\nDivision: / (returns a floating-point result) and // (returns a rational number)\n\n\na = 10\nb = 3\n\nsum = a + b\ndifference = a - b\nproduct = a * b\nquotient = a / b\nrational = a // b\n\njulia&gt; a = 10\njulia&gt; b = 3\njulia&gt; sum = 13\njulia&gt; difference = 7\njulia&gt; product = 30\njulia&gt; quotient = 3.3333333333333335\njulia&gt; rational = 10//3\n\n\n\n\nModulo Operation\nThe modulo operator % returns the remainder of a division operation. It is useful for determining if a number is even or odd, or for wrapping around values.\n\nmodulus_result = a % b  # remainder of 10 divided by 3\n\n1\n\n\n\n\nExponentiation\nYou can perform exponentiation using the ^ operator.\n\na^2          # 10 squared\n\n100\n\n\n\n\nUsing Arithmetic in Control Flow\nYou can combine arithmetic operations with control flow statements. For example, you can use the modulo operation to check if a number is even or odd:\n\nif a % 2 == 0\n    println(\"$a is even\")\nelse\n    println(\"$a is odd\")\nend\n\n10 is even\n\n\n\n\nSummary of Arithmetic Operations\n\n\n\nOperation\nSymbol\nExample\nResult\n\n\n\n\nAddition\n+\n5 + 3\n8\n\n\nSubtraction\n-\n5 - 3\n2\n\n\nMultiplication\n*\n5 * 3\n15\n\n\nDivision\n/\n5 / 2\n2.5\n\n\nModulo\n%\n5 % 2\n1\n\n\nExponentiation\n^\n2 ^ 3\n8\n\n\n\nThese arithmetic operations can be combined and nested to perform complex calculations as needed.",
    "crumbs": [
      "Content of the course",
      "Syntax Essentials and Scoping"
    ]
  },
  {
    "objectID": "src/syntax.html#functions",
    "href": "src/syntax.html#functions",
    "title": "Julia Syntax Essentials and Variable Scoping",
    "section": "Functions",
    "text": "Functions\nJulia offers flexible ways to define functions, with options for positional arguments, keyword arguments, optional arguments with default values, and variable-length arguments. Let’s explore each of these in detail.\n\nDefining Functions\nFunctions in Julia can be defined using either the function keyword or the assignment syntax.\n\n# Using the `function` keyword\nfunction add(a, b)\n    return a + b\nend\n\n# Using assignment syntax\nmultiply(a, b) = a * b\n\nadd(2, 3)\nmultiply(2, 3)\n\njulia&gt; add(2, 3) = 5\njulia&gt; multiply(2, 3) = 6\n\n\n\n\nPositional and Keyword Arguments\nIn Julia, functions can take both positional arguments and keyword arguments.\n\nPositional Arguments: These are listed first in the parameter list and must be provided in the correct order when the function is called. Positional arguments can have default values, but it’s not required.\nKeyword Arguments: Keyword arguments are specified after a semicolon (;) in the parameter list. These arguments must be provided by name when calling the function. Like positional arguments, keyword arguments can have default values, but they don’t have to.\n\n\nfunction greet(name; punctuation = \"!\")\n    return \"Hello, \" * name * punctuation\nend\n\nprintln(greet(\"Alice\"))\nprintln(greet(\"Alice\", punctuation = \"?\"))\n\nHello, Alice!\nHello, Alice?\n\n\nIn this example, punctuation is a keyword argument with a default value of \"!\". You could also define a keyword argument without a default value if needed.\n\n\nVariable Number of Arguments\nJulia functions can accept an arbitrary number of arguments using the splatting operator .... These arguments are gathered into a tuple.\n\nfunction sum_all(args...)\n    total = 0\n    for x in args\n        total += x\n    end\n    return total\nend\n\nsum_all(1, 2, 3, 4)\n\njulia&gt; sum_all(1, 2, 3, 4) = 10\n\n\n\n\nDefault Values for Optional Arguments\nIn Julia, you can assign default values to both positional and keyword arguments. When the function is called without specifying a value for an argument with a default, the default value is used.\n\nfunction power(base, exponent=2)\n    return base ^ exponent\nend\n\npower(3)      # Outputs: 9 (since exponent defaults to 2)\npower(3, 3)   # Outputs: 27\n\njulia&gt; power(3) = 9\njulia&gt; power(3, 3) = 27\n\n\n\n\nMultiple Optional Positional Arguments\nWhen a function has multiple optional positional arguments, Julia will use the default values for any arguments not provided, allowing flexible combinations.\n\nfunction calculate(a=1, b=2, c=3)\n    return a + b * c\nend\n\ncalculate()        # Outputs: 7  (1 + 2 * 3)\ncalculate(5)       # Outputs: 11 (5 + 2 * 3)\ncalculate(5, 4)    # Outputs: 17 (5 + 4 * 3)\ncalculate(5, 4, 1) # Outputs: 9  (5 + 4 * 1)\n\njulia&gt; calculate() = 7\njulia&gt; calculate(5) = 11\njulia&gt; calculate(5, 4) = 17\njulia&gt; calculate(5, 4, 1) = 9\n\n\nHere’s how the argument combinations work:\n\ncalculate() uses all default values: a=1, b=2, c=3.\ncalculate(5) overrides a, leaving b and c as defaults.\ncalculate(5, 4) overrides a and b, leaving c as the default.\ncalculate(5, 4, 1) overrides all arguments.\n\nThis flexibility makes it easy to call functions with varying levels of detail without explicitly specifying each parameter.\n\n\n\n\n\n\nTip\n\n\n\nIf a function has many optional arguments, consider using keyword arguments to improve readability and avoid confusion about the order of arguments.\n\n\n\n\nMutation and the Bang ! Convention\nIn Julia, functions that modify or mutate their arguments typically end with a !, following the “bang” convention. This is not enforced by the language but is a widely followed convention in Julia to indicate mutation.\n\nfunction add_one!(array)\n    for i in eachindex(array)\n        array[i] += 1\n    end\nend\n\narr = [1, 2, 3]\nadd_one!(arr)\narr  # Outputs: [2, 3, 4]\n\njulia&gt; arr = [1, 2, 3]\njulia&gt; add_one!(arr) = nothing\njulia&gt; arr = [2, 3, 4]\n\n\nIn this example, add_one! modifies the elements of the array arr. By convention, the ! at the end of the function name indicates that the function mutates its input.\n\n\nBroadcasting\nJulia supports broadcasting, a powerful feature that applies a function element-wise to arrays or other collections. Broadcasting is denoted by a . placed before the function call or operator.\n\n# Define a simple function\nfunction square(x)\n    return x^2\nend\n\n# Apply the function to a vector using broadcasting\nvec = [1, 2, 3, 4]\nsquared_vec = square.(vec)\n\nprintln(\"Original vector: \", vec)\nprintln(\"Squared vector: \", squared_vec)\n\nOriginal vector: [1, 2, 3, 4]\nSquared vector: [1, 4, 9, 16]\n\n\nIn this example:\n\nThe function square(x) is applied to each element of vec using the . operator.\nBroadcasting works seamlessly with both built-in and user-defined functions, making it easy to perform element-wise operations on arrays of any shape.\n\n\n\nReturn Values\nIn Julia, functions automatically return the last evaluated expression. However, you can use the return keyword to explicitly specify the output if needed.\nfunction multiply(a, b)\n    a * b  # Returns the result of a * b\nend",
    "crumbs": [
      "Content of the course",
      "Syntax Essentials and Scoping"
    ]
  },
  {
    "objectID": "src/syntax.html#scoping-and-closure",
    "href": "src/syntax.html#scoping-and-closure",
    "title": "Julia Syntax Essentials and Variable Scoping",
    "section": "Scoping and Closure",
    "text": "Scoping and Closure\nIn Julia, scoping rules determine the visibility and lifetime of variables. Understanding scope and closures is essential for writing efficient and error-free code.\n\nVariable Scope\nScope in Julia refers to the region of code where a variable is accessible. There are two primary scopes: global and local.\n\nGlobal Scope: Variables defined at the top level of a module or script are in the global scope and can be accessed from anywhere in that file. However, modifying global variables from within functions is generally discouraged.\n\n\nglobal_var = 10\n\nfunction access_global()\n    return global_var\nend\n\naccess_global()  # Outputs: 10\n\njulia&gt; access_global() = 10\n\n\n\nLocal Scope: Variables defined within a function or a block (e.g., loops or conditionals) have local scope and cannot be accessed outside of that block.\n\n\nfunction local_scope_example()\n    local_var = 5\n    return local_var\nend\n\nlocal_scope_example()\n\njulia&gt; local_scope_example() = 5\n\n\nIf you try to access local_var outside the function, you will get an error because it is not defined in the global scope.\n\nlocal_var  # This would cause an error, as local_var is not accessible here\n\nLoadError: UndefVarError: `local_var` not defined in `Main`\nSuggestion: check for spelling errors or missing imports.\nUndefVarError: `local_var` not defined in `Main`\nSuggestion: check for spelling errors or missing imports.\n\n\n\n\nScope of Variables in for Loops\nIn Julia, a for loop does create a new local scope for its loop variable when inside a function or another local scope. This means that a variable used as the loop variable will not overwrite an existing global variable with the same name in that context.\nHere’s an example:\n\ni = 10  # Define a global variable `i`\n\nfor i = 1:3\n    println(i)  # Prints 1, 2, and 3\nend\n\nprintln(\"Outside loop: i = \", i)  # Outputs: 10\n\n1\n2\n3\nOutside loop: i = 10\n\n\nIn this case, the initial value of i (10) is not affected by the loop because the for loop has its own local scope for i. After the loop completes, the global variable i retains its original value (10), demonstrating that the for loop did not alter it.\nHowever, if this code were inside a function, i would be entirely scoped within that function’s local environment, meaning any loop variables would only affect other variables within the function itself.\n\n\nNested Scopes\nJulia allows for nested functions, which can access variables in their enclosing scopes. This is known as lexical scoping.\n\nfunction outer_function(x)\n    y = 2\n    function inner_function(z)\n        return x + y + z\n    end\n    return inner_function\nend\n\nclosure = outer_function(3)\nclosure(4)  # Outputs: 9 (3 + 2 + 4)\n\njulia&gt; closure(4) = 9\n\n\nIn this example, inner_function forms a closure over the variables x and y, retaining access to them even after outer_function has finished executing.\n\n\nClosures\nA closure is a function that captures variables from its surrounding lexical scope, allowing the function to use these variables even after the scope where they were defined has ended. Closures are especially useful for creating customized functions or “function factories.”\n\nExample: Using a Global Variable vs. Capturing a Variable in a Closure\nTo illustrate the difference between referencing a global variable and capturing a variable in a closure, let’s first create a function that uses a global variable:\n\nfactor = 2\n\nfunction multiply_by_global(x)\n    return x * factor\nend\n\nmultiply_by_global(5)  # Outputs: 10\n\n# Update the global variable `factor`\nfactor = 3\nmultiply_by_global(5)  # Outputs: 15 (factor is now 3)\n\njulia&gt; factor = 2\njulia&gt; function multiply_by_global(x)\n    return x * factor\nend\njulia&gt; multiply_by_global(5) = 10\njulia&gt; factor = 3\njulia&gt; multiply_by_global(5) = 15\n\n\nIn this example, multiply_by_global uses the global variable factor, so whenever factor is updated, the result of calling multiply_by_global changes.\n\n\nExample: Capturing a Variable in a Closure\nNow, let’s use a closure to capture the factor variable inside a function. Here, the captured value of factor remains fixed at the time the closure was created, regardless of changes to the variable afterward.\n\nfunction make_multiplier(factor)\n    return (x) -&gt; x * factor  # Returns a closure that captures `factor`\nend\n\ndouble = make_multiplier(2)   # `factor` is captured as 2 in this closure\ntriple = make_multiplier(3)   # `factor` is captured as 3 in this closure\n\ndouble(5)  # Outputs: 10\ntriple(5)  # Outputs: 15\n\n# Even if we change `factor` globally, it doesn't affect the closure\nfactor = 4\ndouble(5)  # Still outputs: 10\ntriple(5)  # Still outputs: 15\n\njulia&gt; function make_multiplier(factor)\n    return (x-&gt;begin\n                x * factor\n            end)\nend\njulia&gt; double = make_multiplier(2)\njulia&gt; triple = make_multiplier(3)\njulia&gt; double(5) = 10\njulia&gt; triple(5) = 15\njulia&gt; factor = 4\njulia&gt; double(5) = 10\njulia&gt; triple(5) = 15\n\n\nIn this example, make_multiplier returns a function that captures the factor variable when the closure is created. This means that double will always multiply by 2, and triple will always multiply by 3, regardless of any subsequent changes to factor.\n\n\n\nSummary\nUsing closures in Julia allows you to “lock in” the values of variables from an outer scope at the time of the closure’s creation. This differs from referencing global variables directly, where any changes to the variable are reflected immediately. Closures are particularly useful for creating function factories or callbacks that need to retain specific values independently of changes in the global scope.\nUnderstanding scope is crucial for performance in Julia. Defining variables within a local scope, such as inside functions, can lead to more efficient code execution. Global variables can lead to performance penalties due to type instability.\nIn summary, scoping rules in Julia allow for clear management of variable accessibility and lifespan, while closures enable powerful programming patterns by capturing the context in which they are created. Understanding these concepts is key to writing effective Julia code.",
    "crumbs": [
      "Content of the course",
      "Syntax Essentials and Scoping"
    ]
  },
  {
    "objectID": "src/syntax.html#exercices",
    "href": "src/syntax.html#exercices",
    "title": "Julia Syntax Essentials and Variable Scoping",
    "section": "Exercices",
    "text": "Exercices\n\nExercise 1: Temperature Converter\nWrite a function convert_temperature that takes a temperature value and a keyword argument unit that can either be \"C\" for Celsius or \"F\" for Fahrenheit. The function should convert the temperature to the other unit and return the converted value. Use a conditional statement to determine the conversion formula:\n\nIf the unit is \"C\", convert to Fahrenheit using the formula: \n  F = C \\times \\frac{9}{5} + 32\n\nIf the unit is \"F\", convert to Celsius using the formula: \n  C = (F - 32) \\times \\frac{5}{9}\n\n\nExample Output:\nprintln(convert_temperature(100, unit=\"C\"))  # Outputs: 212.0\nprintln(convert_temperature(32, unit=\"F\"))    # Outputs: 0.0\n\n\n\n\n\n\nTo go further for Exercise 1: Temperature Converter\n\n\n\n\n\nIf the unit provided is not \"C\" or \"F\", you can raise an error using the throw statement along with ArgumentError. This way, you can inform the user that the input is invalid.\n\n\n\n\n\n\n\n\n\nCorrection of Exercise 1: Temperature Converter\n\n\n\n\n\n\nfunction convert_temperature(value; unit)\n    if unit == \"C\"\n        return value * 9/5 + 32  # Convert Celsius to Fahrenheit\n    elseif unit == \"F\"\n        return (value - 32) * 5/9  # Convert Fahrenheit to Celsius\n    else\n        throw(ArgumentError(\"Unit must be 'C' or 'F'\"))\n    end\nend\n\nprintln(convert_temperature(100, unit=\"C\"))  # Outputs: 212.0\nprintln(convert_temperature(32, unit=\"F\"))    # Outputs: 0.0\n\n212.0\n0.0\n\n\n\n\n\n\n\nExercise 2: Factorial Function with Closure\nCreate a function make_factorial that returns a closure. This closure should compute the factorial of a number. The closure should capture a variable that keeps track of the number of times it has been called. When the closure is called, it should return the factorial of the number and the call count.\nExample Output:\nfactorial_closure = make_factorial()\nresult, count = factorial_closure(5)\nprintln(result)  # Outputs: 120\nresult, count = factorial_closure(3)\nprintln(result)  # Outputs: 6\nprintln(\"Function called \", count, \" times\")  # Outputs: 2 times\n\n\n\n\n\n\nHint Exercise 2: Factorial Function with Closure\n\n\n\n\n\nWhen returning the results from the closure, you can return a pair of values by creating a tuple. In Julia, tuples are created using parentheses, like this: (value1, value2).\n\n\n\n\n\n\n\n\n\nCorrection of Exercise 2: Factorial Function with Closure\n\n\n\n\n\n\nfunction make_factorial()\n    counter = 0 # Variable to keep track of calls\n    function factorial(n::Int)\n        y = 1\n        for i ∈ 2:n\n            y *= i \n        end\n        counter += 1\n        return y, counter\n    end\n    return factorial \nend\n\nfactorial_closure = make_factorial()\nresult, count = factorial_closure(5)\nprintln(result)  # Outputs: 120\nresult, count = factorial_closure(3)\nprintln(result)  # Outputs: 6\nprintln(\"Function called \", count, \" times\")  # Outputs: 2 times\n\n120\n6\nFunction called 2 times\n\n\n\n\n\n\n\nExercise 3: Filter Even Numbers\nWrite a function filter_even that takes an array of integers as input and returns a new array containing only the even numbers from the input array. Use a loop and a conditional statement to check each number.\nAdditionally, implement a helper function is_even that checks if a number is even. Use the filter_even function to filter an array of numbers, and print the result.\nExample Output:\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\neven_numbers = filter_even(numbers)\nprintln(even_numbers)  # Outputs: [2, 4, 6, 8, 10]\n\n\n\n\n\n\nHint for Exercise 3: Filter Even Numbers\n\n\n\n\n\nTo add elements to an array in Julia, use the push! function. This function takes two arguments: the array you want to modify and the element to add to that array.\n\n\n\n\n\n\n\n\n\nCorrection of Exercise 3: Filter Even Numbers\n\n\n\n\n\n\nfunction is_even(x)\n    return x % 2 == 0\nend\n\nfunction filter_even(numbers)\n    even_numbers = []\n    for number in numbers\n        if is_even(number)\n            push!(even_numbers, number)\n        end\n    end\n    return even_numbers\nend\n\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\neven_numbers = filter_even(numbers)\nprintln(even_numbers)  # Outputs: [2, 4, 6, 8, 10]\n\nAny[2, 4, 6, 8, 10]\n\n\n\n\n\n\n\nExercise Instructions\n\nFor each exercise, implement the required functions in a new Julia script or interactive session.\nTest your functions with different inputs to ensure they work as expected.\nComment on your code to explain the logic behind each part, especially where you utilize control flow and scope.",
    "crumbs": [
      "Content of the course",
      "Syntax Essentials and Scoping"
    ]
  },
  {
    "objectID": "src/miscellaneous.html",
    "href": "src/miscellaneous.html",
    "title": "Miscellaneous",
    "section": "",
    "text": "See also:\n\nAuto diff and Differentiable programming\nOptimization with JuMP\nJulia basic tutorial\nIntroduction to Julia\n\n\n\n\n Back to top",
    "crumbs": [
      "Content of the course",
      "Work in progress",
      "Miscellaneous"
    ]
  },
  {
    "objectID": "src/getting_started.html",
    "href": "src/getting_started.html",
    "title": "Getting Started with Julia",
    "section": "",
    "text": "This page provides an introduction to the Julia programming language, including its key features and installation process. You’ll learn how to install Julia on different operating systems and how to verify the installation. It also covers using the Julia REPL for interactive coding, creating and running Julia scripts, and managing packages with Julia’s built-in package manager, Pkg. Additionally, this page provides resources for learning and getting help with Julia, including official documentation, community platforms, and an overview of the Julia ecosystem.\nKey Topics:",
    "crumbs": [
      "Content of the course",
      "Getting started"
    ]
  },
  {
    "objectID": "src/getting_started.html#introduction-to-julia-programming-language",
    "href": "src/getting_started.html#introduction-to-julia-programming-language",
    "title": "Getting Started with Julia",
    "section": "Introduction to Julia Programming Language",
    "text": "Introduction to Julia Programming Language\nWelcome to the world of Julia! This section will introduce you to the language, explaining why it’s gaining popularity, and highlighting some key features that make Julia a unique tool for scientific computing and general-purpose programming.\n\nWhat is Julia?\nJulia is a high-level, high-performance programming language primarily designed for technical computing. It combines the best features of other programming languages, including Python’s ease of use, C’s speed, and MATLAB’s support for numerical computation. Julia is open-source and has become a go-to language for scientific research, data analysis, and machine learning applications.\n\n\nWhy Julia?\n\nHigh performance: Julia is designed for performance from the ground up. It often performs on par with statically typed languages like C or Fortran, thanks to Just-In-Time (JIT) compilation using LLVM.\nMultiple dispatch: Julia uses multiple dispatch as its core paradigm, which allows for highly flexible and efficient function definitions.\nDesigned for scientific computing: Julia excels in areas such as linear algebra, numerical analysis, and optimization, making it a great choice for data-heavy fields like economics, physics, and engineering.\nEase of use: Julia offers a simple, intuitive syntax similar to Python and MATLAB, which makes it easy to learn and use, even for those with little programming experience.",
    "crumbs": [
      "Content of the course",
      "Getting started"
    ]
  },
  {
    "objectID": "src/getting_started.html#installing-julia",
    "href": "src/getting_started.html#installing-julia",
    "title": "Getting Started with Julia",
    "section": "Installing Julia",
    "text": "Installing Julia\n\nDownload Julia\nTo get started with Julia, you first need to install the language on your computer. The official Julia website provides the installation files for various operating systems, including Windows, macOS, and Linux. Follow these steps:\n\nVisit the official Julia Downloads page.\nChoose the appropriate version of Julia for your operating system.\nDownload the installer (the latest stable version is recommended for most users).\n\n\n\nInstallation Instructions\nBefore you can start using Julia, you need to install it on your system. Below are the steps for installing Julia on different operating systems: Mac, Linux, and Windows.\n\nMac / LinuxWindows\n\n\nTo install the latest stable version of Julia on Mac or Linux, follow these simple steps:\n\nOpen your terminal.\nRun the following command to download and install Julia:\n\ncurl -fsSL https://install.julialang.org | sh\nThis command downloads the Julia installation script and runs it automatically. It will install Julia and place it in your /usr/local/bin directory by default.\n\n\nTo install Julia on Windows, follow these steps:\n\nOpen the Microsoft Store page for Julia.\nClick “Get” to download and install the latest version of Julia from the Microsoft Store.\n\nAlternatively, you can install Julia using the Windows Package Manager (winget). Open the command prompt and run the following command:\nwinget install julia -s msstore\nAfter installation, you can launch Julia by searching for it in the Start menu or by running julia in the command prompt.\n\n\n\n\n\nVerify Installation\nAfter installation, you can verify that Julia is correctly installed by opening a terminal or command prompt and typing the following command:\njulia\nThis will launch the Julia REPL (Read-Eval-Print Loop), where you can start running Julia commands interactively. You should see something similar to the following:\n\n\n               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type \"?\" for help, \"]?\" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.11.6 (2025-07-09)\n _/ |\\__'_|_|_|\\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\n\njulia&gt;\n\n\nIf you see this prompt, it means Julia is installed and working correctly!\n\n\nDiscover the Package Manager\nJulia includes a built-in package manager, Pkg, that allows you to easily manage external packages (libraries) for your projects.\n\nTo start using Pkg, open the Julia REPL and type:\nusing Pkg\nYou can install a package by running:\nPkg.add(\"PackageName\")\n\nFor example, to install the popular plotting package Plots, run:\nPkg.add(\"Plots\")\nThis will download and install the package, making it available for use in your Julia scripts.",
    "crumbs": [
      "Content of the course",
      "Getting started"
    ]
  },
  {
    "objectID": "src/getting_started.html#using-the-julia-repl",
    "href": "src/getting_started.html#using-the-julia-repl",
    "title": "Getting Started with Julia",
    "section": "Using the Julia REPL",
    "text": "Using the Julia REPL\nThe Julia REPL (Read-Eval-Print Loop) is an interactive command-line environment for executing Julia code. It allows you to run Julia code line-by-line, evaluate expressions, and see the results immediately.\n\nStarting the REPL\nTo start the Julia REPL, open your terminal or command prompt and simply type:\njulia\nYou should see the Julia prompt, which looks like this:\n\n\n               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type \"?\" for help, \"]?\" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.11.6 (2025-07-09)\n _/ |\\__'_|_|_|\\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\n\njulia&gt;\n\n\nThis is the REPL where you can start typing Julia expressions.\n\n\nBasic Commands\nIn the REPL, you can type expressions and commands. For example:\n\nTo perform a simple arithmetic operation, type:\n\n3 + 4\nThe result will appear right below the command, like so:\n7\n\nTo assign a value to a variable, use the = sign:\n\nx = 10\nNow, x holds the value 10. You can use it in further expressions:\nx * 2\nThe result will be:\n20\n\n\nUsing REPL Features\nThe Julia REPL has several features that make it more convenient to use:\n\nHistory: You can use the up and down arrow keys to scroll through your command history and reuse previous commands.\nTab Completion: Type part of a function or variable name and press Tab to automatically complete it or show suggestions.\nHelp: Type ? followed by a function or type name to get documentation directly in the REPL. For example:\n\n?sum\nThis will show information about the sum function.\n\nExiting the REPL: To exit the REPL, simply type:\n\nexit()\nOr press Ctrl-D (on most systems).\n\n\nREPL Modes\nThe Julia REPL has different prompt modes that can be very useful to install / remove packages, run shell commands, search for help, etc. The different modes are:\n\nThe Julian mode\nHelp mode\nPackage mode\nShell mode\n\nVisit the command-line REPL page for more details.\n\nHelp modePackage modeShell mode\n\n\nBy pressing ? you can obtain information and metadata about Julia objects (functions, types, etc.) or unicode symbols. The query fetches the docstring of the object, which explains how to use it.\nhelp?&gt; println\nIf you don’t know the exact name you are looking for, type a word surrounded by quotes to see in which docstrings it pops up. To come back to Julia mode, hit backspace.\n\n\nBy pressing ] you access Pkg.jl, Julia’s integrated package manager. Please visit the documentation for details. Pkg.jl allows you to:\n\n]activate different local, shared or temporary environments;\n]instantiate them by downloading the necessary packages;\n]add, ]update (or ]up) and ]remove (or ]rm) packages;\nget the ]status (or ]st) of your current environment.\n\nAs an illustration, we download the package Plots.jl inside our current environment:\npkg&gt; add Plots\nNote that you can do the same in Julia mode:\njulia&gt; using Pkg\njulia&gt; Pkg.rm(\"Plots\")\nThe package mode itself also has a help mode, accessed with ?. To come back to Julia mode, hit backspace.\n\n\nBy pressing ; you enter a terminal, where you can execute any command you want. Here’s an example for Unix systems:\nshell&gt; pwd\nTo come back to Julia mode, hit backspace.",
    "crumbs": [
      "Content of the course",
      "Getting started"
    ]
  },
  {
    "objectID": "src/getting_started.html#running-julia-scripts",
    "href": "src/getting_started.html#running-julia-scripts",
    "title": "Getting Started with Julia",
    "section": "Running Julia Scripts",
    "text": "Running Julia Scripts\nWhile the Julia REPL is great for interactive experimentation, you’ll often want to write and run larger programs. This is where running Julia scripts comes in.\n\nCreating a Julia Script\nA Julia script is a plain text file that contains Julia code. You can create a Julia script using any text editor, such as VS Code, Sublime Text, or even a simple text editor.\nSave the file with the .jl extension, for example myscript.jl.\n\n\nRunning a Julia Script\nTo run a Julia script, open your terminal or command prompt, navigate to the directory where the script is located, and then use the following command:\njulia myscript.jl\nThis will execute the code in myscript.jl and output any results in the terminal. If your script includes print statements, those outputs will be displayed. See the command-line interface page for more details.\n\n\nExample: Running a Script\nHere’s an example of a simple Julia script:\n# myscript.jl\nprintln(\"Hello, World!\")\nx = 10\ny = 20\nprintln(\"The sum of x and y is \", x + y)\nTo run this script, save it as myscript.jl and use the command:\njulia myscript.jl\nThe output will look like this:\nHello, World!\nThe sum of x and y is 30\n\n\nRunning Scripts with Arguments\nYou can also pass command-line arguments to a Julia script. For example, let’s modify the script to accept arguments:\n# args_example.jl\nprintln(\"Arguments passed to the script: \", ARGS)\nNow, when running the script, you can pass arguments like this:\njulia args_example.jl arg1 arg2 arg3\nThe output will be:\nArguments passed to the script: [\"arg1\", \"arg2\", \"arg3\"]\nYou can access the arguments as elements of the ARGS array within your script.\n\n\nRunning Julia Scripts from the REPL\nYou can also run Julia scripts directly from the REPL by using the include() function. To run the myscript.jl script, for example:\ninclude(\"myscript.jl\")\nThis command will execute the code in the script, and you’ll see the output in the REPL.\n\n\nRunning Julia Scripts in IDEs\nIf you’re using an IDE like VS Code with the Julia extension, you can run the script directly from within the editor by pressing the “Run” button or using the appropriate keyboard shortcut. This is convenient for testing and iterating on your code without having to switch back and forth between the editor and the terminal. See the Running Code page from Julia in VS Code documentation for more details.",
    "crumbs": [
      "Content of the course",
      "Getting started"
    ]
  },
  {
    "objectID": "src/getting_started.html#editors-and-ides",
    "href": "src/getting_started.html#editors-and-ides",
    "title": "Getting Started with Julia",
    "section": "Editors and Ides",
    "text": "Editors and Ides\nWhile any text editor can be used to write Julia code, Integrated Development Environments (IDEs) significantly enhance the programming experience. Notable options for Julia include Visual Studio Code (VS Code), Jupyter, Pluto.jl, Vim, and Emacs. Each of these editors offers unique features like interactive environments, real-time code feedback, and specialized plugins for a smoother development process. For instance, VS Code with the Julia extension is the most feature-rich IDE for Julia, while Jupyter provides an interactive notebook environment. Pluto.jl focuses on reactive notebooks, and Vim and Emacs offer efficient, customizable text editing solutions.\nThe best IDE for Julia is Visual Studio Code, or VS Code, developed by Microsoft. Indeed, the Julia VS Code extension is the most feature-rich of all Julia IDE plugins. You can download it from the VS Code Marketplace and read its documentation.\n\n\n\n\n\n\nTip\n\n\n\nTo use Julia in Visual Studio Code, please follow these steps, where you can find how to install Julia, VS Code and the necessary extensions.\nTo gain time, you can learn the keyboard shortcuts for:\n\nWindows,\nmacOS,\nLinux.\n\n\n\n\nVS CodeJupyterPluto.jlVimEmacs\n\n\n  \nJulia for Visual Studio Code is a powerful, free IDE for the Julia language. Visual Studio Code is a powerful and customizable editor. With a completely live environment, Julia for VS Code aims to take the frustration and guesswork out of programming and put the fun back in. We build on Julia’s unique combination of ease-of-use and performance. Beginners and experts can build better software more quickly, and get to a result faster. Julia is an officially supported language on the VS Code documentation.\n\n\n  \nYou can write Jupyter notebooks and use the Jupyter interactive environment. To do so you need to install the IJulia.jl package. IJulia is a Julia-language backend combined with the Jupyter interactive environment (also used by IPython). This combination allows you to interact with the Julia language using Jupyter/IPython’s powerful graphical notebook, which combines code, formatted text, math, and multimedia in a single document. IJulia is a Jupyter language kernel and works with a variety of notebook user interfaces. In addition to the classic Jupyter Notebook, IJulia also works with JupyterLab, a Jupyter-based integrated development environment for notebooks and code. The nteract notebook desktop supports IJulia with detailed instructions for its installation with nteract. Please visit this webpage to get a tutorial on how to use Julia in Jupyter notebook.\n\n\n   Simple reactive notebooks\n\n\n   Vim plugin\n\n\n   Emacs plugin",
    "crumbs": [
      "Content of the course",
      "Getting started"
    ]
  },
  {
    "objectID": "src/getting_started.html#julia-documentation",
    "href": "src/getting_started.html#julia-documentation",
    "title": "Getting Started with Julia",
    "section": "Julia Documentation",
    "text": "Julia Documentation\nOne of the key strengths of Julia is its comprehensive and easy-to-navigate documentation. Julia’s official documentation provides detailed explanations of the language features, standard libraries, and tools available for developers.\n\nOfficial Documentation\nThe official Julia documentation is a complete reference guide for the language. You can find it here:\n\nJulia Documentation Website\n\nThis documentation covers everything from basic syntax to advanced topics like parallel computing and package management.\nExample. Search how to compute the norm of a vector.\n\nThe norm function comes from the standard librairy LinearAlgebra.\n\nHowever, we are not directly at the right place, so I recommend to use the Search docs field.\n\nAnd now, we have the documentation.\n\n\n\n\n\n\n\nNote\n\n\n\nYou can also access the Julia documentation directly from the Julia REPL using the ? (help) command.\n\n\n\n\nAccessing Help in the REPL\nThe REPL provides a built-in help system that can assist you in looking up functions, types, and more. Here’s how you can use it:\n\nLook up a function or keyword: Type ? followed by the function name or keyword you want help with.\n?println\nThis will display the documentation for the println function.\nSearch for a keyword: You can also type just ? followed by a search term to find relevant functions or types in the documentation.\n?array\nThis will display documentation related to arrays in Julia.\n\n\n\nAdditional Resources\n\nJulia Language GitHub: Julia GitHub Repository — Contains the source code and development discussion.\nJulia Discourse: Julia Discourse Forum — A community forum where you can ask questions, share ideas, and discuss Julia-related topics.\nJuliaLang Slack: Join Slack Community — An official Slack workspace for the Julia community.\nJulia Community: Julia Community — A hub for Julia community resources, including events, blogs, and videos.",
    "crumbs": [
      "Content of the course",
      "Getting started"
    ]
  },
  {
    "objectID": "src/getting_started.html#working-with-julia-packages",
    "href": "src/getting_started.html#working-with-julia-packages",
    "title": "Getting Started with Julia",
    "section": "Working with Julia Packages",
    "text": "Working with Julia Packages\nJulia has a rich ecosystem of packages that extend the language’s capabilities for various domains, such as machine learning, data science, optimization, and more. The Julia Packages webpage is the official source for Julia packages. This section will cover how to manage and use packages in Julia.\n\nStandard Libraries in Julia\nJulia comes with a set of standard libraries, which are built-in packages available with the installation. These libraries cover a wide range of functionality, from mathematical operations to file handling and system utilities. You do not need to install them separately; they are ready to be used as soon as you start Julia.\nOne commonly used standard library is LinearAlgebra, which provides tools for linear algebra, such as matrix factorizations and vector operations.\n\nExample: Computing the Norm of a Vector\nThe LinearAlgebra library can be used to compute the norm of a vector. Here’s how you can do that:\n\nusing LinearAlgebra\n\n# Define a vector\nv = [3, 4]\n\n# Compute the Euclidean norm (magnitude) of the vector\nnorm_v = norm(v)\n\nprintln(\"The norm of the vector is: \", norm_v)\n\nThe norm of the vector is: 5.0\n\n\nIn this example, the norm() function calculates the Euclidean norm (or 2-norm) of the vector v, which in this case is\n\n\\sqrt{3^2 + 4^2} = 5.\n\nThese standard libraries help you to get started quickly with common tasks, without the need to install additional packages.\n\n\n\nInstalling Packages\nTo install a package, you can use the Pkg module, which is part of Julia’s standard library. Here’s how to install a package:\n\nEnter the package manager mode by typing ] in the REPL.\nThen, use the add command to install a package.\n\nExample:\n] add DataFrames\nThis will install the DataFrames package, which is widely used for data manipulation in Julia. To get the list of installed packages, type:\n] status\n\n\n\n\n\n\nNote\n\n\n\nYou can also install the package directly from the Julia mode:\nusing Pkg\nPkg.add(\"DataFrames\")\n\n\n\n\nUsing Installed Packages\nOnce a package is installed, you can use it by importing it into your code using the using keyword. This makes the functions and types of the package available for use.\nExample:\n\nusing DataFrames\n\ndf = DataFrame(A = 1:4, B = [\"a\", \"b\", \"c\", \"d\"])\n\n4×2 DataFrame\n\n\n\nRow\nA\nB\n\n\n\nInt64\nString\n\n\n\n\n1\n1\na\n\n\n2\n2\nb\n\n\n3\n3\nc\n\n\n4\n4\nd\n\n\n\n\n\n\nThis creates a simple DataFrame object with two columns A and B.\n\n\nUpdating Packages\nTo update the packages installed in your environment to their latest versions, use the update command in the package manager.\nExample:\n] update\nYou can also update a specific package by running:\n] update PackageName\n\n\n\n\n\n\nNote\n\n\n\nYou can also update packages directly from the Julia mode:\nusing Pkg\nPkg.update()\n# or\nPkg.update(\"PackageName\")\n\n\n\n\nRemoving Packages\nIf you no longer need a package, you can remove it using the rm command.\nExample:\n] rm DataFrames\nThis will uninstall the DataFrames package from your environment.\n\n\n\n\n\n\nNote\n\n\n\nYou can also remove packages directly from the Julia mode:\nusing Pkg\nPkg.rm(\"DataFrames\")\n\n\n\n\nPackage Environments\nIn Julia, you can manage different environments, each with its own set of installed packages. This allows you to work on multiple projects with different dependencies without conflicts. You can create a new environment by navigating to a directory and typing:\n] activate .\nThis will activate the environment in the current directory. You can also specify a different directory or environment path by providing it after activate. If you want to come back to the global environment, type:\n] activate\nNote that the packages installed in the global environment are visible from any other environment. See the Working with Environments page for more details.\n\n\n\n\n\n\nNote\n\n\n\nYou can also activate environments directly from the Julia mode. For instance, for the current directory:\nusing Pkg\nPkg.activate(\".\")\n\n\n\n\nConclusion\nWorking with packages is essential to leveraging Julia’s powerful ecosystem. Understanding how to install, update, and remove packages, as well as using environments to manage project-specific dependencies, will help you make the most out of Julia’s vast libraries.",
    "crumbs": [
      "Content of the course",
      "Getting started"
    ]
  },
  {
    "objectID": "src/getting_started.html#julia-ecosystem",
    "href": "src/getting_started.html#julia-ecosystem",
    "title": "Getting Started with Julia",
    "section": "Julia Ecosystem",
    "text": "Julia Ecosystem\nThe Julia programming language has a rich ecosystem of tools, platforms, and communities that can help you develop, deploy, and scale your applications. This section will introduce some key components of the Julia ecosystem, including JuliaHub, JuliaSim, JuliaCon, and other important resources. The Julia ecosystem is growing rapidly, offering a wide range of tools for scientific computing, data science, and application development. Platforms like JuliaHub, simulation tools like JuliaSim, and community events like JuliaCon are all central to the ecosystem and provide invaluable resources to Julia users.\n\nJuliaHub\nJuliaHub is an online platform developed by Julia Computing that provides cloud-based access to Julia environments. It offers managed Julia instances, making it easier to share and deploy Julia-based projects without the need to worry about local setup. JuliaHub also supports collaboration on Julia projects and integrates with popular tools such as Jupyter notebooks.\nFeatures of JuliaHub include:\n\nCloud-based Julia environments: Run Julia code on the cloud without any installation.\nPackage management: Seamless integration with Julia’s package manager.\nCollaboration: Share Julia code and data with colleagues and collaborators.\nJupyter notebooks: Use Jupyter notebooks hosted on JuliaHub for interactive computing.\n\n\n\nJuliaSim\nJuliaSim is a collection of tools and libraries for modeling and simulation, built using Julia. It is designed for systems simulation in fields such as engineering, physics, and finance. JuliaSim offers several packages and tools to help you build and simulate complex models, as well as visualize and analyze the results.\nFeatures of JuliaSim include:\n\nDifferential equation solving: Tools like DifferentialEquations.jl are used to solve complex systems of differential equations.\nSimulations in science and engineering: Use JuliaSim to simulate and analyze physical, chemical, and biological systems.\nFast performance: The high-performance capabilities of Julia make JuliaSim ideal for computationally intensive simulations.\n\n\n\nJuliaCon\nJuliaCon is the annual conference for the Julia community, where developers, researchers, and users come together to share the latest developments, discuss best practices, and showcase their Julia projects. JuliaCon features keynote speakers, tutorials, workshops, and talks on a wide range of topics related to Julia programming.\nKey features of JuliaCon:\n\nWorkshops and tutorials: Learn Julia directly from experts through hands-on workshops.\nNetworking: Meet fellow Julia users, contributors, and researchers to collaborate on projects and research.\nTalks and presentations: Hear about cutting-edge developments in Julia from experts in various fields.",
    "crumbs": [
      "Content of the course",
      "Getting started"
    ]
  },
  {
    "objectID": "src/modules_and_packages.html",
    "href": "src/modules_and_packages.html",
    "title": "Modules and packages",
    "section": "",
    "text": "Modules documentation\nEnvironment documentation\nCreating packages documentation",
    "crumbs": [
      "Content of the course",
      "Work in progress",
      "Modules and Packages"
    ]
  },
  {
    "objectID": "src/modules_and_packages.html#references",
    "href": "src/modules_and_packages.html#references",
    "title": "Modules and packages",
    "section": "",
    "text": "Modules documentation\nEnvironment documentation\nCreating packages documentation",
    "crumbs": [
      "Content of the course",
      "Work in progress",
      "Modules and Packages"
    ]
  },
  {
    "objectID": "src/advanced-types.html",
    "href": "src/advanced-types.html",
    "title": "Advanced Types and Error Handling in Julia",
    "section": "",
    "text": "In this section, we will delve into some of the more advanced features of Julia’s type system and error handling. We will explore the hierarchical structure of types, how to define and work with parametric types, as well as how to handle type conversions and promotions. Additionally, we will look at how to manage errors in Julia, including common error types and exception handling mechanisms.\nBy the end of this page, you’ll have a deeper understanding of Julia’s flexible and powerful type system, which is essential for writing efficient, type-safe code. We will also cover how to manage and handle errors gracefully to ensure that your programs run smoothly.\nTopics Covered:",
    "crumbs": [
      "Content of the course",
      "Type System and Error Handling"
    ]
  },
  {
    "objectID": "src/advanced-types.html#type-hierarchies",
    "href": "src/advanced-types.html#type-hierarchies",
    "title": "Advanced Types and Error Handling in Julia",
    "section": "Type Hierarchies",
    "text": "Type Hierarchies\nIn Julia, types are organized into a hierarchy with Any as the root. At the top, Any is the most general type, and all other types are subtypes of Any. The type hierarchy enables Julia to provide flexibility while supporting efficient dispatch based on types.\n\nusing GraphRecipes, Plots\ndefault(size=(800, 800))\nplot(AbstractFloat, fontsize=10, nodeshape=:rect, nodesize=0.08)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAbstract and Concrete Types\nTypes in Julia can be abstract or concrete:\n\nAbstract types serve as nodes in the hierarchy but cannot be instantiated. They provide a framework for organizing related types.\nConcrete types can be instantiated and are the actual types used for values.\n\nFor example, Julia’s Real and AbstractFloat types are abstract, while Int64 and Float64 are concrete subtypes.\n\nn::Int64 = 42   # Int64 is a concrete type\ntypeof(n)       # Output: Int64 (concrete type)\nr::Real = 3.14  # Real is an abstract type\ntypeof(r)       # Output: Float64 (concrete type)\n\njulia&gt; n::Int64 = 42\njulia&gt; typeof(n) = Int64\njulia&gt; r::Real = 3.14\njulia&gt; typeof(r) = Float64\n\n\n\n\nChecking if a Type is Concrete\nIn Julia, you can use the isconcretetype function to check if a type is concrete (meaning it can be instantiated) or abstract (which serves as a blueprint for other types but cannot be instantiated directly).\n\nisconcretetype(Int64)\nisconcretetype(AbstractFloat)\n\njulia&gt; isconcretetype(Int64) = true\njulia&gt; isconcretetype(AbstractFloat) = false\n\n\nThe isconcretetype function returns true for concrete types (like Int64 or Float64) and false for abstract types (like AbstractFloat or Real).\n\n\nGet the Type of a Variable\nYou can use the typeof() function to get the type of a variable:\n\na = 42\ntypeof(a)\n\njulia&gt; a = 42\njulia&gt; typeof(a) = Int64\n\n\nThe typeof() function returns the concrete type of the variable.\n\n\nExample\nLet’s instantiate a variable with a specific concrete type, check its type using typeof(), and verify if it’s concrete using isconcretetype:\n\na = 3.14\ntypeof(a)\nisconcretetype(typeof(a))\n\njulia&gt; a = 3.14\njulia&gt; typeof(a) = Float64\njulia&gt; isconcretetype(typeof(a)) = true\n\n\n\n\nThe isa Operator\nThe isa operator is used to check if a value is an instance of a specific type:\n\na = 42\na isa Int64\na isa Number\na isa Float64\n\njulia&gt; a = 42\njulia&gt; a isa Int64 = true\njulia&gt; a isa Number = true\njulia&gt; a isa Float64 = false\n\n\nThe isa operator is often used for type checking within functions or when validating data.\n\n\nThe &lt;: Operator\nThe &lt;: operator checks if a type is a subtype of another type in the hierarchy. It can be used for checking if one type is a more general or more specific type than another:\n\nInt64 &lt;: Real\nFloat64 &lt;: Real\nReal &lt;: Number\nNumber &lt;: Real\n\njulia&gt; Int64 &lt;: Real = true\njulia&gt; Float64 &lt;: Real = true\njulia&gt; Real &lt;: Number = true\njulia&gt; Number &lt;: Real = false\n\n\n\n\nCreating Custom Abstract Types\nJulia allows you to create your own abstract types. For example, you can define a custom abstract type Shape, and create concrete subtypes like Circle and Rectangle.\n\n# Define abstract type\nabstract type Shape end\n\n# Define concrete subtypes\nstruct Circle &lt;: Shape\n    radius::Float64\nend\n\nstruct Rectangle &lt;: Shape\n    width::Float64\n    height::Float64\nend\n\n# Create instances\ncircle = Circle(5.0)\nrectangle = Rectangle(3.0, 4.0)\n\n# Check if they are subtypes of Shape\ncircle isa Shape\nrectangle isa Shape\n\njulia&gt; circle isa Shape = true\njulia&gt; rectangle isa Shape = true\n\n\n\n\nGetting Subtypes and Parent Types\nIn Julia, you can use the subtypes() function to find all direct subtypes of a given type. Additionally, the supertypes() function can be used to get the entire chain of parent (super) types for a given type.\n\nGetting Subtypes\nTo find all direct subtypes of a specific type, you can use the subtypes() function. Here’s an example:\n\nsubtypes(AbstractFloat)\n\n5-element Vector{Any}:\n BigFloat\n Core.BFloat16\n Float16\n Float32\n Float64\n\n\nThis will return all direct subtypes of AbstractFloat. To visualize the type hierarchy, you can use the plot function from the GraphRecipes package or for a textual representation, you can do the following:\n\nusing AbstractTrees\nAbstractTrees.children(d::DataType) = subtypes(d)\nprint_tree(Real)\n\nReal\n├─ AbstractFloat\n│  ├─ BigFloat\n│  ├─ BFloat16\n│  ├─ Float16\n│  ├─ Float32\n│  └─ Float64\n├─ AbstractIrrational\n│  ├─ Irrational\n│  └─ IrrationalConstant\n│     ├─ Fourinvπ\n│     ├─ Fourπ\n│     ├─ Halfπ\n│     ├─ Inv2π\n│     ├─ Inv4π\n│     ├─ Invsqrt2\n│     ├─ Invsqrt2π\n│     ├─ Invsqrtπ\n│     ├─ Invπ\n│     ├─ Log2π\n│     ├─ Log4π\n│     ├─ Loghalf\n│     ├─ Logten\n│     ├─ Logtwo\n│     ├─ Logπ\n│     ├─ Quartπ\n│     ├─ Sqrt2\n│     ├─ Sqrt2π\n│     ├─ Sqrt3\n│     ├─ Sqrt4π\n│     ├─ Sqrthalfπ\n│     ├─ Sqrtπ\n│     ├─ Twoinvπ\n│     └─ Twoπ\n├─ FixedPoint\n├─ Integer\n│  ├─ Bool\n│  ├─ OffsetInteger\n│  ├─ OffsetInteger\n│  ├─ Signed\n│  │  ├─ BigInt\n│  │  ├─ Int128\n│  │  ├─ Int16\n│  │  ├─ Int32\n│  │  ├─ Int64\n│  │  └─ Int8\n│  └─ Unsigned\n│     ├─ UInt128\n│     ├─ UInt16\n│     ├─ UInt32\n│     ├─ UInt64\n│     └─ UInt8\n├─ Rational\n├─ SimpleRatio\n├─ PValue\n└─ TestStat\n\n\n\n\nGetting the Parent Type\nTo find the immediate supertype (parent type) of a specific type, you can use the supertype() function. Here’s an example:\n\nsupertype(Int64)\n\nSigned\n\n\nThis will return the immediate parent type of Int64.\n\n\nGetting the List of All Parent Types\nTo get the entire chain of parent types, you can use the supertypes() function, which directly returns all the parent types of a given type. Here’s an example that shows how to do this for Float64:\n\nsupertypes(Float64)\n\n(Float64, AbstractFloat, Real, Number, Any)\n\n\nThis code will return the list of all parent types of Float64, starting from Float64 itself and going up the type hierarchy to Any. This can be useful for understanding the relationships between different types in Julia. To print the list of parent types in a more readable format, you can use the join function:\n\njoin(supertypes(Float64), \" -&gt; \")\n\n\"Float64 -&gt; AbstractFloat -&gt; Real -&gt; Number -&gt; Any\"\n\n\n\n\n\nType Hierarchies and Performance\nThe type hierarchy plays a crucial role in enabling multiple dispatch in Julia, allowing for efficient method selection based on the types of function arguments. By organizing types into a well-defined hierarchy, Julia can quickly select the most specific method for a given operation, optimizing performance, especially in scientific and numerical computing.\n\n\nQuiz\n\n\n\n\n\n\nQuiz: Type Hierarchies in Julia\n\n\n\n\n\n\n\nQuestion 1. What is the purpose of an abstract type in Julia?\n\n\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        It provides a blueprint for organizing related types but cannot be instantiated.\n    \n    \n\n\n    \n    \n    \n    \n        It is used for type annotations in functions.\n    \n    \n\n\n    \n    \n    \n    \n        It defines a concrete implementation for other types.\n    \n    \n\n\n    \n    \n    \n    \n        It can be instantiated and used directly.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 2. Which of the following types is a concrete type?\n\n\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        AbstractFloat\n    \n    \n\n\n    \n    \n    \n    \n        Real\n    \n    \n\n\n    \n    \n    \n    \n        Int64\n    \n    \n\n\n    \n    \n    \n    \n        Number\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 3. What does the isconcretetype function return for AbstractFloat?\n\n\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        null\n    \n    \n\n\n    \n    \n    \n    \n        true\n    \n    \n\n\n    \n    \n    \n    \n        false\n    \n    \n\n\n    \n    \n    \n    \n        Error: Undefined type\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 4. What will the following code return?\n\n\n\n\ntypeof(42)\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        Integer\n    \n    \n\n\n    \n    \n    \n    \n        Number\n    \n    \n\n\n    \n    \n    \n    \n        Real\n    \n    \n\n\n    \n    \n    \n    \n        Int64\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 5. What is the purpose of the isa operator in Julia?\n\n\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        To check if a variable is an instance of a specific type or any of its subtypes.\n    \n    \n\n\n    \n    \n    \n    \n        To check if a variable's value matches a specific type.\n    \n    \n\n\n    \n    \n    \n    \n        To check if a variable is a subtype of Any.\n    \n    \n\n\n    \n    \n    \n    \n        To check if a type is concrete.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 6. What will be the result of the following code?\n\n\n\n\nInt64 &lt;: Real\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        true\n    \n    \n\n\n    \n    \n    \n    \n        false\n    \n    \n\n\n    \n    \n    \n    \n        Error: Type mismatch\n    \n    \n\n\n    \n    \n    \n    \n        true for Float64 but not for Int64\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 7. What will the following code return?\n\n\n\n\nisconcretetype(Int64)\nisconcretetype(AbstractFloat)\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        true for AbstractFloat and false for Int64\n    \n    \n\n\n    \n    \n    \n    \n        false for both types if using a different syntax\n    \n    \n\n\n    \n    \n    \n    \n        true for Int64 and false for AbstractFloat\n    \n    \n\n\n    \n    \n    \n    \n        false for both types\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 8. What does the &lt;: operator check in Julia?\n\n\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        If a type can be instantiated.\n    \n    \n\n\n    \n    \n    \n    \n        If two types are exactly the same.\n    \n    \n\n\n    \n    \n    \n    \n        If a type is abstract.\n    \n    \n\n\n    \n    \n    \n    \n        If one type is a subtype of another.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 9. What is the result of the following code?\n\n\n\n\nsubtypes(Real)\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        Returns a list of all types that are subtypes of Real.\n    \n    \n\n\n    \n    \n    \n    \n        Returns an error because Real is abstract.\n    \n    \n\n\n    \n    \n    \n    \n        Returns Any as the only subtype of Real.\n    \n    \n\n\n    \n    \n    \n    \n        Shows Real as a parent type with no subtypes.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 10. What does the supertype function return for Float64?\n\n\n\n\nsupertype(Float64)\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        Number\n    \n    \n\n\n    \n    \n    \n    \n        AbstractFloat\n    \n    \n\n\n    \n    \n    \n    \n        Real\n    \n    \n\n\n    \n    \n    \n    \n        Int",
    "crumbs": [
      "Content of the course",
      "Type System and Error Handling"
    ]
  },
  {
    "objectID": "src/advanced-types.html#type-annotations-and-declarations",
    "href": "src/advanced-types.html#type-annotations-and-declarations",
    "title": "Advanced Types and Error Handling in Julia",
    "section": "Type Annotations and Declarations",
    "text": "Type Annotations and Declarations\nIn Julia, you can specify types for variables, function arguments, and return values. Type annotations help to provide clarity in your code, and in some cases, they can enable Julia’s just-in-time (JIT) compiler to generate more efficient code. While type annotations are optional, they are recommended for improving code readability and performance.\n\nVariable Type Annotations\nYou can explicitly declare the type of a variable by using a type annotation:\n\nx::Int = 10  # x is an integer\ny::Float64 = 3.14  # y is a Float64\n\nIn this example, x is explicitly declared as an integer (Int), and y is declared as a Float64. Type annotations can also be used with mutable and immutable structs.\n\n\nFunction Argument Type Annotations\nYou can specify types for function arguments to ensure that the function only accepts values of a specific type:\n\nfunction add(a::Int, b::Int)\n    return a + b\nend\n\nadd(3, 4)\nadd(3, \"4\")  # Error: \"4\" is a String, not an Int\n\njulia&gt; add(3, 4) = 7\njulia&gt; add(3, \"4\")\n\n\n\nMethodError: no method matching add(::Int64, ::String)\nThe function `add` exists, but no method is defined for this combination of argument types.\n\nClosest candidates are:\n  add(::Int64, ::Int64)\n   @ Main In[38]:1\n\n\nStacktrace:\n [1] macro expansion\n   @ show.jl:1232 [inlined]\n [2] macro expansion\n   @ ~/Courses/julia/course-tse-julia/assets/julia/myshow.jl:82 [inlined]\n [3] top-level scope\n   @ In[38]:7\n\n\n\nIn the above example, a and b must both be Ints. If you try to pass a value of the wrong type (like \"4\"), Julia will throw an error.\n\n\nReturn Type Annotations\nYou can also annotate the return type of a function:\n\nfunction multiply(a::Int, b::Int)::Int\n    return a * b\nend\n\nHere, the function multiply is declared to return an Int, ensuring that the result will always be an integer.\n\n\nQuiz\n\n\n\n\n\n\nQuiz: Type Annotations and Declarations in Julia\n\n\n\n\n\n\n\nQuestion 1. What is the primary purpose of type annotations in Julia?\n\n\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        To specify the exact memory address of a variable.\n    \n    \n\n\n    \n    \n    \n    \n        To provide clarity in the code and enable optimizations by the compiler.\n    \n    \n\n\n    \n    \n    \n    \n        To make code run faster by skipping type checks.\n    \n    \n\n\n    \n    \n    \n    \n        To prevent errors from occurring in the code.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 2. Which of the following correctly applies a type annotation to a variable?\n\n\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        a:Int = 10\n    \n    \n\n\n    \n    \n    \n    \n        a::Int = 10\n    \n    \n\n\n    \n    \n    \n    \n        a = 10::Int\n    \n    \n\n\n    \n    \n    \n    \n        Int::a = 10\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 3. What will happen if the following code is executed?\n\n\n\n\nfunction add(a::Int, b::Int)\n    return a + b\nend\n\nadd(3, \"4\")\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        It will throw a type error because \"4\" is a String, not an Int.\n    \n    \n\n\n    \n    \n    \n    \n        It will convert \"4\" to an Int and return 7.\n    \n    \n\n\n    \n    \n    \n    \n        It will ignore the type annotation and return 7.\n    \n    \n\n\n    \n    \n    \n    \n        It will throw a syntax error.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 4. In Julia, what will the following code output?\n\n\n\n\nfunction multiply(a::Int, b::Int)::Int\n    return a * b\nend\nmultiply(3, 4)\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        12\n    \n    \n\n\n    \n    \n    \n    \n        12.0\n    \n    \n\n\n    \n    \n    \n    \n        Nothing\n    \n    \n\n\n    \n    \n    \n    \n        Error: Incorrect type",
    "crumbs": [
      "Content of the course",
      "Type System and Error Handling"
    ]
  },
  {
    "objectID": "src/advanced-types.html#parametric-types",
    "href": "src/advanced-types.html#parametric-types",
    "title": "Advanced Types and Error Handling in Julia",
    "section": "Parametric Types",
    "text": "Parametric Types\nParametric types in Julia allow you to create types that can work with multiple data types, providing flexibility and enabling generic programming. This is particularly useful when you want to create functions, structs, or methods that can handle various types without needing to duplicate code.\n\nParametric Composite Types\nA parametric struct can take one or more type parameters:\n\nstruct Pair{T, S}\n    first::T\n    second::S\nend\n\npair1 = Pair(1, \"apple\")  # Pair of Int and String\npair2 = Pair(3.14, true)  # Pair of Float64 and Bool\n\njulia&gt; pair1 = Pair{Int64, String}(1, \"apple\")\njulia&gt; pair2 = Pair{Float64, Bool}(3.14, true)\n\n\nIn this case, Pair can be instantiated with any two types T and S, making it more versatile.\n\n\nParametric Abstract Types\nParametric abstract types allow you to define abstract types that are parameterized by other types.\n\nSyntax:\nabstract type AbstractContainer{T} end\nHere, AbstractContainer is an abstract type that takes a type parameter T. Any concrete type that is a subtype of AbstractContainer can specify the concrete type for T.\n\n\nExample:\n\nabstract type AbstractContainer{T} end\n\nstruct VectorContainer{T} &lt;: AbstractContainer{T}\n    data::Vector{T}\nend\n\nstruct SetContainer{T} &lt;: AbstractContainer{T}\n    data::Set{T}\nend\n\nstruct FloatVectorContainer &lt;: AbstractContainer{Float64}\n    data::Vector{Float64}\nend\n\nfunction print_container_info(container::AbstractContainer{T}) where T\n    println(\"Container holds values of type: \", T)\nend\n\n# Usage:\nvec = VectorContainer([1, 2, 3])\nset = SetContainer(Set([1, 2, 3]))\nflo = FloatVectorContainer([1.0, 2.0, 3.0])\n\nprint_container_info(vec)\nprint_container_info(set)\nprint_container_info(flo)\n\nContainer holds values of type: Int64\nContainer holds values of type: Int64\nContainer holds values of type: Float64\n\n\n\n\nExplanation:\n\nAbstractContainer{T} is a parametric abstract type, where T represents the type of elements contained within the container.\nVectorContainer and SetContainer are concrete subtypes of AbstractContainer, each using a different data structure (Vector and Set) to store elements of type T.\nFloatVectorContainer is a concrete subtype of AbstractContainer that specifies Float64 as the type for T.\nThe function print_container_info accepts any container that is a subtype of AbstractContainer and prints the type of elements inside the container.\n\n\n\n\nConstrained Parametric Types\nConstrained parametric types allow you to restrict acceptable type parameters using &lt;:, ensuring greater control and type safety.\n\nstruct RealPair{T &lt;: Real}\n    first::T\n    second::T\nend\n\n# Valid:\npair = RealPair(1.0, 2.5)\n\n# Constraining a function:****\nfunction sum_elements(container::AbstractContainer{T}) where T &lt;: Real\n    return sum(container.data)\nend\n\nvec = VectorContainer([1.0, 2.0, 3.0])\nprintln(sum_elements(vec))  # Outputs: 6.0\n\n6.0\n\n\nIn this example, RealPair is a struct that only accepts type parameters that are subtypes of Real. Similarly, the sum_elements function only works with containers that hold elements of type T that are subtypes of Real. The following code will throw an error because String is not a subtype of Real:\n\n# Invalid (throws an error):\ninvalid_pair = RealPair(\"a\", \"b\")\n\n\nMethodError: no method matching RealPair(::String, ::String)\nThe type `RealPair` exists, but no method is defined for this combination of argument types when trying to construct it.\n\nClosest candidates are:\n  RealPair(::T, ::T) where T&lt;:Real\n   @ Main In[51]:2\n\n\nStacktrace:\n [1] top-level scope\n   @ In[52]:2\n\n\n\nConstraints enhance type safety, clarify requirements, and support robust generic programming.\n\n\nQuiz\n\n\n\n\n\n\nQuiz: Parametric Types in Julia\n\n\n\n\n\n\n\nQuestion 1. What is a parametric type in Julia?\n\n\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        A type that is defined for a specific data type.\n    \n    \n\n\n    \n    \n    \n    \n        A type that can only work with abstract types.\n    \n    \n\n\n    \n    \n    \n    \n        A type that doesn't require any parameters.\n    \n    \n\n\n    \n    \n    \n    \n        A type that can work with multiple data types, specified by parameters.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 2. What is the role of T and S in the Pair struct example?\n\n\n\n\nstruct Pair{T, S}\n    first::T\n    second::S\nend\n\npair1 = Pair(1, \"apple\")  # Pair of Int and String\npair2 = Pair(3.14, true)  # Pair of Float64 and Bool\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        T and S define the data types of the first and second elements of the pair.\n    \n    \n\n\n    \n    \n    \n    \n        T and S are unused in this case, they are placeholders.\n    \n    \n\n\n    \n    \n    \n    \n        T is used for the first element, and S is used for the second element.\n    \n    \n\n\n    \n    \n    \n    \n        T defines the data type of both elements in the pair.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 3. What happens when you instantiate Pair(1, 'apple') in the provided code?\n\n\n\n\npair1 = Pair(1, \"apple\")  # Pair of Int and String\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        It will create a pair with Int64 and String.\n    \n    \n\n\n    \n    \n    \n    \n        It will create a pair with an Int and a String.\n    \n    \n\n\n    \n    \n    \n    \n        It will cause a runtime error because the types don't match.\n    \n    \n\n\n    \n    \n    \n    \n        It will throw an error because Int and String can't be combined.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 4. What is the benefit of using parametric types like AbstractContainer{T}?\n\n\n\n\nabstract type AbstractContainer{T} end\n\nstruct VectorContainer{T} &lt;: AbstractContainer{T}\n    data::Vector{T}\nend\n\nstruct SetContainer{T} &lt;: AbstractContainer{T}\n    data::Set{T}\nend\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        It allows you to create types that can handle any type of data, with type safety.\n    \n    \n\n\n    \n    \n    \n    \n        It allows you to specify concrete types directly in the struct.\n    \n    \n\n\n    \n    \n    \n    \n        It makes the code less flexible and more specific.\n    \n    \n\n\n    \n    \n    \n    \n        It makes the code more complex and harder to maintain.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 5. What does the print_container_info function do?\n\n\n\n\nfunction print_container_info(container::AbstractContainer{T}) where T\n    println(\"Container holds values of type: \", T)\nend\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        It returns the type of the container.\n    \n    \n\n\n    \n    \n    \n    \n        It prints the number of elements in the container.\n    \n    \n\n\n    \n    \n    \n    \n        It prints the type of the container.\n    \n    \n\n\n    \n    \n    \n    \n        It prints the values inside the container.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 6. What is the purpose of AbstractContainer{T} in the code example?\n\n\n\n\nabstract type AbstractContainer{T} end\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        It defines a container for a specific type of data.\n    \n    \n\n\n    \n    \n    \n    \n        It defines a concrete container type.\n    \n    \n\n\n    \n    \n    \n    \n        It restricts containers to hold only numeric types.\n    \n    \n\n\n    \n    \n    \n    \n        It defines an abstract type that can be used to create containers for any data type T.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 7. What would be the output of print_container_info(vec) if vec is VectorContainer([1, 2, 3])?\n\n\n\n\nvec = VectorContainer([1, 2, 3])\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        It will print the values inside the container.\n    \n    \n\n\n    \n    \n    \n    \n        It will print the type AbstractContainer{Int}.\n    \n    \n\n\n    \n    \n    \n    \n        It will throw an error because VectorContainer is not defined.\n    \n    \n\n\n    \n    \n    \n    \n        It will print the type Vector{Int}.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 8. How does using parametric types help with code reusability?\n\n\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        It forces you to create new types for every use case.\n    \n    \n\n\n    \n    \n    \n    \n        It makes the code less reusable.\n    \n    \n\n\n    \n    \n    \n    \n        It requires more boilerplate code.\n    \n    \n\n\n    \n    \n    \n    \n        It reduces the need to define separate functions for different data types.",
    "crumbs": [
      "Content of the course",
      "Type System and Error Handling"
    ]
  },
  {
    "objectID": "src/advanced-types.html#type-conversion-and-promotion",
    "href": "src/advanced-types.html#type-conversion-and-promotion",
    "title": "Advanced Types and Error Handling in Julia",
    "section": "Type Conversion and Promotion",
    "text": "Type Conversion and Promotion\nIn Julia, type conversion and promotion are mechanisms that allow for flexibility when working with different types, enabling smooth interactions and arithmetic between varying data types. Conversion changes the type of a value, while promotion ensures two values have a common type for an operation.\n\nType Conversion\nType conversion in Julia is typically achieved with the convert function, which tries to change a value from one type to another. For conversions between Float64 and Int, methods like round and floor are commonly used to handle fractional parts safely. To convert numbers to strings, use the string() function instead.\n\nround(Int, 3.84)   \nfloor(Int, 3.14)\nconvert(Float64, 5)\nstring(123)\n\njulia&gt; round(Int, 3.84) = 4\njulia&gt; floor(Int, 3.14) = 3\njulia&gt; convert(Float64, 5) = 5.0\njulia&gt; string(123) = \"123\"\n\n\nIn these examples:\n\nround rounds a Float64 to the nearest Int.\nfloor converts a Float64 to the nearest lower Int.\nConverting an Int to Float64 represents the integer as a floating-point number.\nstring() converts an integer to its string representation.\n\n\n\nAutomatic Conversion\nIn many cases, Julia will automatically convert types when it is unambiguous. For instance, you can directly assign an integer to a floating-point variable, and Julia will automatically convert it.\n\ny::Float64 = 10  # The integer 10 is converted to 10.0 (Float64)\n\njulia&gt; y::Float64 = 10.0\n\n\n\n\nType Promotion\nType promotion is used when combining two values of different types in an operation. Julia promotes values to a common type using the promote function, which returns values in their promoted type. This is useful when performing arithmetic on values of different types.\n\na, b = promote(3, 4.5)  # Promotes both values to Float64\ntypeof(a)\ntypeof(b)\n\njulia&gt; (a, b) = (3.0, 4.5)\njulia&gt; typeof(a) = Float64\njulia&gt; typeof(b) = Float64\n\n\nIn this example, promote converts both 3 (an Int) and 4.5 (a Float64) to Float64 so they can be added, subtracted, or multiplied without any type conflicts.\n\n\n\n\n\n\nWarning\n\n\n\nBe aware that promotion has nothing to do with the type hierarchy. For instance, although every Int value can also be represented as a Float64 value, Int is not a subtype of Float64.\n\n\n\n\nSummary\n\nconvert(Type, value): Converts value to the specified Type, if possible.\npromote(x, y): Returns both x and y promoted to a common type.\nType promotion rules allow Julia to handle operations between different types smoothly, making the language both powerful and flexible for numerical and data processing tasks.\n\n\n\nQuiz\n\n\n\n\n\n\nQuiz: Type Conversion and Promotion in Julia\n\n\n\n\n\n\n\nQuestion 1. What does the convert function do in Julia?\n\n\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        It converts a value from one type to another, if possible.\n    \n    \n\n\n    \n    \n    \n    \n        It converts numbers to strings.\n    \n    \n\n\n    \n    \n    \n    \n        It automatically promotes values to a common type.\n    \n    \n\n\n    \n    \n    \n    \n        It changes a value to a boolean type.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 2. What is the output of the following code?\n\n\n\n\nprintln(round(Int, 3.14))   # Rounds 3.14 to the nearest integer, output: 3\nprintln(floor(Int, 3.14))   # Floors 3.14 to the nearest integer, output: 3\nprintln(convert(Float64, 5))  # Converts Int to Float64, output: 5.0\nprintln(string(123))         # Converts Int to String, output: \"123\"\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        3, 3, 5.0, 123\n    \n    \n\n\n    \n    \n    \n    \n        5.0, 3, 5, '123'\n    \n    \n\n\n    \n    \n    \n    \n        3, 3.14, 5, '123'\n    \n    \n\n\n    \n    \n    \n    \n        3, 3, 5.0, '123'\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 3. What happens when an integer is assigned to a Float64 variable in Julia?\n\n\n\n\ny::Float64 = 10  # The integer 10 is automatically converted to 10.0 (Float64)\nprintln(y)       # Output: 10.0\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        Julia automatically converts the integer to a Float64.\n    \n    \n\n\n    \n    \n    \n    \n        The conversion needs to be done explicitly using convert.\n    \n    \n\n\n    \n    \n    \n    \n        The variable y will be set to the integer value of 10.\n    \n    \n\n\n    \n    \n    \n    \n        Julia throws a type error because of the type mismatch.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 4. What does the promote function do in Julia?\n\n\n\n\na, b = promote(3, 4.5)  # Promotes both values to Float64\nprintln(a)              # Output: 3.0\nprintln(b)              # Output: 4.5\nprintln(typeof(a))      # Output: Float64\nprintln(typeof(b))      # Output: Float64\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        It checks if two values have the same type.\n    \n    \n\n\n    \n    \n    \n    \n        It promotes two values to a common type for an operation.\n    \n    \n\n\n    \n    \n    \n    \n        It converts values to strings for display.\n    \n    \n\n\n    \n    \n    \n    \n        It converts both values to integers.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 5. What will happen if we try to add an Int and a String in Julia?\n\n\n\n\nprintln(3 + \"Hello\")  # Attempting to add Int and String\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        It will throw a type error.\n    \n    \n\n\n    \n    \n    \n    \n        It will concatenate the string and the number.\n    \n    \n\n\n    \n    \n    \n    \n        It will promote the number to a string.\n    \n    \n\n\n    \n    \n    \n    \n        Julia will automatically convert both to a common type.",
    "crumbs": [
      "Content of the course",
      "Type System and Error Handling"
    ]
  },
  {
    "objectID": "src/advanced-types.html#union-types",
    "href": "src/advanced-types.html#union-types",
    "title": "Advanced Types and Error Handling in Julia",
    "section": "Union Types",
    "text": "Union Types\nIn Julia, Union types are used to create variables or function arguments that can accept multiple types. This is particularly useful when you want to allow a function to work with multiple types without needing to write separate methods for each one.\nA Union type is created by specifying a list of types within Union{}. This allows a variable to hold values of any type listed in the union.\n\nfunction process(x::Union{Int, Nothing})\n    println(\"The input is: \", x)\nend\n\nprocess(5)        # Works with an Int\nprocess(nothing)  # Works with nothing of type Nothing\n\nThe input is: 5\nThe input is: nothing\n\n\nIn this example, process can accept both Int and Nothing types, making it versatile across multiple input types.\n\nQuiz\n\n\n\n\n\n\nQuiz: Union Types in Julia\n\n\n\n\n\n\n\nQuestion 1. What is a Union type in Julia?\n\n\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        A type that can only accept floating-point numbers.\n    \n    \n\n\n    \n    \n    \n    \n        A built-in function for type conversion.\n    \n    \n\n\n    \n    \n    \n    \n        A type that restricts a variable to only one type.\n    \n    \n\n\n    \n    \n    \n    \n        A type that allows a variable to accept multiple types.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 2. What is the output of the following code?\n\n\n\n\nfunction process_number(x::Union{Int, Float64})\n    println(\"The input is: \", x)\nend\n\nprocess_number(5)       # Works with an Int\nprocess_number(3.14)    # Works with a Float64\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        The input is: 5, The input is: 3.14\n    \n    \n\n\n    \n    \n    \n    \n        The input is: 3.14, The input is: 5\n    \n    \n\n\n    \n    \n    \n    \n        The input is: 5, The input is: 3.0\n    \n    \n\n\n    \n    \n    \n    \n        The input is: 5, The input is: 3\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 3. Which of the following scenarios would benefit from using a Union type?\n\n\n\n\n# Example using Union to handle multiple types in a function\nfunction add_one(x::Union{Int, Float64})\n    return x + 1\nend\n\nprintln(add_one(3))     # Output: 4 (Int)\nprintln(add_one(2.5))   # Output: 3.5 (Float64)\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        When a function needs to accept both integers and floating-point numbers.\n    \n    \n\n\n    \n    \n    \n    \n        When a function accepts only integers.\n    \n    \n\n\n    \n    \n    \n    \n        When a function is only designed to accept floating-point numbers.\n    \n    \n\n\n    \n    \n    \n    \n        When there is a strict requirement to accept a specific type.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 4. What happens when a value of a type not listed in the Union is passed to a function?\n\n\n\n\nfunction process_number(x::Union{Int, Float64})\n    println(\"The input is: \", x)\nend\n\nprocess_number(\"Hello\")  # Trying to pass a String\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        It will automatically convert the string to an integer.\n    \n    \n\n\n    \n    \n    \n    \n        It will work without issue because String is compatible with Union.\n    \n    \n\n\n    \n    \n    \n    \n        It will throw a MethodError because String is not part of the Union.\n    \n    \n\n\n    \n    \n    \n    \n        It will throw a TypeError due to the type mismatch.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 5. How does the add_one function handle both Int and Float64 types?\n\n\n\n\nfunction add_one(x::Union{Int, Float64})\n    return x + 1\nend\n\nprintln(add_one(3))     # Output: 4 (Int)\nprintln(add_one(2.5))   # Output: 3.5 (Float64)\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        It only works for Float64 types.\n    \n    \n\n\n    \n    \n    \n    \n        It requires type checking before execution.\n    \n    \n\n\n    \n    \n    \n    \n        It throws an error for Int but works for Float64.\n    \n    \n\n\n    \n    \n    \n    \n        It works for both types without needing separate methods.",
    "crumbs": [
      "Content of the course",
      "Type System and Error Handling"
    ]
  },
  {
    "objectID": "src/advanced-types.html#special-types",
    "href": "src/advanced-types.html#special-types",
    "title": "Advanced Types and Error Handling in Julia",
    "section": "Special Types",
    "text": "Special Types\nJulia provides several special types to handle different programming needs, including types for flexible assignments, missing values, and functions without specific return values.\n\nNothing\nThe Nothing type represents the absence of a meaningful value, commonly used when a function does not return anything. It’s similar to void in other programming languages. Functions in Julia that do not return a value explicitly return nothing by default.\n\n# Example of a function that returns `Nothing`\nfunction print_message(msg::String)\n    println(msg)\n    return nothing  # Explicitly returns `nothing`\nend\n\nresult = print_message(\"Hello!\")  # Returns `nothing`\nprintln(result === nothing)       # Output: true\n\nHello!\ntrue\n\n\nUsing Nothing is useful when you want to indicate that a function has no specific return value, yet you still want to call it as part of a larger program flow.\n\n\nAny\nAny is the most general type in Julia and serves as the root of Julia’s type hierarchy. Declaring a variable or argument as Any allows it to hold values of any type, making it versatile but potentially less performant since Julia cannot infer a specific type.\n\n# Example of using `Any` as a type\nfunction describe(value::Any)\n    println(\"Value: \", value)\n    println(\"Type: \", typeof(value))\nend\n\ndescribe(42)         # Works with Int\ndescribe(\"Hello\")    # Works with String\ndescribe(3.14)       # Works with Float64\n\nValue: 42\nType: Int64\nValue: Hello\nType: String\nValue: 3.14\nType: Float64\n\n\nUsing Any can be beneficial when handling inputs of unpredictable types, such as in data processing functions where input data may be heterogeneous.\n\n\nMissing\nThe Missing type is used to represent missing or unknown data, especially useful in data analysis. Julia’s missing value is an instance of Missing and can be assigned to variables or included in data structures like arrays and tables. Operations with missing generally propagate missing to indicate the presence of missing data.\n\n# Example of using `missing` in an array\ndata = [1, 2, missing, 4, 5]\n\n# Check for missing values in the array\nfor item in data\n    if item === missing\n        println(\"Missing data detected.\")\n    else\n        println(\"Value: \", item)\n    end\nend\n\nValue: 1\nValue: 2\nMissing data detected.\nValue: 4\nValue: 5\n\n\nThe missing value enables handling of incomplete data in Julia programs without causing errors, making it especially useful in fields like data science.\nIn data analysis, you often want to perform calculations or operations on data while ignoring missing values. Julia provides the skipmissing function, which creates an iterator that skips over any missing values in a collection.\n\nusing Statistics\n\n# Example array with missing values\ndata = [1, 2, missing, 4, 5, missing, 7]\n\n# Summing values while skipping missing entries\nsum_no_missing = sum(skipmissing(data))\nprintln(\"Sum without missing values: \", sum_no_missing)  # Output: 19\n\n# Calculating the mean while skipping missing values\nmean_no_missing = mean(skipmissing(data))\nprintln(\"Mean without missing values: \", mean_no_missing)  # Output: 3.8\n\nSum without missing values: 19\nMean without missing values: 3.8\n\n\nIn this example:\n\nskipmissing(data) returns an iterator that excludes missing values from the data array.\nUsing sum(skipmissing(data)) and mean(skipmissing(data)) allows us to calculate the sum and mean, respectively, without considering any missing entries.\n\nThe skipmissing function is especially useful when handling datasets with incomplete data, enabling accurate calculations without manually filtering out missing values.\n\n\nQuiz\n\n\n\n\n\n\nQuiz: Special Types in Julia\n\n\n\n\n\n\n\nQuestion 1. What does the Nothing type represent in Julia?\n\n\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        It is a placeholder for missing data.\n    \n    \n\n\n    \n    \n    \n    \n        It represents the absence of a meaningful value.\n    \n    \n\n\n    \n    \n    \n    \n        It is used for undefined variables.\n    \n    \n\n\n    \n    \n    \n    \n        It is a special type for numeric values.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 2. What is the result of calling the following function in Julia?\n\n\n\n\n# Example of a function that returns `Nothing`\nfunction print_message(msg::String)\n    println(msg)\n    return nothing  # Explicitly returns `nothing`\nend\n\nresult = print_message(\"Hello!\")\nprintln(result === nothing)  # Output: true\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        The function returns a string 'nothing'.\n    \n    \n\n\n    \n    \n    \n    \n        nothing is returned and the output is true.\n    \n    \n\n\n    \n    \n    \n    \n        nothing is returned but the output is false.\n    \n    \n\n\n    \n    \n    \n    \n        The function throws an error because nothing cannot be returned.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 3. What is the advantage of using Any as a type in Julia?\n\n\n\n\n# Example of using `Any` as a type\nfunction describe(value::Any)\n    println(\"Value: \", value)\n    println(\"Type: \", typeof(value))\nend\n\ndescribe(42)         # Works with Int\ndescribe(\"Hello\")    # Works with String\ndescribe(3.14)       # Works with Float64\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        It prevents runtime errors related to data types.\n    \n    \n\n\n    \n    \n    \n    \n        It makes type inference more precise.\n    \n    \n\n\n    \n    \n    \n    \n        It allows variables to hold any type, making the code flexible.\n    \n    \n\n\n    \n    \n    \n    \n        It increases performance by restricting the type of variable.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 4. What does the following code do in Julia?\n\n\n\n\ndata = [1, 2, missing, 4, 5]\nfor item in data\n    if item === missing\n        println(\"Missing data detected.\")\n    else\n        println(\"Value: \", item)\n    end\nend\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        It sums all the values and skips missing ones.\n    \n    \n\n\n    \n    \n    \n    \n        It replaces missing data with a default value.\n    \n    \n\n\n    \n    \n    \n    \n        It checks for missing values and prints a message for each.\n    \n    \n\n\n    \n    \n    \n    \n        It throws an error when encountering missing data.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 5. What is the purpose of the skipmissing function in Julia?\n\n\n\n\nusing Statistics\n\n# Example array with missing values\ndata = [1, 2, missing, 4, 5, missing, 7]\n\n# Summing values while skipping missing entries\nsum_no_missing = sum(skipmissing(data))\nprintln(\"Sum without missing values: \", sum_no_missing)  # Output: 19\n\n# Calculating the mean while skipping missing values\nmean_no_missing = mean(skipmissing(data))\nprintln(\"Mean without missing values: \", mean_no_missing)  # Output: 3.8\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        It raises an error if missing values are encountered.\n    \n    \n\n\n    \n    \n    \n    \n        It creates an iterator that skips missing values during computations.\n    \n    \n\n\n    \n    \n    \n    \n        It replaces missing values with 0.\n    \n    \n\n\n    \n    \n    \n    \n        It prints out the number of missing values.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 6. What is the main use of the Missing type in Julia?\n\n\n\n\n# Example of using `missing` in an array\ndata = [1, 2, missing, 4, 5]\n\n# Check for missing values in the array\nfor item in data\n    if item === missing\n        println(\"Missing data detected.\")\n    else\n        println(\"Value: \", item)\n    end\nend\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        To represent variables with no value assigned.\n    \n    \n\n\n    \n    \n    \n    \n        To prevent errors when dealing with Nothing.\n    \n    \n\n\n    \n    \n    \n    \n        To represent missing or unknown data in a collection.\n    \n    \n\n\n    \n    \n    \n    \n        To hold any type of data including missing entries.",
    "crumbs": [
      "Content of the course",
      "Type System and Error Handling"
    ]
  },
  {
    "objectID": "src/advanced-types.html#errors-and-exception-handling",
    "href": "src/advanced-types.html#errors-and-exception-handling",
    "title": "Advanced Types and Error Handling in Julia",
    "section": "Errors and Exception Handling",
    "text": "Errors and Exception Handling\nJulia provides a powerful framework for managing and handling errors, which helps in writing robust programs. Error handling in Julia involves various built-in error types and mechanisms, including throw for raising errors and try/catch blocks for handling exceptions.\n\nCommon Error Types in Julia\nJulia has several built-in error types that are commonly used:\n\nArgumentError: Raised when a function receives an argument that is inappropriate or out of expected range.\nBoundsError: Occurs when trying to access an index that is out of bounds for an array or collection.\nDivideError: Raised when division by zero is attempted.\nDomainError: Raised when a mathematical function is called with an argument outside its domain. For instance, taking the square root of a negative number.\nMethodError: Occurs when a method is called with incorrect arguments or types.\n\n\n\nRaising Errors with throw\nIn Julia, you can explicitly raise an error using the throw function. This is useful for defining custom error conditions in your code. To throw an error, call throw with an instance of an error type:\n\nfunction divide(a, b)\n    if b == 0\n        throw(DivideError())\n    end\n    return a / b\nend\n\ndivide(10, 0)  # Will raise a DivideError\n\n\nDivideError: integer division error\n\nStacktrace:\n [1] divide(a::Int64, b::Int64)\n   @ Main ./In[113]:3\n [2] top-level scope\n   @ In[113]:8\n\n\n\nIn this example, the function divide will throw a DivideError if the second argument b is zero, making the function safer and more robust.\n\n\nHandling Errors with try/catch\nJulia provides try/catch blocks for managing exceptions gracefully. Code within a try block runs until an error is encountered. If an error is thrown, control passes to the catch block, where you can handle the error.\nHere’s an example of using try/catch with the divide function:\n\ntry\n    println(divide(10, 0))  # Will raise an error\ncatch e\n    println(\"Error: \", e)  # Handles the error\nend\n\nError: DivideError()\n\n\nIn this example:\n\nIf divide(10, 0) raises an error, the program catches it and prints a custom message instead of stopping execution.\nThe variable e holds the error, which can be printed or used for further handling.\n\n\n\nUsing finally for Cleanup\nIn Julia, finally is a block used in conjunction with try and catch to ensure that certain cleanup actions are executed regardless of whether an error occurs or not. This is useful for tasks like closing files, releasing resources, or resetting variables that need to be done after the execution of a try-catch block.\nThe code inside the finally block is always executed, even if an exception is thrown and caught. This makes it ideal for situations where you need to guarantee that some actions occur after the main code runs, like resource deallocation.\n\nSyntax:\n\ntry\n    # Code that might throw an error\ncatch exception\n    # Code to handle the error\nfinally\n    # Cleanup code that will always run\nend\n\n\n\nExample:\n\nfunction safe_file_read(filename::String)\n    file = nothing\n    try\n        file = open(filename, \"r\")\n        data = read(file, String)\n        return data\n    catch e\n        println(\"An error occurred: \", e)\n    finally\n        if file !== nothing\n            close(file)\n            println(\"File closed.\")\n        end\n    end\nend\n\n# Test with a valid file\nprintln(safe_file_read(\"example.txt\"))\n\n# Test with an invalid file\nprintln(safe_file_read(\"nonexistent.txt\"))\n\nAn error occurred: SystemError(\"opening file \\\"example.txt\\\"\", 2, nothing)\nnothing\nAn error occurred: SystemError(\"opening file \\\"nonexistent.txt\\\"\", 2, nothing)\nnothing\n\n\n\n\nExplanation:\n\nThe finally block ensures that the file is always closed after reading, even if an error occurs (e.g., file not found, read error).\nIf the open operation is successful, the finally block will still execute and close the file, ensuring proper resource management.\nIf an exception is thrown in the try block (like a non-existent file), it will be caught and handled by the catch block, but the finally block will still execute to close the file (if opened).\n\n\n\nUse Cases for finally:\n\nClosing files or network connections.\nReleasing resources (e.g., database connections, locks).\nResetting the program state to a known clean state.\n\n\n\n\nQuiz\n\n\n\n\n\n\nQuiz: Errors and Exception Handling in Julia\n\n\n\n\n\n\n\nQuestion 1. Which error type is raised when an index is out of bounds in an array?\n\n\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        BoundsError\n    \n    \n\n\n    \n    \n    \n    \n        ArgumentError\n    \n    \n\n\n    \n    \n    \n    \n        DivisionByZeroError\n    \n    \n\n\n    \n    \n    \n    \n        IOError\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 2. What does the following code do in Julia?\n\n\n\n\nfunction divide(a, b)\n    if b == 0\n        throw(DivideError())\n    end\n    return a / b\nend\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        It throws a BoundsError if a or b are not numbers.\n    \n    \n\n\n    \n    \n    \n    \n        It performs division and returns the result.\n    \n    \n\n\n    \n    \n    \n    \n        It raises a DivideError when b equals 0.\n    \n    \n\n\n    \n    \n    \n    \n        It raises an ArgumentError when a or b is invalid.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 3. What happens when the following try/catch block is executed?\n\n\n\n\ntry\n    println(divide(10, 0))  # Will raise an error\ncatch e\n    println(\"Error: \", e)  # Handles the error\nend\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        The program silently ignores the error.\n    \n    \n\n\n    \n    \n    \n    \n        The error is caught and a custom error message is printed.\n    \n    \n\n\n    \n    \n    \n    \n        The program prints the result of the division.\n    \n    \n\n\n    \n    \n    \n    \n        The program throws an error and stops execution.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 4. What is the purpose of the finally block in Julia’s exception handling?\n\n\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        To catch all errors and handle them.\n    \n    \n\n\n    \n    \n    \n    \n        To perform the main logic of the program.\n    \n    \n\n\n    \n    \n    \n    \n        To rethrow any errors that are caught.\n    \n    \n\n\n    \n    \n    \n    \n        To ensure that cleanup code runs regardless of whether an error occurs.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 5. What is the output of the following code?\n\n\n\n\nfunction safe_file_read(filename::String)\n    file = nothing\n    try\n        file = open(filename, \"r\")\n        data = read(file, String)\n        return data\n    catch e\n        println(\"An error occurred: \", e)\n    finally\n        if file !== nothing\n            close(file)\n            println(\"File closed.\")\n        end\n    end\nend\n\n# Test with a valid file\nprintln(safe_file_read(\"example.txt\"))\n\n# Test with an invalid file\nprintln(safe_file_read(\"nonexistent.txt\"))\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        The program tries to read a file, catches errors, and always closes the file.\n    \n    \n\n\n    \n    \n    \n    \n        The program prints the error but skips file closing.\n    \n    \n\n\n    \n    \n    \n    \n        The program prints data from the file and closes it.\n    \n    \n\n\n    \n    \n    \n    \n        The program raises an error and does not close the file.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 6. Which of the following is an appropriate use case for the finally block?\n\n\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        Ensuring a file is closed after reading, regardless of errors.\n    \n    \n\n\n    \n    \n    \n    \n        To prevent specific types of errors from being raised.\n    \n    \n\n\n    \n    \n    \n    \n        To catch all exceptions without handling them.\n    \n    \n\n\n    \n    \n    \n    \n        To handle errors and return a value from the finally block.",
    "crumbs": [
      "Content of the course",
      "Type System and Error Handling"
    ]
  },
  {
    "objectID": "src/performance.html",
    "href": "src/performance.html",
    "title": "Performance in Julia",
    "section": "",
    "text": "See\n\nJulia is fast\nThe Relationship between Vectorized and Devectorized Code\nThe need for speed\n\n\n\n\n Back to top",
    "crumbs": [
      "Content of the course",
      "Work in progress",
      "Performance"
    ]
  },
  {
    "objectID": "src/metaprogramming.html",
    "href": "src/metaprogramming.html",
    "title": "Metaprogramming and introspection in Julia",
    "section": "",
    "text": "Metaprogramming documentation\nReflective programming",
    "crumbs": [
      "Content of the course",
      "Work in progress",
      "Metaprogramming"
    ]
  },
  {
    "objectID": "src/metaprogramming.html#references",
    "href": "src/metaprogramming.html#references",
    "title": "Metaprogramming and introspection in Julia",
    "section": "",
    "text": "Metaprogramming documentation\nReflective programming",
    "crumbs": [
      "Content of the course",
      "Work in progress",
      "Metaprogramming"
    ]
  },
  {
    "objectID": "src/test.html",
    "href": "src/test.html",
    "title": "Test",
    "section": "",
    "text": "x = 10          # x is inferred to be of type Int64\ny = 3.14        # y is inferred to be of type Float64\nz = \"Hello\"     # z is inferred to be of type String\n\ntypeof(x), typeof(y), typeof(z)\n\njulia&gt; x = 10\njulia&gt; y = 3.14\njulia&gt; z = \"Hello\"\njulia&gt; (typeof(x), typeof(y), typeof(z)) = (Int64, Float64, String)\n\n\n\na = 1+0\na + 2\nb = 1\nb\ng(x) = 2\ng(3)\nfunction f(x)\n    return x + 2\nend\nf(3)\nfunction make_closure(x)\n    return (y) -&gt; x*y\nend\ndouble = make_closure(2)\ndouble(3)\n1 + \"2\"\n\njulia&gt; a = 1\njulia&gt; a + 2 = 3\njulia&gt; b = 1\njulia&gt; b = 1\njulia&gt; g(x) = begin\n        2\n    end\njulia&gt; g(3)\n\n\n\nUndefVarError: `g` not defined in `Main`\nSuggestion: check for spelling errors or missing imports.\n\nStacktrace:\n [1] macro expansion\n   @ show.jl:1232 [inlined]\n [2] macro expansion\n   @ ~/Courses/julia/course-tse-julia/assets/julia/myshow.jl:82 [inlined]\n [3] top-level scope\n   @ In[4]:7\n\n\n\n\n# Define a simple struct for a point in 2D space\nstruct Point\n    x::Float64\n    y::Float64\nend\n\n\nstruct Circle\n    center::Point\n    radius::Float64\nend\n\n# Define a custom constructor\nfunction Circle(x::Real, y::Real, radius::Real)\n    if radius &lt;= 0\n        throw(DomainError(radius, \"Radius must be positive\"))\n    end\n    Circle(Point(float(x), float(y)), float(radius))\nend\n\n\n# Create a Circle using the custom constructor\nc = Circle(0, 0, 5)  # Creates a Circle with center (0.0, 0.0) and radius 5.0\n\n# Attempt to create a Circle with an invalid radius\nc = Circle(0, 0, -3)  # Throws an error: \"Radius must be positive\"\n\njulia&gt; c = Circle(Point(0.0, 0.0), 5.0)\njulia&gt; c = Circle(0, 0, -3)\n\n\n\nDomainError with -3:\nRadius must be positive\n\nStacktrace:\n [1] Circle(x::Int64, y::Int64, radius::Int64)\n   @ Main ./In[6]:9\n [2] macro expansion\n   @ ~/Courses/julia/course-tse-julia/assets/julia/myshow.jl:53 [inlined]\n [3] top-level scope\n   @ In[7]:7\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "src/why_julia.html",
    "href": "src/why_julia.html",
    "title": "Why Julia?",
    "section": "",
    "text": "Paraphrasing Why Julia?, Julia is a fast and expressive programming language, delivering the speed of C++ and Fortran together with the productivity of Python, MATLAB, and R. This fundamentally empowers diverse teams to work together to develop and deploy performant programs at scale by solving the two language problem.",
    "crumbs": [
      "Content of the course",
      "Why Julia?"
    ]
  },
  {
    "objectID": "src/why_julia.html#benefits-of-julia",
    "href": "src/why_julia.html#benefits-of-julia",
    "title": "Why Julia?",
    "section": "Benefits of Julia",
    "text": "Benefits of Julia\nJulia combines the speed of low-level languages like C++ and Fortran with the productivity of high-level languages like Python, MATLAB, and R. Here are some of its key benefits:\n\nHigh Performance: Optimized for native compilation, multi-threading, and GPU compute, Julia can achieve speeds close to C++.\nHigh Productivity: Expressive and dynamic, Julia is up to 100x faster than traditional high-level languages.\nEase of Use: Clear and simple syntax, making it easy to learn, write, and analyze.\nComposability: Packages are designed to work seamlessly together and with custom code.\nInteroperability: Julia integrates well with languages like Python, R, C++, and Java.\nUnified Language: Supports both prototyping and deployment, solving the two-language problem.\nRich Ecosystem: More than 10,000 registered packages and a large community of contributors.",
    "crumbs": [
      "Content of the course",
      "Why Julia?"
    ]
  },
  {
    "objectID": "src/why_julia.html#the-two-language-problem",
    "href": "src/why_julia.html#the-two-language-problem",
    "title": "Why Julia?",
    "section": "The Two-Language Problem",
    "text": "The Two-Language Problem\nTraditionally, programming required both a high-level, slower language for prototyping and a low-level, faster language for production, causing inefficiencies. Julia unifies these two needs into one language, allowing:\n\n\n\n\n\n\n\n\nAspect\nHigh-Level Language (e.g., Python)\nLow-Level Language (e.g., C++)\n\n\n\n\nPros\nEasy to write and read\nFast in production\n\n\nCons\nSlow in production\nComplex, lengthy code\n\n\nJulia’s Solution\nCombines ease of high-level with speed of low-level, eliminating the need for separate languages for research and production.",
    "crumbs": [
      "Content of the course",
      "Why Julia?"
    ]
  },
  {
    "objectID": "src/why_julia.html#comparisons",
    "href": "src/why_julia.html#comparisons",
    "title": "Why Julia?",
    "section": "Comparisons",
    "text": "Comparisons\nIf you want to know for instance the date of the first public release, the price and the names of the creators of numerical-analysis softwares, please visite the Wikipedia page.\nJulia is made for scientific computing as shown by the table below which compares some languages in terms of differential equation solvers. For more details visit this page.\n\n  \n\nYou can find here cheatsheets. One interesting is the comparison with Python and R.\n\n  \n\nOne goal of Julia is to be efficient and high-level. This is illustrated by the following figure given by the Mandelbrot benchmark project.",
    "crumbs": [
      "Content of the course",
      "Why Julia?"
    ]
  },
  {
    "objectID": "src/index.html",
    "href": "src/index.html",
    "title": "Julia Master 1 course",
    "section": "",
    "text": "This course is adressed to the students of the Master 1 “Econométrie, Statistiques” of Toulouse School of Economics. It is part of the topic Software for Data science. The Julia course is composed of 5 slots of 3 hours. In this course, we introduce the Julia ecosystem, we present the Julia programming language and some relevant packages.\n\n\n\n\n\nContent\n\n\nGetting started\nForetaste of Julia Code\nWhy Julia?\nSyntax Essentials and Scoping\nBasic Types and Data Structures\nType System and Error Handling\n\n\n\n\n\n\nApplications\n\n\nRoot-Finding Methods\n\n\n\n\n\n\nWork in progress\n\n\nType Stability\nMethods and Multiple Dispatch\nModules and Packages\nMetaprogramming\nInteroperability\nPerformance\nMiscellaneous\n\n\n\n\nNo matching items\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Content of the course"
    ]
  },
  {
    "objectID": "src/root_finding.html",
    "href": "src/root_finding.html",
    "title": "Root-Finding Methods: Bisection and Newton",
    "section": "",
    "text": "Root-finding methods are fundamental tools in numerical analysis for solving equations of the form f(x) = 0. This page introduces two key techniques: the Bisection Method and Newton’s Method. Each offers unique strengths and is suited to different problem contexts.\nThe Bisection Method is a robust and straightforward approach that requires only function evaluations, not derivatives. It systematically narrows down the interval containing a root, making it particularly useful when derivative information is unavailable or the function is non-differentiable.\nThe Newton Method, in contrast, leverages derivative information to achieve rapid (quadratic) convergence under appropriate conditions. This efficiency, however, comes at the cost of requiring the computation of derivatives, making it more sensitive to initial guesses and less versatile for certain types of problems.\nIn this chapter, we explore:\nBy the end, you’ll have a strong grasp of these foundational methods, paving the way for more advanced numerical algorithms.",
    "crumbs": [
      "Content of the course",
      "Applications",
      "Root-Finding Methods"
    ]
  },
  {
    "objectID": "src/root_finding.html#the-bisection-method",
    "href": "src/root_finding.html#the-bisection-method",
    "title": "Root-Finding Methods: Bisection and Newton",
    "section": "The Bisection Method",
    "text": "The Bisection Method\nThe bisection method is an iterative numerical technique for finding a root of a continuous function f(x) on a closed interval [a, b]. The method assumes that f(a) and f(b) have opposite signs, which guarantees, by the Intermediate Value Theorem, that there is at least one root in [a, b]. The procedure works by repeatedly halving the interval and selecting the subinterval where the sign change occurs.\n\nExercise: Implement the Bisection Method\n\nObjective: Implement the bisection method in Julia and analyze its behavior.\nFunction Signature: Define a function bisection(f, a, b; tol=1e-12, max_iter=100) that takes:\n\nA continuous function f.\nThe interval bounds a and b.\nAn optional tolerance tol for stopping criteria.\nAn optional maximum number of iterations max_iter.\n\n\nThe function should return:\n\nAn approximation of the root.\nThe number of iterations performed.\n\nStopping criteria for the bisection method include:\n\n\n\n\n\n\n\nCondition\nDescription\n\n\n\n\nThe length of the interval [a, b]\n\\leq \\texttt{tol}: The interval has shrunk to a size less than or equal to the tolerance.\n\n\nFunction value at midpoint of [a, b]\n\\texttt{abs}(f((a + b)/2)) \\leq \\texttt{tol}: The function value at the midpoint is close enough to zero.\n\n\nMaximum number of iterations reached\nThe bisection algorithm terminates after reaching the predefined maximum iterations.\n\n\n\n\nExample Problem: Use the bisection method to find the root of f(x) = \\cos(x) - x on the interval [0, 1].\nAnalysis:\n\nRecord the approximate root at each iteration.\nCalculate the absolute error |x_k - x^*| where x^* = 0.7390851332151607 is the true root.\nPlot the error on a logarithmic scale and determine the order and rate of convergence.\n\nDiscussion:\n\nObserve the behavior of the error as the iterations progress.\nConclude that the bisection method has a linear convergence order.\n\n\n\n\n\n\n\n\nHint to implement the Bisection Method\n\n\n\n\n\n\nUse a loop to halve the interval and check the signs of f(a), f(b), and f(\\text{midpoint}).\nStop the iterations when |b - a| / 2 \\leq \\text{tol} or the maximum number of iterations is reached.\nHandle cases where the initial interval does not satisfy the conditions for the method.\n\n\n\n\n\n\n\n\n\n\nCorrection for the Bisection Method\n\n\n\n\n\n\nfunction bisection(f, a, b; tol=1e-12, max_iter=100)\n    # Check if the initial interval is valid\n    if f(a) * f(b) &gt; 0\n        error(\"The function must have opposite signs at the endpoints a and b.\")\n    end\n    \n    # Initialize variables\n    mid = (a + b) / 2\n    iter_count = 0\n    \n    while (b - a) / 2 &gt; tol && iter_count &lt; max_iter\n        iter_count += 1\n        mid = (a + b) / 2\n        \n        # Check if the midpoint is a root\n        if abs(f(mid)) ≤ tol\n            return mid, iter_count\n        elseif f(a) * f(mid) &lt; 0\n            b = mid  # Root is in [a, mid]\n        else\n            a = mid  # Root is in [mid, b]\n        end\n    end\n    \n    # Return the midpoint as the approximate root\n    return mid, iter_count\nend\n\n# Example usage\nf(x) = cos(x) - x\nroot, iterations = bisection(f, 0, 1)\nprintln(\"Approximate root: $root\")\nprintln(\"Evaluated function at the root: $(f(root))\")\nprintln(\"Number of iterations: $iterations\", \"\\n\")\n\n# Exact root for comparison\nexact_root = 0.7390851332151607\nprintln(\"Exact root: $exact_root\")\nprintln(\"Evaluated function at the exact root: $(f(exact_root))\")\nprintln(\"Absolute error: $(abs(root - exact_root))\")\nprintln(\"Relative error: $(abs(root - exact_root) / exact_root)\")\n\nApproximate root: 0.7390851332147577\nEvaluated function at the root: 6.744604874597826e-13\nNumber of iterations: 39\n\nExact root: 0.7390851332151607\nEvaluated function at the exact root: 0.0\nAbsolute error: 4.030109579389318e-13\nRelative error: 5.452835401867138e-13\n\n\n\n\n\n\n\n\n\n\n\nHint to Analyze the Bisection Method\n\n\n\n\n\nYou can follow the steps below to analyze the convergence of the bisection method:\n\nUse a vector to store the midpoints at each iteration for comparison with the exact root.\nIf the true root is known, calculate the absolute error |x_k - x^*| for each midpoint x_k.\nPlot the errors on a logarithmic scale to visualize the linear convergence behavior of the method.\nFit a regression line to the log of the errors to estimate the convergence rate. You can use the Polynomials package in Julia for this purpose.\n\n\n\n\n\n\n\n\n\n\nCorrection for Analysis\n\n\n\n\n\nTo analyze the convergence of the bisection method for f(x) = \\cos(x) - x on the interval [0, 1], we compute the approximate root at each iteration and calculate the absolute error. Using the exact root x^* \\approx 0.7390851332151607, we determine the error |x_k - x^*|. We also plot the error on a logarithmic scale to observe the convergence behavior.\nBelow is the Julia code for the analysis:\n\nusing Plots\n\nfunction bisection_analysis(f, a, b; tol=1e-12, max_iter=100, true_root=nothing)\n    if f(a) * f(b) &gt; 0\n        error(\"The function must have opposite signs at the endpoints a and b.\")\n    end\n\n    midpoints = []\n    errors = []\n    iter_count = 0\n    mid = (a + b) / 2\n    \n    while (b - a) / 2 &gt; tol && iter_count &lt; max_iter\n        iter_count += 1\n        mid = (a + b) / 2\n        push!(midpoints, mid)\n        \n        if !isnothing(true_root)\n            push!(errors, abs(mid - true_root))\n        end\n\n        if abs(f(mid)) ≤ tol\n            break\n        elseif f(a) * f(mid) &lt; 0\n            b = mid\n        else\n            a = mid\n        end\n    end\n    \n    return mid, iter_count, midpoints, errors\nend\n\n# Exact root for reference\ntrue_root = 0.7390851332151607\nf(x) = cos(x) - x\nroot, iterations, midpoints, errors = bisection_analysis(f, 0, 1, true_root=true_root)\n\n# Print the approximate root and error\nprintln(\"Approximate root: $root\")\nprintln(\"Number of iterations: $iterations\")\nprintln(\"Final error: $(errors[end])\", \"\\n\")\n\n# Plot the errors on a logarithmic scale\nplt = plot(1:iterations, errors, yscale=:log10, xlabel=\"Iteration\", ylabel=\"Absolute Error\", \n    title=\"Convergence of the Bisection Method\", label=\"Computed Error\",\n    seriestype=:scatter, markersize=4, markerstrokewidth=0, z_order=:front)\n\n# Compute by linear regression the convergence rate\nusing Polynomials\nline = fit(1:iterations, log10.(errors), 1)\nprintln(\"Linear fit: $line\")\nprintln(\"Convergence rate: $(10^(line.coeffs[2]))\")\n\n# add the linear regression line to the plot\nplot!(plt, 1:iterations, 10 .^ line.(1:iterations), label=\"Linear Regression\", \n    linewidth=2, z_order=:back)\n\nApproximate root: 0.7390851332147577\nNumber of iterations: 39\nFinal error: 4.030109579389318e-13\n\nLinear fit: -0.471122 - 0.299499*x\nConvergence rate: 0.5017659435024082",
    "crumbs": [
      "Content of the course",
      "Applications",
      "Root-Finding Methods"
    ]
  },
  {
    "objectID": "src/root_finding.html#the-newton-method",
    "href": "src/root_finding.html#the-newton-method",
    "title": "Root-Finding Methods: Bisection and Newton",
    "section": "The Newton Method",
    "text": "The Newton Method\nThe Newton Method, or Newton-Raphson Method, is an iterative numerical technique for finding roots of a nonlinear equation f(x) = 0. Unlike the bisection method, Newton’s method leverages the derivative of f(x) to achieve a much faster rate of convergence under suitable conditions. Specifically, it exhibits quadratic convergence, meaning the number of accurate decimal places roughly doubles at each iteration once close to the root.\n\nNewton’s Iteration Formula\nGiven an initial guess x_0, the Newton iteration is defined as:\n\nx_{k+1} = x_k - \\frac{f(x_k)}{f'(x_k)},\n\nwhere f'(x_k) is the derivative of f(x) evaluated at x_k. The method relies on the approximation of f(x) by its tangent line at x_k. The next iterate x_{k+1} is where this tangent line intersects the x-axis.\n\n\nExercise: Apply Newton’s Method to Find a Root\n\nObjective: Use the Newton method to find the root of f(x) = \\cos(x) - x, starting from the initial iterate x_0 = 0.\nFunction Signature: Define a function newton(f, df, x0; tol=1e-12, max_iter=100) that takes:\n\nA continuous function f.\nIts derivative df.\nThe initial guess x0.\nAn optional tolerance tol for stopping criteria.\nAn optional maximum number of iterations max_iter.\n\n\nThe function should return:\n\nThe approximate root.\nThe number of iterations performed.\n\nThe stopping criteria for the Newton method include:\n\n\n\n\n\n\n\nCondition\nDescription\n\n\n\n\nDifference between consecutive iterations\n\\texttt{abs}(x_{k+1} - x_k) \\leq \\texttt{tol}: The method converges when the change between successive approximations is less than or equal to the tolerance.\n\n\nMaximum number of iterations reached\nThe Newton method terminates after reaching the predefined maximum iterations.\n\n\n\n\nExample Problem: Use the Newton method to find the root of f(x) = \\cos(x) - x starting at x_0 = 0.\nAnalysis:\n\nRecord the approximate root at each iteration.\nCalculate the absolute error |x_k - x^*| where x^* \\approx 0.7390851332151607 is the true root.\nPlot the error on a logarithmic scale and determine the order of convergence.\n\n\n\n\n\n\n\n\nHint for Implementation\n\n\n\n\n\n\nUse the Newton iteration formula to update the guess at each iteration.\nStop the iterations when |x_{k+1} - x_k| \\leq \\text{tol} or the maximum number of iterations is reached.\n\n\n\n\n\n\n\n\n\n\nCorrection for the Newton Method\n\n\n\n\n\n\nfunction newton(f, df, x0; tol=1e-12, max_iter=100)\n    xk = x0\n    iter_count = 0\n\n    while iter_count &lt; max_iter\n        iter_count += 1\n        x_next = xk - f(xk) / df(xk)\n\n        # Check if the difference is within the tolerance\n        if abs(x_next - xk) &lt; tol\n            return x_next, iter_count\n        end\n\n        xk = x_next\n    end\n\n    return xk, iter_count\nend\n\n# Example usage\nf(x) = cos(x) - x\ndf(x) = -sin(x) - 1\nx0 = 0\nroot, iterations = newton(f, df, x0)\n\nprintln(\"Approximate root: $root\")\nprintln(\"Evaluated function at the root: $(f(root))\")\nprintln(\"Number of iterations: $iterations\", \"\\n\")\n\n# Exact root for comparison\nexact_root = 0.7390851332151607\nprintln(\"Exact root: $exact_root\")\nprintln(\"Evaluated function at the exact root: $(f(exact_root))\")\nprintln(\"Absolute error: $(abs(root - exact_root))\")\nprintln(\"Relative error: $(abs(root - exact_root) / exact_root)\")\n\nApproximate root: 0.7390851332151607\nEvaluated function at the root: 0.0\nNumber of iterations: 6\n\nExact root: 0.7390851332151607\nEvaluated function at the exact root: 0.0\nAbsolute error: 0.0\nRelative error: 0.0\n\n\n\n\n\n\n\n\n\n\n\nHint for Analysis\n\n\n\n\n\nYou can follow the steps below to analyze the convergence of the Newton method:\n\nCompute the error at each iteration as |x_k - x^*|, where x^* is the known or highly accurate root.\nObserve the convergence pattern by plotting the error on a logarithmic scale.\nFor Newton’s method, quadratic convergence is expected when the initial guess is close to the root and the function is well-behaved (e.g., with a non-zero derivative at the root).\nFit a quadratic polynomial to the logarithm of the error to verify quadratic convergence.\n\n\n\n\n\n\n\n\n\n\nCorrection for Analysis\n\n\n\n\n\nTo analyze the convergence of the Newton method for f(x) = \\cos(x) - x, we compute the approximate root at each iteration and calculate the absolute error. Using the exact root x^* \\approx 0.7390851332151607, we determine the error |x_k - x^*|. We also plot the error on a logarithmic scale to observe the convergence behavior.\nBelow is the Julia code for the analysis:\n\nusing Plots\nusing Polynomials\n\nfunction newton_analysis(f, df, x0; tol=1e-12, max_iter=100, true_root=nothing)\n    xk = x0\n    iter_count = 0\n    approximations = []\n    errors = []\n\n    while iter_count &lt; max_iter\n        iter_count += 1\n        x_next = xk - f(xk) / df(xk)\n        push!(approximations, x_next)\n\n        if !isnothing(true_root)\n            push!(errors, abs(x_next - true_root))\n        end\n\n        if abs(x_next - xk) &lt; tol\n            break\n        end\n\n        xk = x_next\n    end\n\n    return approximations, errors\nend\n\n# Exact root for reference\ntrue_root = 0.7390851332151607\nf(x) = cos(x) - x\ndf(x) = -sin(x) - 1\nx0 = 0\napproximations, errors = newton_analysis(f, df, x0, true_root=true_root)\n\n# Exclude zero values for quadratic fitting\nnon_zero_errors = filter(e -&gt; e &gt; 0, errors)  # Only non-zero errors\nindices_non_zero = findall(e -&gt; e &gt; 0, errors)  # Indices of non-zero errors\n\nif length(non_zero_errors) &gt; 2\n    # Fit a quadratic polynomial to the log of non-zero errors\n    p = fit(indices_non_zero, log10.(non_zero_errors), 2)  # Fit quadratic to log10 of errors\n    println(\"Quadratic fit: $p\")\n\n    # Replace zero errors with the values predicted by the quadratic fit\n    for i in 1:length(errors)\n        if errors[i] == 0\n            errors[i] = 10^p(i)  # Replace with the fitted value at the iteration\n        end\n    end\nend\n\n# Print the approximate root and error\nprintln(\"Approximate root: $(approximations[end])\")\nprintln(\"Final error: $(errors[end])\")\n\n# Create the plot\nplt = plot(1:length(errors), errors, yscale=:log10, xlabel=\"Iteration\", ylabel=\"Absolute Error\", \n    title=\"Convergence of the Newton Method\", label=\"Computed Error\",\n    seriestype=:scatter, markersize=5, markerstrokewidth=0, z_order=:front)\n\n# Add the fitted quadratic to the plot\niterations = 1:length(errors)\nfitted_values = 10 .^ p.(iterations)\nplot!(plt, iterations, fitted_values, label=\"Quadratic Fit\", linewidth=2, z_order=:back)\n\n# Show the plot\ndisplay(plt)\n\nQuadratic fit: -1.48323 + 1.79387*x - 0.962095*x^2\nApproximate root: 0.7390851332151607\nFinal error: 4.411134345995057e-26",
    "crumbs": [
      "Content of the course",
      "Applications",
      "Root-Finding Methods"
    ]
  },
  {
    "objectID": "src/type_stability.html",
    "href": "src/type_stability.html",
    "title": "Type stability in Julia",
    "section": "",
    "text": "Note\n\n\n\nThis page is still under construction. For more details about type stability and performance tips, please refer to the official Julia Performance Tips Documentation or visit the page Why Does Julia Work So Well?.\n\n\nIn Julia, type stability is a key concept for writing efficient code. Type stability means that the type of a variable or expression can be determined at compile time, enabling the Julia compiler to optimize the code. When working with advanced types, such as parametric abstract types, it’s important to ensure that your code remains type stable, as this allows Julia’s Just-In-Time (JIT) compiler to generate more efficient machine code.\n\nWhy is Type Stability Important?\nType instability can cause the JIT compiler to generate multiple versions of a function or method, which can degrade performance. Type stability, on the other hand, helps Julia avoid unnecessary runtime checks and ensures that the type of every variable is known before runtime.\nFor instance, if you define a function where the type of its output cannot be predicted based on the input types, Julia may have to fall back to a slower, more generic approach.\n\n\nExample of Type Instability and Stability\nLet’s consider an example using parametric types:\n\nfunction sum_elements(arr::Vector{T}) where T\n    s = 0\n    for x in arr\n        s += x  # Type instability: T is not known to be a number\n    end\n    return s\nend\n\nIn this case, the function sum_elements is type unstable because Julia cannot guarantee that T will always be a numeric type. This can lead to inefficiencies.\nNow, let’s fix this by enforcing type stability:\n\nfunction sum_elements(arr::Vector{T}) where T &lt;: Number\n    s = zero(T)  # Start with the appropriate type for T\n    for x in arr\n        s += x\n    end\n    return s\nend\n\nIn this version, we restrict the type of T to be a subtype of Number, ensuring that the type of s is always numeric and enabling better performance through type stability.\n\n\nKey Points for Ensuring Type Stability\n\nUse specific type annotations whenever possible, especially with parametric types.\nAvoid mixing types that could lead to ambiguities in the function’s return type.\nAlways initialize variables with types that are known, such as using zero(T) for numeric types.\nWhen dealing with generic code, try to define methods that narrow the possible types of variables (e.g., T &lt;: Number).\n\nEnsuring type stability not only helps with performance but also aids in catching potential type errors early during development.\n\n\n\n\n\n\nNote\n\n\n\nTo ensure type stability, the return type of a function should be predictable based on the input types (and not the values), and the types of all variables should be known at compile time.\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Content of the course",
      "Work in progress",
      "Type Stability"
    ]
  },
  {
    "objectID": "src/foretaste_of_julia_code.html",
    "href": "src/foretaste_of_julia_code.html",
    "title": "Foretaste of Julia Code",
    "section": "",
    "text": "Julia is a high-level, high-performance programming language primarily designed for numerical and scientific computing. Its syntax is familiar to users of other technical computing environments, while its flexibility and performance make it an excellent choice for a wide range of applications. In this section, we will look at a few simple examples to illustrate some core features of Julia and demonstrate its intuitive and powerful design.",
    "crumbs": [
      "Content of the course",
      "Foretaste of Julia Code"
    ]
  },
  {
    "objectID": "src/foretaste_of_julia_code.html#variables",
    "href": "src/foretaste_of_julia_code.html#variables",
    "title": "Foretaste of Julia Code",
    "section": "Variables",
    "text": "Variables\n\nSimple Assignment\nIn Julia, you can assign values to variables directly:\n\nx = 1   # Assign an integer to x\n2x      # The result of 2 * x\n\n2\n\n\n\n\nMathematical Operations\nYou can also perform mathematical operations directly on variables:\n\nx = sqrt(2)    # Assign the square root of 2 to x\nx              # Output the value of x\n\n1.4142135623730951\n\n\n\n\nUsing Unicode\nJulia allows you to use Unicode characters in your code, which makes it more expressive:\n\n# Unicode is great\nx = √(2)        # Square root symbol for 2\nx               # The value of x is the square root of 2\n\n1.4142135623730951\n\n\n\n\nCustom Variable Names\nJulia even allows using emojis for variable names:\n\n😄 = sqrt(2)    # Assign the square root of 2 to the emoji variable\n2😄              # Result of 2 times 😄\n\n2.8284271247461903\n\n\n\n\n\n\n\n\nNote\n\n\n\nVisit the list of Unicode Input for more examples.",
    "crumbs": [
      "Content of the course",
      "Foretaste of Julia Code"
    ]
  },
  {
    "objectID": "src/foretaste_of_julia_code.html#functions",
    "href": "src/foretaste_of_julia_code.html#functions",
    "title": "Foretaste of Julia Code",
    "section": "Functions",
    "text": "Functions\n\nSimple Function Definition\nIn Julia, you can define a function using the function keyword:\n\n# this is a function\nfunction f(x)\n  return 2x + 1   # Return a value that is double x plus 1\nend\n\nf (generic function with 1 method)\n\n\nTo evaluate a function, simply call it with an argument:\n\nf(2)  # Output: 5\n\n5\n\n\n\n\nFunction Definition in Assignment Form\nJulia also supports defintion of functions in assignement form, which are often used for short operations:\n\n# This is also a function\ng(x) = 2x + 1   # A shorthand for defining a function\ng(2)            # Output: 5\n\n5\n\n\n\n\nAnonymous Functions\nJulia also supports anonymous functions (functions without a name):\n\n# Another example with anonymous function\nh = x -&gt; 2x^2    # Function definition using the arrow syntax\nh(1)             # Output: 2, since 2 * 1^2 = 2\n\n2\n\n\n\n\nFunction Priority and Operator Precedence\nIn some cases, you need to be cautious about operator precedence:\n\n# Be careful of operator priorities\nh(1 + 1)  # The correct evaluation is 2 * (1+1)^2 = 8\n\n8",
    "crumbs": [
      "Content of the course",
      "Foretaste of Julia Code"
    ]
  },
  {
    "objectID": "src/foretaste_of_julia_code.html#side-effects",
    "href": "src/foretaste_of_julia_code.html#side-effects",
    "title": "Foretaste of Julia Code",
    "section": "Side Effects",
    "text": "Side Effects\nIn Julia, functions can have side effects, meaning they modify variables or objects outside the scope of the function. Here’s an example:\n\nMutating Vectors\nLet’s consider the following vector:\n\nx = [1, 3, 12]\n\n3-element Vector{Int64}:\n  1\n  3\n 12\n\n\nYou can access an element of the vector like this:\n\nx[2]  # Output: 3, the second element of the array\n\n3\n\n\nTo update an element, simply reassign it:\n\nx[2] = 5  # Changes the second element to 5\nx         # Now x = [1, 5, 12]\n\n3-element Vector{Int64}:\n  1\n  5\n 12\n\n\n\n\nSide Effects in Functions\nIf you mutate data inside a function, it will have side effects. For example, consider this function:\n\nfunction f(x, y)\n    x[1] = 42        # Mutates x\n    y = 7 + sum(x)   # New binding for y, no mutation\n    return y\nend\n\na = [4, 5, 6]\nb = 3\n\nprintln(\"f($a, $b) = \", f(a, b))  # f modifies 'a' but not 'b'\nprintln(\"a = \", a, \" # a[1] is changed to 42 by f\")\nprintln(\"b = \", b, \" # b remains unchanged\")\n\nf([4, 5, 6], 3) = 60\na = [42, 5, 6] # a[1] is changed to 42 by f\nb = 3 # b remains unchanged\n\n\n\n\nThe Bang Convention\nWhen a function has side effects, it’s a good practice to use the ! symbol at the end of the function’s name. This is called the bang convention, and it signals that the function mutates its arguments:\n\nfunction put_at_second_place!(x, value)\n  x[2] = value\n  return nothing  # No explicit return, it's just a side effect\nend\n\nx = [1, 3, 12]\nprintln(\"x[2] before: \", x[2])\n\nput_at_second_place!(x, 5)  # Mutates x\nprintln(\"x[2] after: \", x[2])\n\nx[2] before: 3\nx[2] after: 5\n\n\n\n\nCaution with Slices\nWhen you pass a slice of an array to a function in Julia, the slice is actually a copy, so modifying it does not alter the original array:\n\nx = [1, 2, 3, 4]\nprintln(\"x[2] before slice modification: \", x[2])\n\nput_at_second_place!(x[1:3], 15)  # Safe to modify the slice\n\nprintln(\"x[2] after slice modification: \", x[2])  # Original array remains unchanged\n\nx[2] before slice modification: 2\nx[2] after slice modification: 2\n\n\n\n\n\n\n\n\nTip\n\n\n\nWhen working with slices, remember that they are copies in Julia. Modifying a slice will not impact the original array, which helps prevent unintentional changes to your data.",
    "crumbs": [
      "Content of the course",
      "Foretaste of Julia Code"
    ]
  },
  {
    "objectID": "src/foretaste_of_julia_code.html#methods",
    "href": "src/foretaste_of_julia_code.html#methods",
    "title": "Foretaste of Julia Code",
    "section": "Methods",
    "text": "Methods\nJulia supports multiple methods for the same function name, which allows for more flexible and dynamic behavior. Here’s an example:\n\nMethod Overloading\nYou can define several methods for the same function with different types:\n\nΣ(x::Float64, y::Float64) = 2x + y   # Method for Float64 inputs\n\nΣ (generic function with 1 method)\n\n\nCalling the function:\n\nΣ(2.0, 3.0)  # Output: 7.0\n\n7.0\n\n\nIf you call Σ with arguments that don’t match the types, Julia will throw an error:\n\nΣ(2, 3.0)  # Error: no method matching Σ(::Int64, ::Float64)\n\n\nMethodError: no method matching Σ(::Int64, ::Float64)\nThe function `Σ` exists, but no method is defined for this combination of argument types.\n\nClosest candidates are:\n  Σ(::Float64, ::Float64)\n   @ Main In[18]:1\n\n\nStacktrace:\n [1] top-level scope\n   @ In[20]:1\n\n\n\n\n\nMultiple Methods for Different Types\nYou can define more methods that work with different types:\n\nφ(x::Number, y::Number) = 2x - y           # General method for numbers\nφ(x::Int, y::Int)     = 2x * y             # Method for integers\nφ(x::Float64, y::Float64) = 2x + y         # Method for Float64\n\nφ (generic function with 3 methods)\n\n\n\n\nMethod Dispatch Example\nJulia will select the appropriate method based on the argument types:\n\nprintln(\"φ(2,   3.0) = \", φ(2, 3.0))       # Uses general method\nprintln(\"φ(2,   3)   = \", φ(2, 3))         # Uses the integer method\nprintln(\"φ(2.0, 3.0) = \", φ(2.0, 3.0))     # Uses the Float64 method\n\nφ(2,   3.0) = 1.0\nφ(2,   3)   = 12\nφ(2.0, 3.0) = 7.0",
    "crumbs": [
      "Content of the course",
      "Foretaste of Julia Code"
    ]
  },
  {
    "objectID": "src/foretaste_of_julia_code.html#iterators",
    "href": "src/foretaste_of_julia_code.html#iterators",
    "title": "Foretaste of Julia Code",
    "section": "Iterators",
    "text": "Iterators\nIn Julia, iterators allow you to loop through collections in a memory-efficient way. Here’s an example of using 1:5 as an iterator:\n\nfor i in 1:5\n    println(i)\nend\n\n1\n2\n3\n4\n5\n\n\nThis prints the numbers from 1 to 5. You can also iterate through ranges and collections:\n\nfor i in [10, 20, 30]\n    println(i)\nend\n\n10\n20\n30\n\n\n\nWorking with Lazy Collections\nJulia’s Iterators package allows for lazy collections, where values are computed on demand. Here’s an example:\n\nusing Base.Iterators: cycle\nround = 1\nfor i in cycle([1, 2, 3])\n    println(i)\n    if i == 3\n      if round == 2\n        break\n      else\n        round += 1\n      end\n    end\nend\n\n1\n2\n3\n1\n2\n3\n\n\nThis loops over the values 1, 2, and 3, repeating as a cycle.",
    "crumbs": [
      "Content of the course",
      "Foretaste of Julia Code"
    ]
  },
  {
    "objectID": "src/foretaste_of_julia_code.html#type-stability",
    "href": "src/foretaste_of_julia_code.html#type-stability",
    "title": "Foretaste of Julia Code",
    "section": "Type Stability",
    "text": "Type Stability\nJulia has type stability for fast compilation and execution. When writing functions, it’s important to ensure that the type of the return value can be determined without ambiguity.\nExample of type instability:\n\nfunction f(x)\n    if x &gt; 0\n        return 1\n    else\n        return 0.0\n    end\nend\n\nprintln(\"The value  2 of type \", typeof( 2), \" produces an output of type \", typeof(f( 2)))\nprintln(\"The value -2 of type \", typeof(-2), \" produces an output of type \", typeof(f(-2)))\n\nThe value  2 of type Int64 produces an output of type Int64\nThe value -2 of type Int64 produces an output of type Float64\n\n\nJulia is dynamically typed, but ensuring type stability within functions helps the compiler optimize code for better performance.\n\n\n\n\n\n\nTip\n\n\n\nFor better performance, always try to ensure type stability in your functions. This can be achieved by making the return type predictable, from the types of input variables and not their values.",
    "crumbs": [
      "Content of the course",
      "Foretaste of Julia Code"
    ]
  },
  {
    "objectID": "src/foretaste_of_julia_code.html#exercise",
    "href": "src/foretaste_of_julia_code.html#exercise",
    "title": "Foretaste of Julia Code",
    "section": "Exercise",
    "text": "Exercise\n\nLeast Squares Regression Line\nWe propose a first exercise about simple linear regression. The data are excerpted from this example and saved into data.csv. We propose an ordinary least squares formulation which is a type of linear least squares method for choosing the unknown parameters in a linear regression model by the principle of least squares: minimizing the sum of the squares of the differences between the observed dependent variable (values of the variable being observed) in the input dataset and the output of the (linear) function of the independent variable.\n\nGiven a set of m data points y_{1}, y_{2}, \\dots, y_{m}, consisting of experimentally measured values taken at m values x_{1}, x_{2}, \\dots, x_{m} of an independent variable (x_i may be scalar or vector quantities), and given a model function y=f(x,\\beta), with \\beta =(\\beta_{1},\\beta_{2},\\dots ,\\beta_{n}), it is desired to find the parameters \\beta_j such that the model function “best” fits the data. In linear least squares, linearity is meant to be with respect to parameters \\beta_j, so \n  f(x, \\beta) = \\sum_{j=1}^n \\beta_j\\, \\varphi_j(x).\n In general, the functions \\varphi_j may be nonlinear. However, we consider linear regression, that is \n  f(x, \\beta) = \\beta_1 + \\beta_2 x.\n Ideally, the model function fits the data exactly, so \n  y_i = f(x_i, \\beta)\n for all i=1, 2, \\dots, m. This is usually not possible in practice, as there are more data points than there are parameters to be determined. The approach chosen then is to find the minimal possible value of the sum of squares of the residuals \n  r_i(\\beta) = y_i - f(x_i, \\beta), \\quad i=1, 2, \\dots, m\n so to minimize the function \n  S(\\beta) = \\sum_{i=1}^m r_i^2(\\beta).\n In the linear least squares case, the residuals are of the form \n  r(\\beta) = y - X\\, \\beta\n with y = (y_i)_{1\\le i\\le m} \\in \\mathbb{R}^m and X = (X_{ij})_{1\\le i\\le m, 1\\le j\\le n} \\in \\mathrm{M}_{mn}(\\mathbb{R}), where X_{ij} = \\varphi_j(x_i). Since we consider linear regression, the i-th row of the matrix X is given by \n  X_{i[:]} = [1 \\quad x_i].\n The objective function may be written \n  S(\\beta) = {\\Vert y - X\\, \\beta \\Vert}^2\n where the norm is the usual 2-norm. The solution to the linear least squares problem \n  \\underset{\\beta \\in \\mathbb{R}^n}{\\mathrm{minimize}}\\, {\\Vert y - X\\, \\beta \\Vert}^2\n is computed by solving the normal equation \n  X^\\top X\\, \\beta = X^\\top y,\n where X^\\top denotes the transpose of X.\n\n\nQuestions\nTo answer the questions you need to import the following packages.\n\nusing DataFrames\nusing CSV\nusing Plots\n\nYou also need to download the csv file. Click on the following image.\n  \n\nUsing the packages DataFrames.jl and CSV.jl, load the dataset from data/introduction/data.csv and save the result into a variable named dataset.\n\n\n\nShow the answer\npath = \"data/introduction/data.csv\" # update depending on the location of your file\ndataset = DataFrame(CSV.File(path))\n\n\n5×2 DataFrame\n\n\n\nRow\nTime\nMass\n\n\n\nInt64\nInt64\n\n\n\n\n1\n5\n40\n\n\n2\n7\n120\n\n\n3\n12\n180\n\n\n4\n16\n210\n\n\n5\n20\n240\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nDo not hesitate to visit the documentation of CSV.jl and DataFrames.jl.\n\n\n\nUsing the package Plot.jl, plot the data.\n\n\n\n\n\n\n\nHint\n\n\n\n\n\nUse names(dataset) to get the list of data names. If Time is a name you can access to the associated data by dataset.Time.\n\n\n\n\n\nShow the answer\nplt = plot(\n  dataset.Time, \n  dataset.Mass,\n  seriestype=:scatter, \n  legend=false, \n  xlabel=\"Time\", \n  ylabel=\"Mass\"\n)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCreate the matrix X, the vector \\beta and solve the normal equation with the operator Base.\\.\n\n\n\n\n\n\n\nHint\n\n\n\n\n\nUse ones(m) to generate a vector of 1 of length m.\n\n\n\n\n\nShow the answer\nm = length(dataset.Time)\nX = [ones(m) dataset.Time]\ny = dataset.Mass\nβ = X\\y\n\n\n2-element Vector{Float64}:\n 11.506493506493449\n 12.207792207792208\n\n\n\nPlot the linear model on the same plot as the data. Use the plot! function. See the basic concepts for plotting.\n\n\n\nShow the answer\nx = [5, 20]\ny = β[1] .+ β[2]*x\nplot!(plt, x, y)",
    "crumbs": [
      "Content of the course",
      "Foretaste of Julia Code"
    ]
  },
  {
    "objectID": "src/basic-types.html",
    "href": "src/basic-types.html",
    "title": "Basic Types and Data Structures in Julia",
    "section": "",
    "text": "In Julia, understanding the fundamental types and data structures is essential for efficient coding and problem-solving. This page provides an introduction to some of the basic types in Julia, including integers, floating-point numbers, strings, and composite types like arrays and tuples. We’ll also explore more advanced data structures and their practical uses.\nYou’ll learn about:\nWhether you’re a beginner or looking to deepen your understanding of Julia’s type system, this page will help you get familiar with the core building blocks for handling data efficiently in Julia.",
    "crumbs": [
      "Content of the course",
      "Basic Types and Data Structures"
    ]
  },
  {
    "objectID": "src/basic-types.html#introduction-to-types-in-julia",
    "href": "src/basic-types.html#introduction-to-types-in-julia",
    "title": "Basic Types and Data Structures in Julia",
    "section": "Introduction to Types in Julia",
    "text": "Introduction to Types in Julia\nJulia is a dynamically typed language, meaning that variable types are determined at runtime. However, Julia also supports strong typing, which means that types are important and can be explicitly specified when needed. Understanding types in Julia is essential for writing efficient code, as the language uses Just-In-Time (JIT) compilation to optimize based on variable types.\n\nDynamic Typing\nIn Julia, variables do not require explicit type declarations. The type of a variable is inferred based on the value assigned to it.\n\nx = 10          # x is inferred to be of type Int64\ny = 3.14        # y is inferred to be of type Float64\nz = \"Hello\"     # z is inferred to be of type String\n\ntypeof(x), typeof(y), typeof(z)\n\njulia&gt; x = 10\njulia&gt; y = 3.14\njulia&gt; z = \"Hello\"\njulia&gt; (typeof(x), typeof(y), typeof(z)) = (Int64, Float64, String)\n\n\nEven though Julia automatically infers types, you can still explicitly specify them when necessary, particularly for performance optimization or for ensuring that a variable matches a particular type.\n\n\nStrong Typing\nWhile Julia uses dynamic typing, it is strongly typed. This means that Julia will enforce type constraints on operations, and will raise errors when an operation is attempted with incompatible types.\nYou can add an integer and a float,\n\nn = 5           # Integer\nx = 2.0         # Float\nn + x           # we can add an Int64 and a Float64\n\njulia&gt; n = 5\njulia&gt; x = 2.0\njulia&gt; n + x = 7.0\n\n\nbut you cannot add an integer and a string:\n\ns = \"Hello\"     # String\nn + s           # Error: does not make sense to add an Int64 and a String\n\njulia&gt; s = \"Hello\"\njulia&gt; n + s\n\n\n\nMethodError: no method matching +(::Int64, ::String)\nThe function `+` exists, but no method is defined for this combination of argument types.\n\nClosest candidates are:\n  +(::Any, ::Any, ::Any, ::Any...)\n   @ Base operators.jl:596\n  +(::Real, ::Complex{Bool})\n   @ Base complex.jl:322\n  +(::Real, ::Complex)\n   @ Base complex.jl:334\n  ...\n\n\nStacktrace:\n [1] macro expansion\n   @ show.jl:1232 [inlined]\n [2] macro expansion\n   @ ~/Courses/julia/course-tse-julia/assets/julia/myshow.jl:82 [inlined]\n [3] top-level scope\n   @ In[5]:3\n\n\n\nWe see from the error message that we can add an Integer and a Char: +(::Integer, ::AbstractChar) is a valid operation. This is because a Char can be treated as an integer in Julia.\n\nc = 'a'      # Char\nc + 128448   # This will work because Char can be treated as an integer\n\njulia&gt; c = 'a'\njulia&gt; c + 128448 = '😡'\n\n\nJulia allows flexibility compared to statically typed languages like C or Java, but still ensures that operations make sense for the types involved.\n\n\nType System and Performance\nThe type system in Julia plays a key role in performance. By inferring or specifying types, Julia’s JIT compiler can optimize code for specific data types, leading to faster execution. For example, when types are known at compile time, Julia can generate machine code tailored for the specific types involved.\nJulia’s type system also supports abstract types, allowing for more flexible and generic code, as well as parametric types that let you define functions or types that work with any data type.\n\n\nSummary\n\nJulia is dynamically typed but enforces strong typing.\nTypes are inferred from the values assigned to variables.\nJulia optimizes performance based on types, making type information crucial.",
    "crumbs": [
      "Content of the course",
      "Basic Types and Data Structures"
    ]
  },
  {
    "objectID": "src/basic-types.html#basic-types",
    "href": "src/basic-types.html#basic-types",
    "title": "Basic Types and Data Structures in Julia",
    "section": "Basic Types",
    "text": "Basic Types\nJulia has several basic (or primitive) types that are fundamental to working with the language. These include numerical types, characters, and strings. Understanding these types is crucial as they form the building blocks for more complex data structures.\n\nCommon Basic Types\n\nInt: Represents integer values. Julia has multiple types of integers, such as Int8, Int16, Int32, and Int64 depending on the desired size. By default, Int refers to the most appropriate integer type for the system (usually Int64 on modern systems).\nFloat64: Represents floating-point numbers with double precision.\nString: Represents sequences of characters.\nBool: Represents Boolean values, i.e., true or false.\nChar: Represents individual Unicode characters.\n\n\n\nExample Usage of Basic Types\n\n# Integer type (default is Int64)\na = 42         # a is of type Int64\n\n# Float type (default is Float64)\nb = 3.14       # b is of type Float64\n\n# String type\nc = \"Hello\"    # c is of type String\n\n# Boolean type\nd = true       # d is of type Bool\n\n# Char type\ne = 'α'        # e is of type Char\n\nThese basic types are often used for simple calculations and conditionals. Julia allows operations between different types, but it will raise an error if the types are incompatible.",
    "crumbs": [
      "Content of the course",
      "Basic Types and Data Structures"
    ]
  },
  {
    "objectID": "src/basic-types.html#collections-and-data-structures",
    "href": "src/basic-types.html#collections-and-data-structures",
    "title": "Basic Types and Data Structures in Julia",
    "section": "Collections and Data Structures",
    "text": "Collections and Data Structures\n\nJulia as an Array Programming Language\nJulia is designed as an array programming language, focusing on operations that apply to entire arrays or subarrays rather than individual elements. This paradigm simplifies code for numerical, scientific, and data-intensive applications. By leveraging features like broadcasting and vectorized operations, Julia allows for efficient and concise code, enhancing performance without sacrificing readability. Array programming is central to Julia’s capabilities, enabling fast computation on large datasets and making it ideal for high-performance scientific computing.\n\n\nArrays, Vectors, and Matrices\nIn Julia, arrays are fundamental data structures that can hold elements of any type. Arrays can be one-dimensional (vectors) or two-dimensional (matrices), and they can hold data of various types.\n\nCreating an Array:\n\n\narr = [1, 2, 3, 4]  # A simple 1D array (vector)\n\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4\n\n\n\nmatrix = [1 2 3; 4 5 6]  # A 2D array (matrix)\n\n2×3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n\n\n\nAccessing Array Elements:\n\n\narr[1]   # Access the first element of the array\n\n1\n\n\n\nmatrix[2, 3]  # Access the element in the second row, third column\n\n6\n\n\n\nSlicing of Vectors and Matrices\nYou can extract slices (sub-arrays) of vectors and matrices in Julia. The slicing syntax allows you to access specific portions of an array.\n\nSlicing a vector:\n\n\narr[2:4]  # Extracts elements from index 2 to 4: [2, 3, 4]\n\n3-element Vector{Int64}:\n 2\n 3\n 4\n\n\n\nSlicing a matrix:\n\n\nmatrix[1, :]   # Extracts the first row: [1, 2, 3]\n\n3-element Vector{Int64}:\n 1\n 2\n 3\n\n\n\nmatrix[:, 2]   # Extracts the second column: [2, 5]\n\n2-element Vector{Int64}:\n 2\n 5\n\n\n\n\nMutation of Arrays\nArrays in Julia are mutable, meaning their elements can be changed after creation. The .= operator is commonly used to apply element-wise operations.\n\nModify an individual element:\n\n\narr[2] = 99  # Change the second element to 99\n\n99\n\n\n\nElement-wise operation with .=:\n\n\narr .+= 10  # Adds 10 to each element of the array, resulting in [11, 12, 13, 14]\n\n4-element Vector{Int64}:\n  11\n 109\n  13\n  14\n\n\n\nmatrix .*= 2  # Multiplies each element of the matrix by 2, resulting in [2 4 6; 8 10 12]\n\n2×3 Matrix{Int64}:\n 2   4   6\n 8  10  12\n\n\n\nPush an element into an array (mutates the array by adding a new element):\n\n\npush!(arr, 40)  # Adds 40 to the end of the array\n\n5-element Vector{Int64}:\n  11\n 109\n  13\n  14\n  40\n\n\n\nPop an element from an array (removes the last element):\n\n\npop!(arr)  # Removes the last element, which is 40 in this case\n\n40\n\n\n\n\nMutation Inside a Function\nWhen working with arrays inside a function, it’s important to note that reassigning the entire array (e.g., v = [1, 2]) does not mutate the original array but rather creates a new one locally scoped to the function. To modify the contents of an array in place, use either v[:] = ... or the more flexible broadcasting syntax v .= ....\n\nIncorrect way (does not mutate the original vector):\n\n\nfunction incorrect_mutate(v)\n    v = [1, 2]  # This creates a new array and does not affect the input\nend\n\nvec = [10, 20]\nincorrect_mutate(vec)\nprintln(vec)  # Outputs: [10, 20]\n\n[10, 20]\n\n\n\nCorrect way using v[:] = ...:\n\n\nfunction correct_mutate(v)\n    v[:] = [1, 2]  # Mutates the input vector\nend\n\nvec = [10, 20]\ncorrect_mutate(vec)\nprintln(vec)  # Outputs: [1, 2]\n\n[1, 2]\n\n\n\nUsing broadcasting (v .= ...):\n\n\nfunction flexible_mutate(v)\n    v .= [1, 2]  # More flexible, works for both vectors and matrices\nend\n\nvec = [10, 20]\nflexible_mutate(vec)\nprintln(vec)  # Outputs: [1, 2]\n\nmat = [10 20; 30 40]\nmat .= [1 2; 3 4]  # Updates all elements in-place\nprintln(mat)  # Outputs: [1 2; 3 4]\n\n[1, 2]\n[1 2; 3 4]\n\n\nUsing v .= ... is preferred for its flexibility, as it works seamlessly for arrays of any shape, including matrices. Without broadcasting, you would need to use M[:, :] = ... for matrices to achieve the same effect.\n\n\nSpecial Arrays\nJulia has built-in functions to create arrays with predefined values:\n\nCreate an array of zeros:\n\n\nzeros(3)  # Creates an array of zeros with 3 elements: [0.0, 0.0, 0.0]\n\n3-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n\n\n\nCreate an array of ones:\n\n\nones(2, 3)  # Creates a 2x3 matrix filled with ones: [1.0 1.0 1.0; 1.0 1.0 1.0]\n\n2×3 Matrix{Float64}:\n 1.0  1.0  1.0\n 1.0  1.0  1.0\n\n\n\n\n\nDictionaries (Dict)\nA Dict in Julia is an associative collection that maps keys to values. This allows for efficient lookups, insertions, and deletions based on unique keys.\n\nCreating a Dictionary:\n\n\nd = Dict(\"name\" =&gt; \"Alice\", \"age\" =&gt; 25)\n\nDict{String, Any} with 2 entries:\n  \"name\" =&gt; \"Alice\"\n  \"age\"  =&gt; 25\n\n\nThis creates a dictionary where \"name\" maps to \"Alice\" and \"age\" maps to 25.\n\nAccessing Values:\n\nYou can access values in a dictionary using their corresponding keys:\n\nd[\"name\"]  # Outputs: \"Alice\"\n\n\"Alice\"\n\n\n\nAdding and Updating Values:\n\nTo add a new key-value pair or update an existing one, you can use the following syntax:\n\nd[\"location\"] = \"Paris\"  # Adds a new key-value pair\nd[\"age\"] = 26            # Updates the value associated with the key \"age\"\ndisplay(d)\n\nDict{String, Any} with 3 entries:\n  \"name\"     =&gt; \"Alice\"\n  \"location\" =&gt; \"Paris\"\n  \"age\"      =&gt; 26\n\n\n\nRemoving Key-Value Pairs:\n\nTo remove a key-value pair, use the delete! function:\n\ndelete!(d, \"location\")\n\nDict{String, Any} with 2 entries:\n  \"name\" =&gt; \"Alice\"\n  \"age\"  =&gt; 26\n\n\n\nIteration over Key-Value Pairs:\n\nYou can iterate through the keys, values, or pairs in a dictionary using keys, values, and pairs respectively:\n\nfor (k, v) in pairs(d)\n    println(\"Key: $k, Value: $v\")\nend\n\nKey: name, Value: Alice\nKey: age, Value: 26\n\n\n\n\nTuples and Named Tuples\nJulia Tuples are ordered collections of elements, while Named Tuples are tuples where elements are associated with names (keys). Tuples are immutable, meaning their elements cannot be changed after creation.\n\nBasic usage of Tuples and Named Tuples\n\nTuple is an ordered collection of elements, which can hold elements of different types.\n\n\nt = (1, \"Julia\", true)  # A tuple with three elements\n\n(1, \"Julia\", true)\n\n\n\nNamedTuple is a special kind of tuple where elements are associated with names (keys).\n\n\nnt = (name = \"Alice\", age = 25)  # A NamedTuple with named fields\n\n(name = \"Alice\", age = 25)\n\n\nYou can access the elements by their name:\n\nnt.name  # Access the field 'name' of the NamedTuple, returns \"Alice\"\n\n\"Alice\"\n\n\n\nMutation of a Tuple: Tuples are immutable, so attempting to change their elements will result in an error.\n\n\nt[1] = 99  # Trying to modify a tuple element will result in an error\n\n\nMethodError: no method matching setindex!(::Tuple{Int64, String, Bool}, ::Int64, ::Int64)\nThe function `setindex!` exists, but no method is defined for this combination of argument types.\n\nStacktrace:\n [1] top-level scope\n   @ In[33]:1\n\n\n\nThe above line will raise an error because tuples are immutable in Julia, and their elements cannot be modified after creation.\n\n\nTuples in Function\nIn Julia, tuples and named tuples play an important role in function definitions and return values.\n\nPositional and Keyword Arguments:\n\nWhen defining functions with a variable number of arguments, Julia uses tuples to capture positional arguments and named tuples for keyword arguments:\n\nfunction example_function(args...; kwargs...)\n    println(\"Positional arguments type: \", typeof(args))\n    println(\"Keyword arguments type: \", typeof(kwargs))\n    return kwargs\nend\n\nkw = example_function(1, 2, 3; name=\"Alice\", age=30)\n\nPositional arguments type: Tuple{Int64, Int64, Int64}\nKeyword arguments type: Base.Pairs{Symbol, Any, Tuple{Symbol, Symbol}, @NamedTuple{name::String, age::Int64}}\n\n\nIn this example, args is of type Tuple, containing all positional arguments, while kwargs is based on a NamedTuple, containing all keyword arguments. The arguments are captured using the args... and kwargs... syntax. The kwargs argument is actually a ‘Base.Pairs’:\n\nkw\n\npairs(::NamedTuple) with 2 entries:\n  :name =&gt; \"Alice\"\n  :age  =&gt; 30\n\n\n\ntypeof(kw)\nkw isa Base.Pairs\nkw isa AbstractDict\nkeys(kw)\nvalues(kw)\npairs(kw)\nkw[:name]\nkw[:age]\n\njulia&gt; typeof(kw) = Base.Pairs{Symbol, Any, Tuple{Symbol, Symbol}, @NamedTuple{name::String, age::Int64}}\njulia&gt; kw isa Base.Pairs = true\njulia&gt; kw isa AbstractDict = true\njulia&gt; keys(kw) = (:name, :age)\njulia&gt; values(kw) = (name = \"Alice\", age = 30)\njulia&gt; pairs(kw) = Base.Pairs{Symbol, Any, Tuple{Symbol, Symbol}, @NamedTuple{name::String, age::Int64}}(:name =&gt; \"Alice\", :age =&gt; 30)\njulia&gt; kw[:name] = \"Alice\"\njulia&gt; kw[:age] = 30\n\n\nActually, the values are a NamedTuple:\n\ntypeof(values(kw))\n\n@NamedTuple{name::String, age::Int64}\n\n\nContrary to a Dict, you cannot add entries to a Base.Pairs:\n\nkw[:height] = 5.9\n\n\nMethodError: no method matching setindex!(::@NamedTuple{name::String, age::Int64}, ::Float64, ::Symbol)\nThe function `setindex!` exists, but no method is defined for this combination of argument types.\n\nStacktrace:\n [1] setindex!(v::@Kwargs{name::String, age::Int64}, value::Float64, key::Symbol)\n   @ Base.Iterators ./iterators.jl:325\n [2] top-level scope\n   @ In[38]:1\n\n\n\n\nReturning Tuples:\n\nIn Julia, when a function returns multiple values separated by commas, they are automatically returned as a tuple:\n\nfunction return_multiple_values()\n    return 1, \"Julia\", true\nend\n\nresult = return_multiple_values()\nprintln(\"Result type: \", typeof(result))\n\nResult type: Tuple{Int64, String, Bool}\n\n\nSo, return_multiple_values() returns a tuple with three elements.",
    "crumbs": [
      "Content of the course",
      "Basic Types and Data Structures"
    ]
  },
  {
    "objectID": "src/basic-types.html#composite-types",
    "href": "src/basic-types.html#composite-types",
    "title": "Basic Types and Data Structures in Julia",
    "section": "Composite Types",
    "text": "Composite Types\n\nIntroduction to struct\nIn Julia, you can define your own custom data types using the struct keyword. Composite types are user-defined types that group together different pieces of data into one object. A struct is a great way to create a type that can represent a complex entity with multiple fields.\n\nCreating a custom struct:\n\n\n# Define a simple struct for a point in 2D space\nstruct Point\n    x::Float64\n    y::Float64\nend\n\nHere, we created a Point struct with two fields: x and y, both of which are of type Float64.\n\nCreating an instance of a struct:\n\n\np = Point(3.0, 4.0)  # Creates a Point with x = 3.0 and y = 4.0\n\nPoint(3.0, 4.0)\n\n\n\nAccessing fields of a struct:\n\n\np.x  # Access the 'x' field of the Point instance\np.y  # Access the 'y' field of the Point instance\n\n4.0\n\n\nYou can access the fields of a struct directly using dot notation, as shown above.\n\nGet the names of the fields:\n\n\nfieldnames(Point)  # Returns the names of the fields in the Point struct\n\n(:x, :y)\n\n\n\n\nMutability of struct\nIn Julia, structs are immutable by default, meaning once you create an instance of a struct, its fields cannot be changed. However, you can create mutable structs by using the mutable struct keyword, which allows modification of field values after creation.\n\nCreating a mutable struct:\n\n\nmutable struct MutablePoint\n    x::Float64\n    y::Float64\nend\n\nNow you can modify the fields of MutablePoint instances after they are created.\n\nmp = MutablePoint(1.0, 2.0)\nmp.x = 3.0  # Modify the 'x' field\n\n\n\nExample: struct for a Circle\nWe can create a more complex type, such as a Circle, which has a center represented by a Point and a radius:\n\nstruct Circle\n    center::Point\n    radius::Float64\nend\n\n\nCreating an instance of Circle:\n\n\nc = Circle(Point(0.0, 0.0), 5.0)  # Create a circle with center (0, 0) and radius 5\n\nCircle(Point(0.0, 0.0), 5.0)\n\n\n\nAccessing fields of a nested struct:\n\n\nc.center.x  # Access the x field of the center of the circle\nc.center.y  # Access the y field of the center of the circle\nc.radius    # Access the radius of the circle\n\n\n\nAdding a Custom Constructor\nJulia allows you to define custom constructors for structs. These constructors enable additional logic during object creation, such as validating inputs or providing default values. Here’s an example of a custom constructor for a Circle that ensures the radius is always positive and converts the center coordinates to Float64 if they are not already:\n\nstruct Circle\n    center::Point\n    radius::Float64\nend\n\n# Define a custom constructor\nfunction Circle(x::Real, y::Real, radius::Real)\n    if radius &lt;= 0\n        throw(DomainError(radius, \"Radius must be positive\"))\n    end\n    Circle(Point(float(x), float(y)), float(radius))\nend\n\n\nExplanation:\n\nThe custom constructor accepts the center’s x and y coordinates and the radius as inputs.\nIt checks if the radius is positive, throwing an error otherwise.\nIt converts the inputs to Float64 using float, ensuring consistency with the field types defined in the Circle struct.\n\nUsage:\n\n\n# Create a Circle using the custom constructor\nc = Circle(0, 0, 5)  # Creates a Circle with center (0.0, 0.0) and radius 5.0\n\n# Attempt to create a Circle with an invalid radius\nc = Circle(0, 0, -3)  # Throws an error: \"Radius must be positive\"\n\njulia&gt; c = Circle(Point(0.0, 0.0), 5.0)\njulia&gt; c = Circle(0, 0, -3)\n\n\n\nDomainError with -3:\nRadius must be positive\n\nStacktrace:\n [1] Circle(x::Int64, y::Int64, radius::Int64)\n   @ Main ./In[49]:9\n [2] macro expansion\n   @ ~/Courses/julia/course-tse-julia/assets/julia/myshow.jl:53 [inlined]\n [3] top-level scope\n   @ In[50]:7\n\n\n\n\n\nFunction-like Object (Callable struct)\nIn Julia, you can make a struct “callable” by defining the call method for it. This allows instances of the struct to be used like functions. This feature is useful for encapsulating parameters or states in a type while still allowing it to behave like a function.\nHere’s an example that demonstrates a callable struct for a linear transformation:\n\n# Define a callable struct for a linear transformation\nstruct LinearTransform\n    a::Float64  # Slope\n    b::Float64  # Intercept\nend\n\n# Define the call method for LinearTransform\nfunction (lt::LinearTransform)(x::Real)\n    lt.a * x + lt.b  # Apply the linear transformation\nend\n\n\nExplanation:\n\nThe LinearTransform struct stores the parameters of the linear function ( y = ax + b ).\nBy defining the call method for the struct, you enable instances of LinearTransform to behave like a function.\n\nUsage:\n\n\n# Create an instance of LinearTransform\nlt = LinearTransform(2.0, 3.0)  # y = 2x + 3\n\n# Call the instance like a function\ntypeof(lt)  # Output: LinearTransform\ny1 = lt(5)   # Calculates 2 * 5 + 3 = 13\ny2 = lt(-1)  # Calculates 2 * -1 + 3 = 1\n\njulia&gt; typeof(lt) = LinearTransform\njulia&gt; y1 = 13.0\njulia&gt; y2 = 1.0\n\n\n\n\nExtending the Concept: Composable Linear Transforms\nYou can take this idea further by allowing composition of transformations. For example:\n\n# Define a method to compose two LinearTransform objects\nfunction (lt1::LinearTransform)(lt2::LinearTransform)\n    LinearTransform(lt1.a * lt2.a, lt1.a * lt2.b + lt1.b)\nend\n\n# Example usage\nlt1 = LinearTransform(2.0, 3.0)  # y = 2x + 3\nlt2 = LinearTransform(0.5, 1.0)  # y = 0.5x + 1\n\n# Compose the two transformations\nlt_composed = lt1(lt2)  # Equivalent to y = 2 * (0.5x + 1) + 3\n\n# Call the composed transformation\ny = lt_composed(4)  # Calculates 2 * (0.5 * 4 + 1) + 3 = 9\n\njulia&gt; y = 9.0\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe previous composition is equivalent in pure Julia to:\n\ny = (lt1 ∘ lt2)(4)\n\n9.0\n\n\n\n\n\n\nConclusion\n\nIn Julia, struct allows you to create complex custom types that can hold different types of data. Custom constructors provide flexibility for struct initialization, allowing validation and preprocessing of input data. This is especially useful for enforcing constraints and ensuring type consistency. By default, structs are immutable, but you can use mutable struct if you need to change the data after creation.\nUsing a callable struct allows you to represent parameterized functions or transformations in a concise and reusable way. The concept can be extended further to support operations like composition or chaining, making it a powerful tool for functional-style programming in Julia.",
    "crumbs": [
      "Content of the course",
      "Basic Types and Data Structures"
    ]
  },
  {
    "objectID": "src/basic-types.html#exercises",
    "href": "src/basic-types.html#exercises",
    "title": "Basic Types and Data Structures in Julia",
    "section": "Exercises",
    "text": "Exercises\n\nExercise 1: Creating a Shape System\nCreate a system to represent different geometric shapes (like a Rectangle, Circle, and Point) using the following requirements:\n\nDefine a Point struct with x and y coordinates of type Float64.\nDefine a Rectangle struct with fields length and width of type Float64. Use the Point struct to represent the bottom-left corner of the rectangle.\nDefine a Circle struct with a Point for the center and a radius of type Float64.\nWrite a function area(shape) that computes the area of the given shape:\n\nThe area of a rectangle is length * width.\nThe area of a circle is π * radius^2.\n\n\n\n\n\n\n\n\nHint for Exercise 1:\n\n\n\n\n\n\nUse struct to define Point, Rectangle, and Circle.\nUse dot notation to access the fields of the structs.\nUse conditional logic (e.g., typeof()) to handle different shapes in the area function.\nFor the circle, use π = 3.141592653589793.\n\n\n\n\n\n\n\n\n\n\nCorrection of Exercise 1:\n\n\n\n\n\n\n# Define the Point struct\nstruct Point\n    x::Float64\n    y::Float64\nend\n\n# Define the Rectangle struct\nstruct Rectangle\n    bottom_left::Point\n    length::Float64\n    width::Float64\nend\n\n# Define the Circle struct\nstruct Circle\n    center::Point\n    radius::Float64\nend\n\n# Function to calculate the area\nfunction area(shape)\n    if typeof(shape) == Rectangle\n        return shape.length * shape.width\n    elseif typeof(shape) == Circle\n        return π * shape.radius^2\n    else\n        throw(ArgumentError(\"Unsupported shape\"))\n    end\nend\n\n# Example usage\np1 = Point(0.0, 0.0)\nr1 = Rectangle(p1, 3.0, 4.0)\nc1 = Circle(p1, 5.0)\n\nprintln(\"Area of rectangle: \", area(r1))  # Should print 12.0\nprintln(\"Area of circle: \", area(c1))     # Should print 78.53981633974483\n\nArea of rectangle: 12.0\nArea of circle: 78.53981633974483\n\n\n\n\n\n\n\nExercise 2: Working with Complex Numbers and Arrays\n\nCreate two complex numbers z1 and z2 of type Complex{Float64}.\nWrite a function add_complex(z1, z2) that adds two complex numbers and returns the result.\nCreate an array of complex numbers and use the map function to add 2.0 to the real part of each complex number.\nCreate a function max_real_part that returns the complex number with the largest real part from an array of complex numbers.\n\n\n\n\n\n\n\nHint for Exercise 2:\n\n\n\n\n\n\nUse the Complex{T} type to create complex numbers.\nYou can access the real and imaginary parts of a complex number with real(z) and imag(z).\nUse the map function to apply a transformation to each element of an array.\nCompare the real parts of the complex numbers using real(z) to find the maximum.\n\n\n\n\n\n\n\n\n\n\nCorrection of Exercise 2:\n\n\n\n\n\n\n# Create two complex numbers\nz1 = Complex{Float64}(3.0, 4.0)  # z1 = 3.0 + 4.0im\nz2 = Complex{Float64}(1.0, 2.0)  # z2 = 1.0 + 2.0im\n\n# Function to add two complex numbers\nfunction add_complex(z1, z2)\n    return z1 + z2\nend\n\n# Add 2.0 to the real part of each complex number in an array\narr = [Complex{Float64}(3.0, 4.0), Complex{Float64}(1.0, 2.0), Complex{Float64}(5.0, 6.0)]\nnew_arr = map(z -&gt; Complex(real(z) + 2.0, imag(z)), arr)\n\nprintln(\"New array with modified real parts: \", new_arr)\n\n# Function to find the complex number with the largest real part\nfunction max_real_part(arr)\n    max_z = arr[1]\n    for z in arr\n        if real(z) &gt; real(max_z)\n            max_z = z\n        end\n    end\n    return max_z\nend\n\n# Find the complex number with the largest real part\nmax_z = max_real_part(arr)\nprintln(\"Complex number with the largest real part: \", max_z)\n\nNew array with modified real parts: ComplexF64[5.0 + 4.0im, 3.0 + 2.0im, 7.0 + 6.0im]\nComplex number with the largest real part: 5.0 + 6.0im\n\n\n\n\n\n\n\nExercise 3: Manipulating Tuples\n\nCreate a tuple t with three elements: a string, an integer, and a float.\nTry to mutate the first element of the tuple and handle any errors using a try-catch block.\nCreate a NamedTuple nt with fields name, age, and height, and initialize it with your details.\n\n\n\n\n\n\n\nHint for Exercise 3:\n\n\n\n\n\n\nRemember that tuples are immutable, so you can’t modify their elements.\nUse a try-catch block to catch errors if an operation fails.\n\n\n\n\n\n\n\n\n\n\nCorrection of Exercise 3:\n\n\n\n\n\n\n# Create a tuple with three elements: a string, an integer, and a float\nt = (\"John\", 25, 5.9)\n\n# Attempt to mutate the first element of the tuple with error handling\ntry\n    t[1] = \"Alice\"  # This will raise an error because tuples are immutable\ncatch e\n    println(\"Error: \", e)\nend\n\n# Create a NamedTuple with fields: name, age, and height\nnt = (name = \"John\", age = 25, height = 5.9)\n\nprintln(\"NamedTuple: \", nt)\n\nError: MethodError(setindex!, ((\"John\", 25, 5.9), \"Alice\", 1), 0x0000000000006895)\nNamedTuple: (name = \"John\", age = 25, height = 5.9)",
    "crumbs": [
      "Content of the course",
      "Basic Types and Data Structures"
    ]
  },
  {
    "objectID": "src/interoperability.html",
    "href": "src/interoperability.html",
    "title": "Interoperability",
    "section": "",
    "text": "Calling C and Fortran Code\nCalling Python, R, and Other Languages",
    "crumbs": [
      "Content of the course",
      "Work in progress",
      "Interoperability"
    ]
  },
  {
    "objectID": "src/interoperability.html#references",
    "href": "src/interoperability.html#references",
    "title": "Interoperability",
    "section": "",
    "text": "Calling C and Fortran Code\nCalling Python, R, and Other Languages",
    "crumbs": [
      "Content of the course",
      "Work in progress",
      "Interoperability"
    ]
  }
]