{
  "hash": "5de110995c40bd0b7d568d24addeb9ec",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Basic Types and Data Structures in Julia\"\npage-layout: article\njupyter: julia-1.11\n---\n\n\n\nIn Julia, understanding the fundamental types and data structures is essential for efficient coding and problem-solving. This page provides an introduction to some of the basic types in Julia, including integers, floating-point numbers, strings, and composite types like arrays and tuples. Weâ€™ll also explore more advanced data structures and their practical uses.\n\nYou'll learn about:\n\n- **Basic Types** such as integers, floating-point numbers, and strings.\n- **Data Structures** like arrays, vectors, matrices, dictionaries, tuples, and `NamedTuple`.\n- The importance of **Type Declarations** and how to use them effectively.\n- How to work with **Collections** and **Composite Types** to model more complex data.\n\nWhether you're a beginner or looking to deepen your understanding of Julia's type system, this page will help you get familiar with the core building blocks for handling data efficiently in Julia.\n\n## Introduction to Types in Julia\n\nJulia is a dynamically typed language, meaning that variable types are determined at runtime. However, Julia also supports strong typing, which means that types are important and can be explicitly specified when needed. Understanding types in Julia is essential for writing efficient code, as the language uses Just-In-Time (JIT) compilation to optimize based on variable types.\n\n### Dynamic Typing\nIn Julia, variables do not require explicit type declarations. The type of a variable is inferred based on the value assigned to it.\n\n::: {#f708fc73 .cell execution_count=2}\n``` {.julia .cell-code}\n@myshow begin #| hide\nx = 10          # x is inferred to be of type Int64\ny = 3.14        # y is inferred to be of type Float64\nz = \"Hello\"     # z is inferred to be of type String\n\ntypeof(x), typeof(y), typeof(z)\nend #| hide\n```\n\n::: {.cell-output .cell-output-stdout}\n```\njulia> x = 10\njulia> y = 3.14\njulia> z = \"Hello\"\njulia> (typeof(x), typeof(y), typeof(z)) = (Int64, Float64, String)\n```\n:::\n:::\n\n\nEven though Julia automatically infers types, you can still explicitly specify them when necessary, particularly for performance optimization or for ensuring that a variable matches a particular type.\n\n### Strong Typing\nWhile Julia uses dynamic typing, it is strongly typed. This means that Julia will enforce type constraints on operations, and will raise errors when an operation is attempted with incompatible types.\n\nYou can add an integer and a float,\n\n::: {#e36d0b42 .cell execution_count=3}\n``` {.julia .cell-code}\n@myshow begin #| hide\nn = 5           # Integer\nx = 2.0         # Float\nn + x           # we can add an Int64 and a Float64\nend #| hide\n```\n\n::: {.cell-output .cell-output-stdout}\n```\njulia> n = 5\njulia> x = 2.0\njulia> n + x = 7.0\n```\n:::\n:::\n\n\nbut you cannot add an integer and a string:\n\n::: {#ddb09126 .cell execution_count=4}\n``` {.julia .cell-code}\n@myshow begin #| hide\ns = \"Hello\"     # String\nn + s           # Error: does not make sense to add an Int64 and a String\nend #| hide\n```\n\n::: {.cell-output .cell-output-stdout}\n```\njulia> s = \"Hello\"\njulia> n + s\n```\n:::\n\n::: {.cell-output .cell-output-error}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre>MethodError: no method matching +(::Int64, ::String)\nThe function `+` exists, but no method is defined for this combination of argument types.\n\nClosest candidates are:\n  +(::Any, ::Any, <span class=\"ansi-bright-red-fg\">::Any</span>, <span class=\"ansi-bright-red-fg\">::Any...</span>)\n<span class=\"ansi-bright-black-fg\">   @</span> <span class=\"ansi-bright-black-fg\">Base</span> <span style=\"text-decoration:underline\" class=\"ansi-bright-black-fg\">operators.jl:596</span>\n  +(::Real, <span class=\"ansi-bright-red-fg\">::Complex{Bool}</span>)\n<span class=\"ansi-bright-black-fg\">   @</span> <span class=\"ansi-bright-black-fg\">Base</span> <span style=\"text-decoration:underline\" class=\"ansi-bright-black-fg\">complex.jl:322</span>\n  +(::Real, <span class=\"ansi-bright-red-fg\">::Complex</span>)\n<span class=\"ansi-bright-black-fg\">   @</span> <span class=\"ansi-bright-black-fg\">Base</span> <span style=\"text-decoration:underline\" class=\"ansi-bright-black-fg\">complex.jl:334</span>\n  ...\n\n\nStacktrace:\n [1] <span class=\"ansi-bold\">macro expansion</span>\n<span class=\"ansi-bright-black-fg\">   @</span> <span style=\"text-decoration:underline\" class=\"ansi-bright-black-fg\">show.jl:1232</span><span class=\"ansi-bright-black-fg\"> [inlined]</span>\n [2] <span class=\"ansi-bold\">macro expansion</span>\n<span class=\"ansi-bright-black-fg\">   @</span> <span class=\"ansi-bright-black-fg\">~/Courses/julia/course-tse-julia/assets/julia/</span><span style=\"text-decoration:underline\" class=\"ansi-bright-black-fg\">myshow.jl:82</span><span class=\"ansi-bright-black-fg\"> [inlined]</span>\n [3] top-level scope\n<span class=\"ansi-bright-black-fg\">   @</span> <span style=\"text-decoration:underline\" class=\"ansi-bright-black-fg\">In[5]:3</span></pre>\n```\n:::\n\n:::\n:::\n\n\nWe see from the error message that we can add an Integer and a Char: `+(::Integer, ::AbstractChar)` is a valid operation. This is because a Char can be treated as an integer in Julia.\n\n::: {#5d6cd98f .cell execution_count=5}\n``` {.julia .cell-code}\n@myshow begin #| hide\nc = 'a'      # Char\nc + 128448   # This will work because Char can be treated as an integer\nend #| hide\n```\n\n::: {.cell-output .cell-output-stdout}\n```\njulia> c = 'a'\njulia> c + 128448 = 'ðŸ˜¡'\n```\n:::\n:::\n\n\nJulia allows flexibility compared to statically typed languages like C or Java, but still ensures that operations make sense for the types involved.\n\n### Type System and Performance\nThe type system in Julia plays a key role in performance. By inferring or specifying types, Julia's JIT compiler can optimize code for specific data types, leading to faster execution. For example, when types are known at compile time, Julia can generate machine code tailored for the specific types involved.\n\nJuliaâ€™s type system also supports abstract types, allowing for more flexible and generic code, as well as parametric types that let you define functions or types that work with any data type.\n\n### Summary\n- Julia is dynamically typed but enforces strong typing.\n- Types are inferred from the values assigned to variables.\n- Julia optimizes performance based on types, making type information crucial.\n\n## Basic Types\n\nJulia has several basic (or primitive) types that are fundamental to working with the language. These include numerical types, characters, and strings. Understanding these types is crucial as they form the building blocks for more complex data structures.\n\n### Common Basic Types\n\n- **`Int`**: Represents integer values. Julia has multiple types of integers, such as `Int8`, `Int16`, `Int32`, and `Int64` depending on the desired size. By default, `Int` refers to the most appropriate integer type for the system (usually `Int64` on modern systems).\n  \n- **`Float64`**: Represents floating-point numbers with double precision.\n  \n- **`String`**: Represents sequences of characters.\n\n- **`Bool`**: Represents Boolean values, i.e., `true` or `false`.\n\n- **`Char`**: Represents individual Unicode characters.\n\n### Example Usage of Basic Types\n\n::: {#8c9f8e83 .cell execution_count=6}\n``` {.julia .cell-code}\n# Integer type (default is Int64)\na = 42         # a is of type Int64\n\n# Float type (default is Float64)\nb = 3.14       # b is of type Float64\n\n# String type\nc = \"Hello\"    # c is of type String\n\n# Boolean type\nd = true       # d is of type Bool\n\n# Char type\ne = 'Î±'        # e is of type Char\nnothing #| hide\n```\n:::\n\n\nThese basic types are often used for simple calculations and conditionals. Julia allows operations between different types, but it will raise an error if the types are incompatible.\n\n## Collections and Data Structures\n\n### Julia as an Array Programming Language\n\nJulia is designed as an [array programming language](https://en.wikipedia.org/wiki/Array_programming), focusing on operations that apply to entire arrays or subarrays rather than individual elements. This paradigm simplifies code for numerical, scientific, and data-intensive applications. By leveraging features like broadcasting and vectorized operations, Julia allows for efficient and concise code, enhancing performance without sacrificing readability. Array programming is central to Juliaâ€™s capabilities, enabling fast computation on large datasets and making it ideal for high-performance scientific computing.\n\n### Arrays, Vectors, and Matrices\n\nIn Julia, [arrays](https://docs.julialang.org/en/v1/manual/arrays/) are fundamental data structures that can hold elements of any type. Arrays can be one-dimensional (vectors) or two-dimensional (matrices), and they can hold data of various types.\n\n- **Creating an Array**:\n\n::: {#1555fdd5 .cell execution_count=7}\n``` {.julia .cell-code}\narr = [1, 2, 3, 4]  # A simple 1D array (vector)\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4\n```\n:::\n:::\n\n\n::: {#674e203d .cell execution_count=8}\n``` {.julia .cell-code}\nmatrix = [1 2 3; 4 5 6]  # A 2D array (matrix)\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\n2Ã—3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n```\n:::\n:::\n\n\n- **Accessing Array Elements**:\n\n::: {#46360904 .cell execution_count=9}\n``` {.julia .cell-code}\narr[1]   # Access the first element of the array\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\n1\n```\n:::\n:::\n\n\n::: {#2afcc1f8 .cell execution_count=10}\n``` {.julia .cell-code}\nmatrix[2, 3]  # Access the element in the second row, third column\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\n6\n```\n:::\n:::\n\n\n#### Slicing of Vectors and Matrices\n\nYou can extract slices (sub-arrays) of vectors and matrices in Julia. The slicing syntax allows you to access specific portions of an array.\n\n- **Slicing a vector**:\n\n::: {#e2fc452c .cell execution_count=11}\n``` {.julia .cell-code}\narr[2:4]  # Extracts elements from index 2 to 4: [2, 3, 4]\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\n3-element Vector{Int64}:\n 2\n 3\n 4\n```\n:::\n:::\n\n\n- **Slicing a matrix**:\n\n::: {#7f02a2d4 .cell execution_count=12}\n``` {.julia .cell-code}\nmatrix[1, :]   # Extracts the first row: [1, 2, 3]\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\n3-element Vector{Int64}:\n 1\n 2\n 3\n```\n:::\n:::\n\n\n::: {#b4ac169e .cell execution_count=13}\n``` {.julia .cell-code}\nmatrix[:, 2]   # Extracts the second column: [2, 5]\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\n2-element Vector{Int64}:\n 2\n 5\n```\n:::\n:::\n\n\n#### Mutation of Arrays\n\nArrays in Julia are mutable, meaning their elements can be changed after creation. The `.=` operator is commonly used to apply element-wise operations.\n\n- **Modify an individual element**:\n\n::: {#bf31ecb3 .cell execution_count=14}\n``` {.julia .cell-code}\narr[2] = 99  # Change the second element to 99\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\n99\n```\n:::\n:::\n\n\n- **Element-wise operation with `.=`**:\n\n::: {#718afb0c .cell execution_count=15}\n``` {.julia .cell-code}\narr .+= 10  # Adds 10 to each element of the array, resulting in [11, 12, 13, 14]\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\n4-element Vector{Int64}:\n  11\n 109\n  13\n  14\n```\n:::\n:::\n\n\n::: {#d4e012da .cell execution_count=16}\n``` {.julia .cell-code}\nmatrix .*= 2  # Multiplies each element of the matrix by 2, resulting in [2 4 6; 8 10 12]\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\n2Ã—3 Matrix{Int64}:\n 2   4   6\n 8  10  12\n```\n:::\n:::\n\n\n- **Push an element into an array** (mutates the array by adding a new element):\n\n::: {#5f16dc73 .cell execution_count=17}\n``` {.julia .cell-code}\npush!(arr, 40)  # Adds 40 to the end of the array\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\n5-element Vector{Int64}:\n  11\n 109\n  13\n  14\n  40\n```\n:::\n:::\n\n\n- **Pop an element from an array** (removes the last element):\n\n::: {#5cbb8137 .cell execution_count=18}\n``` {.julia .cell-code}\npop!(arr)  # Removes the last element, which is 40 in this case\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```\n40\n```\n:::\n:::\n\n\n#### Mutation Inside a Function\n\nWhen working with arrays inside a function, it's important to note that reassigning the entire array (e.g., `v = [1, 2]`) does not mutate the original array but rather creates a new one locally scoped to the function. To modify the contents of an array in place, use either `v[:] = ...` or the more flexible broadcasting syntax `v .= ...`.\n\n- **Incorrect way** (does not mutate the original vector):\n\n::: {#82f1e0f7 .cell execution_count=19}\n``` {.julia .cell-code}\nfunction incorrect_mutate(v)\n    v = [1, 2]  # This creates a new array and does not affect the input\nend\n\nvec = [10, 20]\nincorrect_mutate(vec)\nprintln(vec)  # Outputs: [10, 20]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[10, 20]\n```\n:::\n:::\n\n\n- **Correct way** using `v[:] = ...`:\n\n::: {#f21dab06 .cell execution_count=20}\n``` {.julia .cell-code}\nfunction correct_mutate(v)\n    v[:] = [1, 2]  # Mutates the input vector\nend\n\nvec = [10, 20]\ncorrect_mutate(vec)\nprintln(vec)  # Outputs: [1, 2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 2]\n```\n:::\n:::\n\n\n- **Using broadcasting (`v .= ...`)**:\n\n::: {#986d8e38 .cell execution_count=21}\n``` {.julia .cell-code}\nfunction flexible_mutate(v)\n    v .= [1, 2]  # More flexible, works for both vectors and matrices\nend\n\nvec = [10, 20]\nflexible_mutate(vec)\nprintln(vec)  # Outputs: [1, 2]\n\nmat = [10 20; 30 40]\nmat .= [1 2; 3 4]  # Updates all elements in-place\nprintln(mat)  # Outputs: [1 2; 3 4]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 2]\n[1 2; 3 4]\n```\n:::\n:::\n\n\nUsing `v .= ...` is preferred for its flexibility, as it works seamlessly for arrays of any shape, including matrices. Without broadcasting, you would need to use `M[:, :] = ...` for matrices to achieve the same effect.\n\n::: {.callout-warning}\nTo mutate an array within a function, it should be given *by reference*. In pratice, the memory address of the array is passed to the function. Any modifications to the data will thus affect the original array.\n\nLet us focus on the special case where we want to mutate a slice of the array. We can try the following lines of code.\n\n::: {#d8e2d899 .cell execution_count=22}\n``` {.julia .cell-code}\nfunction mutate_slice(v)\n    @assert(length(v) >= 2)\n    v[1] = -5\n    v[2] = -6\nend\n\nv = [1,2,3,4]\n\nmutate_slice(v[1:2])\n\nv\n```\n\n::: {.cell-output .cell-output-display execution_count=23}\n```\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4\n```\n:::\n:::\n\n\nThe first two elements of the array `v` have not been modified. This is because slices are passed *by copy* in Julia. This means that a duplicate of the slice is created. The function will act on the copy rather than the original data.\n\nIn order to overcome this issue, let us have a look at the `view` function in Julia. It creates a **view** of an array, meaning it gives you a reference to a subset of the array rather than a copy. So when you modify the view, you're modifying the original array. This is an example of by reference behavior.\n\n::: {#70ce8ac6 .cell execution_count=23}\n``` {.julia .cell-code}\nmutate_slice(view(v, 1:2))\n\nv\n```\n\n::: {.cell-output .cell-output-display execution_count=24}\n```\n4-element Vector{Int64}:\n -5\n -6\n  3\n  4\n```\n:::\n:::\n\n\nGreat! We have mutated a slice of `v` without producing any copies. Note that copies require extra memory, which can be limited in large scale applications.\n:::\n\n#### Special Arrays\n\nJulia has built-in functions to create arrays with predefined values:\n\n- **Create an array of zeros**:\n\n::: {#00333374 .cell execution_count=24}\n``` {.julia .cell-code}\nzeros(3)  # Creates an array of zeros with 3 elements: [0.0, 0.0, 0.0]\n```\n\n::: {.cell-output .cell-output-display execution_count=25}\n```\n3-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n```\n:::\n:::\n\n\n- **Create an array of ones**:\n\n::: {#447d311b .cell execution_count=25}\n``` {.julia .cell-code}\nones(2, 3)  # Creates a 2x3 matrix filled with ones: [1.0 1.0 1.0; 1.0 1.0 1.0]\n```\n\n::: {.cell-output .cell-output-display execution_count=26}\n```\n2Ã—3 Matrix{Float64}:\n 1.0  1.0  1.0\n 1.0  1.0  1.0\n```\n:::\n:::\n\n\n### Dictionaries (Dict)\n\nA [`Dict`](https://docs.julialang.org/en/v1/base/collections/#Dictionaries) in Julia is an associative collection that maps keys to values. This allows for efficient lookups, insertions, and deletions based on unique keys.\n\n- **Creating a Dictionary**:\n\n::: {#c0219f00 .cell execution_count=26}\n``` {.julia .cell-code}\nd = Dict(\"name\" => \"Alice\", \"age\" => 25)\n```\n\n::: {.cell-output .cell-output-display execution_count=27}\n```\nDict{String, Any} with 2 entries:\n  \"name\" => \"Alice\"\n  \"age\"  => 25\n```\n:::\n:::\n\n\nThis creates a dictionary where `\"name\"` maps to `\"Alice\"` and `\"age\"` maps to `25`.\n\n- **Accessing Values**:\n  \nYou can access values in a dictionary using their corresponding keys:\n\n::: {#4db33592 .cell execution_count=27}\n``` {.julia .cell-code}\nd[\"name\"]  # Outputs: \"Alice\"\n```\n\n::: {.cell-output .cell-output-display execution_count=28}\n```\n\"Alice\"\n```\n:::\n:::\n\n\n- **Adding and Updating Values**:\n\nTo add a new key-value pair or update an existing one, you can use the following syntax:\n\n::: {#d1605688 .cell execution_count=28}\n``` {.julia .cell-code}\nd[\"location\"] = \"Paris\"  # Adds a new key-value pair\nd[\"age\"] = 26            # Updates the value associated with the key \"age\"\ndisplay(d)\n```\n\n::: {.cell-output .cell-output-display}\n```\nDict{String, Any} with 3 entries:\n  \"name\"     => \"Alice\"\n  \"location\" => \"Paris\"\n  \"age\"      => 26\n```\n:::\n:::\n\n\n- **Removing Key-Value Pairs**:\n\nTo remove a key-value pair, use the `delete!` function:\n\n::: {#70095213 .cell execution_count=29}\n``` {.julia .cell-code}\ndelete!(d, \"location\")\n```\n\n::: {.cell-output .cell-output-display execution_count=30}\n```\nDict{String, Any} with 2 entries:\n  \"name\" => \"Alice\"\n  \"age\"  => 26\n```\n:::\n:::\n\n\n- **Iteration over Key-Value Pairs**:\n\nYou can iterate through the keys, values, or pairs in a dictionary using `keys`, `values`, and `pairs` respectively:\n\n::: {#90347374 .cell execution_count=30}\n``` {.julia .cell-code}\nfor (k, v) in pairs(d)\n    println(\"Key: $k, Value: $v\")\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nKey: name, Value: Alice\nKey: age, Value: 26\n```\n:::\n:::\n\n\n### Tuples and Named Tuples\n\nJulia [Tuples](https://docs.julialang.org/en/v1/manual/types/#Tuple-Types) are ordered collections of elements, while [Named Tuples](https://docs.julialang.org/en/v1/manual/types/#Named-Tuple-Types) are tuples where elements are associated with names (keys). Tuples are immutable, meaning their elements cannot be changed after creation.\n\n#### Basic usage of Tuples and Named Tuples\n\n- **Tuple** is an ordered collection of elements, which can hold elements of different types.\n\n::: {#da5e8327 .cell execution_count=31}\n``` {.julia .cell-code}\nt = (1, \"Julia\", true)  # A tuple with three elements\n```\n\n::: {.cell-output .cell-output-display execution_count=32}\n```\n(1, \"Julia\", true)\n```\n:::\n:::\n\n\n- **NamedTuple** is a special kind of tuple where elements are associated with names (keys).\n\n::: {#4d362ec6 .cell execution_count=32}\n``` {.julia .cell-code}\nnt = (name = \"Alice\", age = 25)  # A NamedTuple with named fields\n```\n\n::: {.cell-output .cell-output-display execution_count=33}\n```\n(name = \"Alice\", age = 25)\n```\n:::\n:::\n\n\nYou can access the elements by their name:\n\n::: {#aa671cc9 .cell execution_count=33}\n``` {.julia .cell-code}\nnt.name  # Access the field 'name' of the NamedTuple, returns \"Alice\"\n```\n\n::: {.cell-output .cell-output-display execution_count=34}\n```\n\"Alice\"\n```\n:::\n:::\n\n\n- **Mutation of a Tuple**: Tuples are immutable, so attempting to change their elements will result in an error.\n\n::: {#6db50caa .cell execution_count=34}\n``` {.julia .cell-code}\nt[1] = 99  # Trying to modify a tuple element will result in an error\n```\n\n::: {.cell-output .cell-output-error}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre>MethodError: no method matching setindex!(::Tuple{Int64, String, Bool}, ::Int64, ::Int64)\nThe function `setindex!` exists, but no method is defined for this combination of argument types.\n\nStacktrace:\n [1] top-level scope\n<span class=\"ansi-bright-black-fg\">   @</span> <span style=\"text-decoration:underline\" class=\"ansi-bright-black-fg\">In[35]:1</span></pre>\n```\n:::\n\n:::\n:::\n\n\nThe above line will raise an error because tuples are immutable in Julia, and their elements cannot be modified after creation.\n\n#### Tuples in Function\n\nIn Julia, tuples and named tuples play an important role in function definitions and return values.\n\n- **Positional and Keyword Arguments**:  \n  \nWhen defining functions with a variable number of arguments, Julia uses *tuples* to capture positional arguments and *named tuples* for keyword arguments:\n\n::: {#1531130f .cell execution_count=35}\n``` {.julia .cell-code}\nfunction example_function(args...; kwargs...)\n    println(\"Positional arguments type: \", typeof(args))\n    println(\"Keyword arguments type: \", typeof(kwargs))\n    return kwargs\nend\n\nkw = example_function(1, 2, 3; name=\"Alice\", age=30)\nnothing #| hide\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPositional arguments type: Tuple{Int64, Int64, Int64}\nKeyword arguments type: Base.Pairs{Symbol, Any, Tuple{Symbol, Symbol}, @NamedTuple{name::String, age::Int64}}\n```\n:::\n:::\n\n\nIn this example, `args` is of type `Tuple`, containing all positional arguments, while `kwargs` is based on a `NamedTuple`, containing all keyword arguments. The arguments are captured using the `args...` and `kwargs...` syntax. The `kwargs` argument is actually a 'Base.Pairs':\n\n::: {#f90026bc .cell execution_count=36}\n``` {.julia .cell-code}\nkw\n```\n\n::: {.cell-output .cell-output-display execution_count=37}\n```\npairs(::NamedTuple) with 2 entries:\n  :name => \"Alice\"\n  :age  => 30\n```\n:::\n:::\n\n\n::: {#e01fcbc8 .cell execution_count=37}\n``` {.julia .cell-code}\n@myshow begin #| hide\ntypeof(kw)\nkw isa Base.Pairs\nkw isa AbstractDict\nkeys(kw)\nvalues(kw)\npairs(kw)\nkw[:name]\nkw[:age]\nend #| hide\n```\n\n::: {.cell-output .cell-output-stdout}\n```\njulia> typeof(kw) = Base.Pairs{Symbol, Any, Tuple{Symbol, Symbol}, @NamedTuple{name::String, age::Int64}}\njulia> kw isa Base.Pairs = true\njulia> kw isa AbstractDict = true\njulia> keys(kw) = (:name, :age)\njulia> values(kw) = (name = \"Alice\", age = 30)\njulia> pairs(kw) = Base.Pairs{Symbol, Any, Tuple{Symbol, Symbol}, @NamedTuple{name::String, age::Int64}}(:name => \"Alice\", :age => 30)\njulia> kw[:name] = \"Alice\"\njulia> kw[:age] = 30\n```\n:::\n:::\n\n\nActually, the values are a `NamedTuple`:\n\n::: {#2e9a6984 .cell execution_count=38}\n``` {.julia .cell-code}\ntypeof(values(kw))\n```\n\n::: {.cell-output .cell-output-display execution_count=39}\n```\n@NamedTuple{name::String, age::Int64}\n```\n:::\n:::\n\n\nContrary to a `Dict`, you cannot add entries to a `Base.Pairs`:\n\n::: {#0edf41d2 .cell execution_count=39}\n``` {.julia .cell-code}\nkw[:height] = 5.9\n```\n\n::: {.cell-output .cell-output-error}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre>MethodError: no method matching setindex!(::@NamedTuple{name::String, age::Int64}, ::Float64, ::Symbol)\nThe function `setindex!` exists, but no method is defined for this combination of argument types.\n\nStacktrace:\n [1] <span class=\"ansi-bold\">setindex!</span><span class=\"ansi-bold\">(</span><span class=\"ansi-bright-black-fg\">v</span>::@Kwargs<span class=\"ansi-bright-black-fg\">{name::String, age::Int64}</span>, <span class=\"ansi-bright-black-fg\">value</span>::Float64, <span class=\"ansi-bright-black-fg\">key</span>::Symbol<span class=\"ansi-bold\">)</span>\n<span class=\"ansi-bright-black-fg\">   @</span> <span class=\"ansi-bright-black-fg\">Base.Iterators</span> <span class=\"ansi-bright-black-fg\">./</span><span style=\"text-decoration:underline\" class=\"ansi-bright-black-fg\">iterators.jl:325</span>\n [2] top-level scope\n<span class=\"ansi-bright-black-fg\">   @</span> <span style=\"text-decoration:underline\" class=\"ansi-bright-black-fg\">In[40]:1</span></pre>\n```\n:::\n\n:::\n:::\n\n\n- **Returning Tuples**:\n\nIn Julia, when a function returns multiple values separated by commas, they are automatically returned as a tuple:\n\n::: {#d356e6cf .cell execution_count=40}\n``` {.julia .cell-code}\nfunction return_multiple_values()\n    return 1, \"Julia\", true\nend\n\nresult = return_multiple_values()\nprintln(\"Result type: \", typeof(result))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nResult type: Tuple{Int64, String, Bool}\n```\n:::\n:::\n\n\nSo, `return_multiple_values()` returns a tuple with three elements.\n\n## Composite Types\n\n### Introduction to `struct`\n\nIn Julia, you can define your own custom data types using the `struct` keyword. [Composite types](https://docs.julialang.org/en/v1/manual/types/#Composite-Types) are user-defined types that group together different pieces of data into one object. A `struct` is a great way to create a type that can represent a complex entity with multiple fields.\n\n- **Creating a custom `struct`**:\n\n::: {#62d81d27 .cell execution_count=41}\n``` {.julia .cell-code}\n# Define a simple struct for a point in 2D space\nstruct Point\n    x::Float64\n    y::Float64\nend\n```\n:::\n\n\nHere, we created a `Point` struct with two fields: `x` and `y`, both of which are of type `Float64`.\n\n- **Creating an instance of a struct**:\n\n::: {#db912dd9 .cell execution_count=42}\n``` {.julia .cell-code}\np = Point(3.0, 4.0)  # Creates a Point with x = 3.0 and y = 4.0\n```\n\n::: {.cell-output .cell-output-display execution_count=43}\n```\nPoint(3.0, 4.0)\n```\n:::\n:::\n\n\n- **Accessing fields of a struct**:\n\n::: {#a0e3f9c2 .cell execution_count=43}\n``` {.julia .cell-code}\np.x  # Access the 'x' field of the Point instance\np.y  # Access the 'y' field of the Point instance\n```\n\n::: {.cell-output .cell-output-display execution_count=44}\n```\n4.0\n```\n:::\n:::\n\n\nYou can access the fields of a struct directly using dot notation, as shown above.\n\n- **Get the names of the fields**:\n\n::: {#c2774df9 .cell execution_count=44}\n``` {.julia .cell-code}\nfieldnames(Point)  # Returns the names of the fields in the Point struct\n```\n\n::: {.cell-output .cell-output-display execution_count=45}\n```\n(:x, :y)\n```\n:::\n:::\n\n\n### Mutability of `struct`\n\nIn Julia, structs are **immutable** by default, meaning once you create an instance of a struct, its fields cannot be changed. However, you can create **mutable structs** by using the `mutable struct` keyword, which allows modification of field values after creation.\n\n- **Creating a mutable struct**:\n\n::: {#fb93c553 .cell execution_count=45}\n``` {.julia .cell-code}\nmutable struct MutablePoint\n    x::Float64\n    y::Float64\nend\n```\n:::\n\n\nNow you can modify the fields of `MutablePoint` instances after they are created.\n\n::: {#414e80ef .cell execution_count=46}\n``` {.julia .cell-code}\nmp = MutablePoint(1.0, 2.0)\nmp.x = 3.0  # Modify the 'x' field\nnothing #| hide\n```\n:::\n\n\n### Example: `struct` for a Circle\n\nWe can create a more complex type, such as a `Circle`, which has a center represented by a `Point` and a radius:\n\n::: {#1fad4bf3 .cell execution_count=47}\n``` {.julia .cell-code}\nstruct Circle\n    center::Point\n    radius::Float64\nend\n```\n:::\n\n\n- **Creating an instance of `Circle`**:\n\n::: {#df654464 .cell execution_count=48}\n``` {.julia .cell-code}\nc = Circle(Point(0.0, 0.0), 5.0)  # Create a circle with center (0, 0) and radius 5\n```\n\n::: {.cell-output .cell-output-display execution_count=49}\n```\nCircle(Point(0.0, 0.0), 5.0)\n```\n:::\n:::\n\n\n- **Accessing fields of a nested struct**:\n\n::: {#62d6c4b5 .cell execution_count=49}\n``` {.julia .cell-code}\nc.center.x  # Access the x field of the center of the circle\nc.center.y  # Access the y field of the center of the circle\nc.radius    # Access the radius of the circle\nnothing #| hide\n```\n:::\n\n\n### Constructor methods\n\nLet us look at an example. A `Duck` is an object that can be described as follows:\n\n- state: a name (`name::String`) and number of feathers (`nb::Int32`);\n- location: a position on a 2-D grid (`pt::Point`).\n\nIn order to create a `Duck`, it is necessary to define the object (as seen previously with `Point`).\n\n::: {#dbf617d7 .cell execution_count=50}\n``` {.julia .cell-code}\nstruct Duck\n    name::String\n    nb::Int64\n    pt::Point\nend\nnothing #| hide\n```\n:::\n\n\nIn order to create a `Duck` with the name \"Donald\", we simply use the *default* constructor generated by the Julia language.\n\n::: {#e241db34 .cell execution_count=51}\n``` {.julia .cell-code}\ndonald = Duck(\"Donald\", 10000, Point(0.,0.))\n```\n\n::: {.cell-output .cell-output-display execution_count=52}\n```\nDuck(\"Donald\", 10000, Point(0.0, 0.0))\n```\n:::\n:::\n\n\nAs any function in Julia, a constructor function can be associated with several constructor methods. The object `Duck` has been defined. Still, it is possible to add so called *outer* constructor methods. For example, we can provide a method that takes two `Float64` instead of an instance of the `Point` object. \n\n::: {#46d5a2a6 .cell execution_count=52}\n``` {.julia .cell-code}\nDuck(name::String, nb::Int64, x::Float64, y::Float64) = Duck(name, nb, Point(x,y));\nnothing #| hide\n```\n:::\n\n\nWe can now create another `Duck` without using the `Point` object.\n\n::: {#62f7b093 .cell execution_count=53}\n``` {.julia .cell-code}\nscrooge = Duck(\"Scrooge\", 5000, 0., 1.)\n```\n\n::: {.cell-output .cell-output-display execution_count=54}\n```\nDuck(\"Scrooge\", 5000, Point(0.0, 1.0))\n```\n:::\n:::\n\n\nOh! But Scrooge is a cheapskate. Let us look into *inner* constructor methods in order to avoid any `Duck` from being called \"Scrooge\". An *inner* constructor can only be defined within the definition of the object. Let us rewrite the `Duck` object in order to replace the *default* constructor method by our own constructor method.\n\n::: {#4bd78073 .cell execution_count=54}\n``` {.julia .cell-code}\nstruct Duck\n    name::String\n    nb::Int64\n    pt::Point\n\n    function Duck(name::String, nb::Int64, pt::Point)\n        if name == \"Scrooge\"\n            error(\"A Duck can not be a cheapskate!!\")\n        end\n        new(name, nb, pt)\n    end\nend\nnothing #| hide\n```\n:::\n\n\nLet us try to create a `Duck` called \"Scrooge\" now.\n\n::: {#ddb62db8 .cell execution_count=55}\n``` {.julia .cell-code}\nscrooge = Duck(\"Scrooge\", 5000, 0., 1.)\n```\n\n::: {.cell-output .cell-output-error}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre>A Duck can not be a cheapskate!!\n\nStacktrace:\n [1] <span class=\"ansi-bold\">error</span><span class=\"ansi-bold\">(</span><span class=\"ansi-bright-black-fg\">s</span>::String<span class=\"ansi-bold\">)</span>\n<span class=\"ansi-bright-black-fg\">   @</span> <span class=\"ansi-bright-black-fg\">Base</span> <span class=\"ansi-bright-black-fg\">./</span><span style=\"text-decoration:underline\" class=\"ansi-bright-black-fg\">error.jl:35</span>\n [2] <span class=\"ansi-bold\">Duck</span>\n<span class=\"ansi-bright-black-fg\">   @</span> <span class=\"ansi-bright-black-fg\">./</span><span style=\"text-decoration:underline\" class=\"ansi-bright-black-fg\">In[55]:8</span><span class=\"ansi-bright-black-fg\"> [inlined]</span>\n [3] <span class=\"ansi-bold\">Duck</span><span class=\"ansi-bold\">(</span><span class=\"ansi-bright-black-fg\">name</span>::String, <span class=\"ansi-bright-black-fg\">nb</span>::Int64, <span class=\"ansi-bright-black-fg\">x</span>::Float64, <span class=\"ansi-bright-black-fg\">y</span>::Float64<span class=\"ansi-bold\">)</span>\n<span class=\"ansi-bright-black-fg\">   @</span> <span class=\"ansi-cyan-fg\">Main</span> <span class=\"ansi-bright-black-fg\">./</span><span style=\"text-decoration:underline\" class=\"ansi-bright-black-fg\">In[53]:1</span>\n [4] top-level scope\n<span class=\"ansi-bright-black-fg\">   @</span> <span style=\"text-decoration:underline\" class=\"ansi-bright-black-fg\">In[56]:1</span></pre>\n```\n:::\n\n:::\n:::\n\n\nGreat an error was thrown!\n\n### Function-like Object (Callable `struct`)\n\nIn Julia, you can make a `struct` \"callable\" by defining the `call` method for it. This allows instances of the `struct` to be used like functions. This feature is useful for encapsulating parameters or states in a type while still allowing it to behave like a function.\n\nHereâ€™s an example that demonstrates a callable struct for a **linear transformation**:\n\n::: {#462ac966 .cell execution_count=56}\n``` {.julia .cell-code}\n# Define a callable struct for a linear transformation\nstruct LinearTransform\n    a::Float64  # Slope\n    b::Float64  # Intercept\nend\n\n# Define the call method for LinearTransform\nfunction (lt::LinearTransform)(x::Real)\n    lt.a * x + lt.b  # Apply the linear transformation\nend\n```\n:::\n\n\n- **Explanation**:\n  - The `LinearTransform` struct stores the parameters of the linear function \\( y = ax + b \\).\n  - By defining the `call` method for the struct, you enable instances of `LinearTransform` to behave like a function.\n\n- **Usage**:\n\n::: {#2d49cbd4 .cell execution_count=57}\n``` {.julia .cell-code}\n# Create an instance of LinearTransform\nlt = LinearTransform(2.0, 3.0)  # y = 2x + 3\n\n@myshow begin #| hide\n# Call the instance like a function\ntypeof(lt)  # Output: LinearTransform\ny1 = lt(5)   # Calculates 2 * 5 + 3 = 13\ny2 = lt(-1)  # Calculates 2 * -1 + 3 = 1\nend #| hide\n```\n\n::: {.cell-output .cell-output-stdout}\n```\njulia> typeof(lt) = LinearTransform\njulia> y1 = 13.0\njulia> y2 = 1.0\n```\n:::\n:::\n\n\n### Extending the Concept: Composable Linear Transforms\n\nYou can take this idea further by allowing composition of transformations. For example:\n\n::: {#fa38b776 .cell execution_count=58}\n``` {.julia .cell-code}\n# Define a method to compose two LinearTransform objects\nfunction (lt1::LinearTransform)(lt2::LinearTransform)\n    LinearTransform(lt1.a * lt2.a, lt1.a * lt2.b + lt1.b)\nend\n\n# Example usage\nlt1 = LinearTransform(2.0, 3.0)  # y = 2x + 3\nlt2 = LinearTransform(0.5, 1.0)  # y = 0.5x + 1\n\n# Compose the two transformations\nlt_composed = lt1(lt2)  # Equivalent to y = 2 * (0.5x + 1) + 3\n\n@myshow begin #| hide\n# Call the composed transformation\ny = lt_composed(4)  # Calculates 2 * (0.5 * 4 + 1) + 3 = 9\nend #| hide\n```\n\n::: {.cell-output .cell-output-stdout}\n```\njulia> y = 9.0\n```\n:::\n:::\n\n\n::: {.callout-note}\nThe previous composition is equivalent in pure Julia to:\n\n::: {#5dccca42 .cell execution_count=59}\n``` {.julia .cell-code}\ny = (lt1 âˆ˜ lt2)(4)\n```\n\n::: {.cell-output .cell-output-display execution_count=60}\n```\n9.0\n```\n:::\n:::\n\n\n:::\n\n### Conclusion\n\n- In Julia, `struct` allows you to create complex custom types that can hold different types of data. Custom constructors provide flexibility for struct initialization, allowing validation and preprocessing of input data. This is especially useful for enforcing constraints and ensuring type consistency. By default, structs are immutable, but you can use `mutable struct` if you need to change the data after creation.\n- Using a callable struct allows you to represent parameterized functions or transformations in a concise and reusable way. The concept can be extended further to support operations like composition or chaining, making it a powerful tool for [functional-style programming](https://en.wikipedia.org/wiki/Functional_programming) in Julia.\n\n## Exercises\n\n### Exercise 1: Creating a Shape System\n\nCreate a system to represent different geometric shapes (like a **Rectangle**, **Circle**, and **Point**) using the following requirements:\n\n1. **Define a `Point` struct** with `x` and `y` coordinates of type `Float64`.\n2. **Define a `Rectangle` struct** with fields `length` and `width` of type `Float64`. Use the `Point` struct to represent the bottom-left corner of the rectangle.\n3. **Define a `Circle` struct** with a `Point` for the center and a `radius` of type `Float64`.\n4. Write a **function `area(shape)`** that computes the area of the given shape:\n   - The area of a rectangle is `length * width`.\n   - The area of a circle is `Ï€ * radius^2`.\n\n::: {.callout-tip collapse=\"true\" icon=false}\n## Hint for Exercise 1:\n- Use **struct** to define `Point`, `Rectangle`, and `Circle`.\n- Use **dot notation** to access the fields of the structs.\n- Use **conditional logic** (e.g., `typeof()`) to handle different shapes in the `area` function.\n- For the circle, use `Ï€ = 3.141592653589793`.\n:::\n\n::: {.callout-caution collapse=\"true\" icon=false}\n## Correction of Exercise 1:\n\n::: {#a2f979ca .cell execution_count=60}\n``` {.julia .cell-code}\n# Define the Point struct\nstruct Point\n    x::Float64\n    y::Float64\nend\n\n# Define the Rectangle struct\nstruct Rectangle\n    bottom_left::Point\n    length::Float64\n    width::Float64\nend\n\n# Define the Circle struct\nstruct Circle\n    center::Point\n    radius::Float64\nend\n\n# Function to calculate the area\nfunction area(shape)\n    if typeof(shape) == Rectangle\n        return shape.length * shape.width\n    elseif typeof(shape) == Circle\n        return Ï€ * shape.radius^2\n    else\n        throw(ArgumentError(\"Unsupported shape\"))\n    end\nend\n\n# Example usage\np1 = Point(0.0, 0.0)\nr1 = Rectangle(p1, 3.0, 4.0)\nc1 = Circle(p1, 5.0)\n\nprintln(\"Area of rectangle: \", area(r1))  # Should print 12.0\nprintln(\"Area of circle: \", area(c1))     # Should print 78.53981633974483\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nArea of rectangle: 12.0\nArea of circle: 78.53981633974483\n```\n:::\n:::\n\n\n:::\n\n### Exercise 2: Working with Complex Numbers and Arrays\n\n1. Create two **complex numbers** `z1` and `z2` of type `Complex{Float64}`.\n2. Write a function `add_complex(z1, z2)` that adds two complex numbers and returns the result.\n3. Create an **array** of complex numbers and use the `map` function to add 2.0 to the real part of each complex number.\n4. Create a function `max_real_part` that returns the complex number with the largest real part from an array of complex numbers.\n\n::: {.callout-tip collapse=\"true\" icon=false}\n## Hint for Exercise 2:\n- Use the `Complex{T}` type to create complex numbers. \n- You can access the real and imaginary parts of a complex number with `real(z)` and `imag(z)`.\n- Use the `map` function to apply a transformation to each element of an array.\n- Compare the real parts of the complex numbers using `real(z)` to find the maximum.\n:::\n\n::: {.callout-caution collapse=\"true\" icon=false}\n## Correction of Exercise 2:\n\n::: {#538c69d7 .cell execution_count=61}\n``` {.julia .cell-code}\n# Create two complex numbers\nz1 = Complex{Float64}(3.0, 4.0)  # z1 = 3.0 + 4.0im\nz2 = Complex{Float64}(1.0, 2.0)  # z2 = 1.0 + 2.0im\n\n# Function to add two complex numbers\nfunction add_complex(z1, z2)\n    return z1 + z2\nend\n\n# Add 2.0 to the real part of each complex number in an array\narr = [Complex{Float64}(3.0, 4.0), Complex{Float64}(1.0, 2.0), Complex{Float64}(5.0, 6.0)]\nnew_arr = map(z -> Complex(real(z) + 2.0, imag(z)), arr)\n\nprintln(\"New array with modified real parts: \", new_arr)\n\n# Function to find the complex number with the largest real part\nfunction max_real_part(arr)\n    max_z = arr[1]\n    for z in arr\n        if real(z) > real(max_z)\n            max_z = z\n        end\n    end\n    return max_z\nend\n\n# Find the complex number with the largest real part\nmax_z = max_real_part(arr)\nprintln(\"Complex number with the largest real part: \", max_z)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNew array with modified real parts: ComplexF64[5.0 + 4.0im, 3.0 + 2.0im, 7.0 + 6.0im]\nComplex number with the largest real part: 5.0 + 6.0im\n```\n:::\n:::\n\n\n:::\n\n### Exercise 3: Manipulating Tuples\n\n1. Create a **tuple** `t` with three elements: a string, an integer, and a float.\n2. Try to mutate the first element of the tuple and handle any errors using a `try-catch` block.\n3. Create a **NamedTuple** `nt` with fields `name`, `age`, and `height`, and initialize it with your details.\n\n::: {.callout-tip collapse=\"true\" icon=false}\n## Hint for Exercise 3:\n- Remember that tuples are immutable, so you can't modify their elements.\n- Use a `try-catch` block to catch errors if an operation fails.\n:::\n\n::: {.callout-caution collapse=\"true\" icon=false}\n## Correction of Exercise 3:\n\n::: {#f73bb566 .cell execution_count=62}\n``` {.julia .cell-code}\n# Create a tuple with three elements: a string, an integer, and a float\nt = (\"John\", 25, 5.9)\n\n# Attempt to mutate the first element of the tuple with error handling\ntry\n    t[1] = \"Alice\"  # This will raise an error because tuples are immutable\ncatch e\n    println(\"Error: \", e)\nend\n\n# Create a NamedTuple with fields: name, age, and height\nnt = (name = \"John\", age = 25, height = 5.9)\n\nprintln(\"NamedTuple: \", nt)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nError: MethodError(setindex!, ((\"John\", 25, 5.9), \"Alice\", 1), 0x00000000000068f5)\nNamedTuple: (name = \"John\", age = 25, height = 5.9)\n```\n:::\n:::\n\n\n:::\n\n",
    "supporting": [
      "basic-types_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}