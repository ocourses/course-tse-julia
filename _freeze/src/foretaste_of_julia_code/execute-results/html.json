{
  "hash": "9361c5d441cb0574db6df342e819c0d4",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Foretaste of Julia Code\"\npage-layout: article\njupyter: julia-1.11\n---\n\n\n\nJulia is a high-level, high-performance programming language primarily designed for numerical and scientific computing. Its syntax is familiar to users of other technical computing environments, while its flexibility and performance make it an excellent choice for a wide range of applications. In this section, we will look at a few simple examples to illustrate some core features of Julia and demonstrate its intuitive and powerful design.\n\n## Variables\n\n### Simple Assignment\n\nIn Julia, you can assign values to variables directly:\n\n::: {#58d260ac .cell execution_count=2}\n``` {.julia .cell-code}\nx = 1   # Assign an integer to x\n2x      # The result of 2 * x\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n2\n```\n:::\n:::\n\n\n### Mathematical Operations\n\nYou can also perform mathematical operations directly on variables:\n\n::: {#45d684ee .cell execution_count=3}\n``` {.julia .cell-code}\nx = sqrt(2)    # Assign the square root of 2 to x\nx              # Output the value of x\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n1.4142135623730951\n```\n:::\n:::\n\n\n### Using Unicode\n\nJulia allows you to use Unicode characters in your code, which makes it more expressive:\n\n::: {#ce0ebd79 .cell execution_count=4}\n``` {.julia .cell-code}\n# Unicode is great\nx = âˆš(2)        # Square root symbol for 2\nx               # The value of x is the square root of 2\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n1.4142135623730951\n```\n:::\n:::\n\n\n### Custom Variable Names\n\nJulia even allows using emojis for variable names:\n\n::: {#123a84bf .cell execution_count=5}\n``` {.julia .cell-code}\nðŸ˜„ = sqrt(2)    # Assign the square root of 2 to the emoji variable\n2ðŸ˜„              # Result of 2 times ðŸ˜„\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n2.8284271247461903\n```\n:::\n:::\n\n\n::: {.callout-note}\nVisit the list of [Unicode Input](https://docs.julialang.org/en/v1/manual/unicode-input/) for more examples.\n:::\n\n## Functions\n\n### Simple Function Definition\n\nIn Julia, you can define a function using the `function` keyword:\n\n::: {#f7b92939 .cell execution_count=6}\n``` {.julia .cell-code}\n# this is a function\nfunction f(x)\n  return 2x + 1   # Return a value that is double x plus 1\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\nf (generic function with 1 method)\n```\n:::\n:::\n\n\nTo evaluate a function, simply call it with an argument:\n\n::: {#4c72563b .cell execution_count=7}\n``` {.julia .cell-code}\nf(2)  # Output: 5\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n5\n```\n:::\n:::\n\n\n### Function Definition in Assignment Form\n\nJulia also supports defintion of functions in assignement form, which are often used for short operations:\n\n::: {#bb3a2513 .cell execution_count=8}\n``` {.julia .cell-code}\n# This is also a function\ng(x) = 2x + 1   # A shorthand for defining a function\ng(2)            # Output: 5\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\n5\n```\n:::\n:::\n\n\n### Anonymous Functions\n\nJulia also supports anonymous functions (functions without a name):\n\n::: {#60915f7b .cell execution_count=9}\n``` {.julia .cell-code}\n# Another example with anonymous function\nh = x -> 2x^2    # Function definition using the arrow syntax\nh(1)             # Output: 2, since 2 * 1^2 = 2\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\n2\n```\n:::\n:::\n\n\n### Function Priority and Operator Precedence\n\nIn some cases, you need to be cautious about operator precedence:\n\n::: {#247f4c3c .cell execution_count=10}\n``` {.julia .cell-code}\n# Be careful of operator priorities\nh(1 + 1)  # The correct evaluation is 2 * (1+1)^2 = 8\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\n8\n```\n:::\n:::\n\n\n## Side Effects\n\nIn Julia, functions can have **side effects**, meaning they modify variables or objects outside the scope of the function. Hereâ€™s an example:\n\n### Mutating Vectors\n\nLet's consider the following vector:\n\n::: {#622e6341 .cell execution_count=11}\n``` {.julia .cell-code}\nx = [1, 3, 12]\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\n3-element Vector{Int64}:\n  1\n  3\n 12\n```\n:::\n:::\n\n\nYou can access an element of the vector like this:\n\n::: {#08305587 .cell execution_count=12}\n``` {.julia .cell-code}\nx[2]  # Output: 3, the second element of the array\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\n3\n```\n:::\n:::\n\n\nTo update an element, simply reassign it:\n\n::: {#5d13f550 .cell execution_count=13}\n``` {.julia .cell-code}\nx[2] = 5  # Changes the second element to 5\nx         # Now x = [1, 5, 12]\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\n3-element Vector{Int64}:\n  1\n  5\n 12\n```\n:::\n:::\n\n\n### Side Effects in Functions\n\nIf you mutate data inside a function, it will have side effects. For example, consider this function:\n\n::: {#9fd4e10b .cell execution_count=14}\n``` {.julia .cell-code}\nfunction f(x, y)\n    x[1] = 42        # Mutates x\n    y = 7 + sum(x)   # New binding for y, no mutation\n    return y\nend\n\na = [4, 5, 6]\nb = 3\n\nprintln(\"f($a, $b) = \", f(a, b))  # f modifies 'a' but not 'b'\nprintln(\"a = \", a, \" # a[1] is changed to 42 by f\")\nprintln(\"b = \", b, \" # b remains unchanged\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nf([4, 5, 6], 3) = 60\na = [42, 5, 6] # a[1] is changed to 42 by f\nb = 3 # b remains unchanged\n```\n:::\n:::\n\n\n### The Bang Convention\n\nWhen a function has side effects, it's a good practice to use the `!` symbol at the end of the function's name. This is called the **bang convention**, and it signals that the function mutates its arguments:\n\n::: {#486dfe1e .cell execution_count=15}\n``` {.julia .cell-code}\nfunction put_at_second_place!(x, value)\n  x[2] = value\n  return nothing  # No explicit return, it's just a side effect\nend\n\nx = [1, 3, 12]\nprintln(\"x[2] before: \", x[2])\n\nput_at_second_place!(x, 5)  # Mutates x\nprintln(\"x[2] after: \", x[2])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nx[2] before: 3\nx[2] after: 5\n```\n:::\n:::\n\n\n### Caution with Slices\n\nWhen you pass a slice of an array to a function in Julia, the slice is actually a copy, so modifying it does **not** alter the original array:\n\n::: {#c7d06b8f .cell execution_count=16}\n``` {.julia .cell-code}\nx = [1, 2, 3, 4]\nprintln(\"x[2] before slice modification: \", x[2])\n\nput_at_second_place!(x[1:3], 15)  # Safe to modify the slice\n\nprintln(\"x[2] after slice modification: \", x[2])  # Original array remains unchanged\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nx[2] before slice modification: 2\nx[2] after slice modification: 2\n```\n:::\n:::\n\n\n::: {.callout-tip} \nWhen working with slices, remember that they are copies in Julia. Modifying a slice will not impact the original array, which helps prevent unintentional changes to your data. \n:::\n\n## Methods\n\nJulia supports multiple methods for the same function name, which allows for more flexible and dynamic behavior. Here's an example:\n\n### Method Overloading\n\nYou can define several methods for the same function with different types:\n\n::: {#d69d461b .cell execution_count=17}\n``` {.julia .cell-code}\nÎ£(x::Float64, y::Float64) = 2x + y   # Method for Float64 inputs\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\nÎ£ (generic function with 1 method)\n```\n:::\n:::\n\n\nCalling the function:\n\n::: {#2ce1f54e .cell execution_count=18}\n``` {.julia .cell-code}\nÎ£(2.0, 3.0)  # Output: 7.0\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```\n7.0\n```\n:::\n:::\n\n\nIf you call `Î£` with arguments that don't match the types, Julia will throw an error:\n\n::: {#eb4f1160 .cell execution_count=19}\n``` {.julia .cell-code}\nÎ£(2, 3.0)  # Error: no method matching Î£(::Int64, ::Float64)\n```\n\n::: {.cell-output .cell-output-error}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre>MethodError: no method matching Î£(::Int64, ::Float64)\nThe function `Î£` exists, but no method is defined for this combination of argument types.\n\nClosest candidates are:\n  Î£(<span class=\"ansi-bright-red-fg\">::Float64</span>, ::Float64)\n<span class=\"ansi-bright-black-fg\">   @</span> <span class=\"ansi-magenta-fg\">Main</span> <span style=\"text-decoration:underline\" class=\"ansi-bright-black-fg\">In[18]:1</span>\n\n\nStacktrace:\n [1] top-level scope\n<span class=\"ansi-bright-black-fg\">   @</span> <span style=\"text-decoration:underline\" class=\"ansi-bright-black-fg\">In[20]:1</span></pre>\n```\n:::\n\n:::\n:::\n\n\n### Multiple Methods for Different Types\n\nYou can define more methods that work with different types:\n\n::: {#e0e2faf9 .cell execution_count=20}\n``` {.julia .cell-code}\nÏ†(x::Number, y::Number) = 2x - y           # General method for numbers\nÏ†(x::Int, y::Int)     = 2x * y             # Method for integers\nÏ†(x::Float64, y::Float64) = 2x + y         # Method for Float64\n```\n\n::: {.cell-output .cell-output-display execution_count=21}\n```\nÏ† (generic function with 3 methods)\n```\n:::\n:::\n\n\n### Method Dispatch Example\n\nJulia will select the appropriate method based on the argument types:\n\n::: {#9ad73849 .cell execution_count=21}\n``` {.julia .cell-code}\nprintln(\"Ï†(2,   3.0) = \", Ï†(2, 3.0))       # Uses general method\nprintln(\"Ï†(2,   3)   = \", Ï†(2, 3))         # Uses the integer method\nprintln(\"Ï†(2.0, 3.0) = \", Ï†(2.0, 3.0))     # Uses the Float64 method\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nÏ†(2,   3.0) = 1.0\nÏ†(2,   3)   = 12\nÏ†(2.0, 3.0) = 7.0\n```\n:::\n:::\n\n\n## Iterators\n\nIn Julia, iterators allow you to loop through collections in a memory-efficient way. Hereâ€™s an example of using `1:5` as an iterator:\n\n::: {#8088589d .cell execution_count=22}\n``` {.julia .cell-code}\nfor i in 1:5\n    println(i)\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1\n2\n3\n4\n5\n```\n:::\n:::\n\n\nThis prints the numbers from 1 to 5. You can also iterate through ranges and collections:\n\n::: {#0d8a41aa .cell execution_count=23}\n``` {.julia .cell-code}\nfor i in [10, 20, 30]\n    println(i)\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n10\n20\n30\n```\n:::\n:::\n\n\n### Working with Lazy Collections\n\nJuliaâ€™s `Iterators` package allows for lazy collections, where values are computed on demand. Hereâ€™s an example:\n\n::: {#f8c4a3bf .cell execution_count=24}\n``` {.julia .cell-code}\nusing Base.Iterators: cycle\nround = 1\nfor i in cycle([1, 2, 3])\n    println(i)\n    if i == 3\n      if round == 2\n        break\n      else\n        round += 1\n      end\n    end\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1\n2\n3\n1\n2\n3\n```\n:::\n:::\n\n\nThis loops over the values 1, 2, and 3, repeating as a cycle.\n\n## Type Stability\n\nJulia has **type stability** for fast compilation and execution. When writing functions, it's important to ensure that the type of the return value can be determined without ambiguity. \n\nExample of type **instability**:\n\n::: {#66a64a0b .cell execution_count=25}\n``` {.julia .cell-code}\nfunction f(x)\n    if x > 0\n        return 1\n    else\n        return 0.0\n    end\nend\n\nprintln(\"The value  2 of type \", typeof( 2), \" produces an output of type \", typeof(f( 2)))\nprintln(\"The value -2 of type \", typeof(-2), \" produces an output of type \", typeof(f(-2)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe value  2 of type Int64 produces an output of type Int64\nThe value -2 of type Int64 produces an output of type Float64\n```\n:::\n:::\n\n\nJulia is dynamically typed, but ensuring **type stability** within functions helps the compiler optimize code for better performance.\n\n::: {.callout-tip}\nFor better performance, always try to ensure type stability in your functions. This can be achieved by making the return type predictable, from the types of input variables and not their values.\n:::\n\n",
    "supporting": [
      "foretaste_of_julia_code_files"
    ],
    "filters": [],
    "includes": {}
  }
}