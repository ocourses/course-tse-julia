[
  {
    "objectID": "lecture1.html#julia-ecosystem",
    "href": "lecture1.html#julia-ecosystem",
    "title": "Julia course: Lecture 1",
    "section": "1 Julia ecosystem",
    "text": "1 Julia ecosystem\nWikipedia citation:\n\nJulia is a high-level, general-purpose dynamic programming language, still designed to be fast and productive, for e.g.Â data science, artificial intelligence, machine learning, modeling and simulation, most commonly used for numerical analysis and computational science.\n\n\nThe work on Julia began in 2009 when Jeff Bezanson, Stefan Karpinski, Alan Edelman and Viral B. Shah set out to create a free language that was both high-level and fast. The first public appearance is in 2012. Juliaâ€™s syntax is now considered stable, since version 1.0 in 2018.\nJulia can be easily downloaded and installed. See the download page where we can find the following.\n\nMac / LinuxWindows\n\n\nInstall the latest Julia version by running this in your terminal:\ncurl -fsSL https://install.julialang.org | sh\n\n\nInstall the latest Julia version from the Microsoft Store by running this in the command prompt:\nwinget install julia -s msstore\n\n\n\nOn the Julia official webpage one can find the following summary of Julia ecosystem.\n\nVisualizationGeneralData ScienceMLScientific DomainsParallel\n\n\n\n\n1.0.1 Data Visualization and Plotting\nData visualization has a complicated history. Plotting software makes trade-offs between features and simplicity, speed and beauty, and a static and dynamic interface. Some packages make a display and never change it, while others make updates in real-time.\nPlots.jlÂ is a visualization interface and toolset. It provides a common API across variousÂ backends, likeÂ GR.jl,Â PyPlot.jl, andÂ PlotlyJS.jl.Â Makie.jlÂ is a sophisticated package for complex graphics and animations. Users who are used to â€œgrammar of graphicsâ€ plotting APIs should take a look atÂ Gadfly.jl.Â VegaLite.jlÂ provides theÂ Vega-LiteÂ grammar of interactive graphics interface as a Julia package. For those who do not wish to leave the comfort of the terminal, there is alsoÂ UnicodePlots.jl.\n\n\n\n\n\n1.0.2 Build, Deploy or Embed Your Code\nJulia makes it possible to build complete applications. Write web UIs withÂ Dash.jlÂ andÂ Genie.jlÂ or native UIs withÂ Gtk4.jl. Pull data fromÂ a variety of databases. Build shared libraries and executables withÂ PackageCompiler. Deploy on a webserver withÂ HTTP.jlÂ or embedded devices. Powerful shell integration make it easy toÂ managing other processes.\nJulia has foreign function interfaces forÂ C, Fortran,Â C++,Â Python,Â R,Â Java,Â Mathematica,Â Matlab, and many other languages. Julia can also be embedded in other programs through itsÂ embedding API. Juliaâ€™sÂ PackageCompilerÂ makes it possible to build binaries from Julia programs that can be integrated into larger projects. Python programs can call Julia usingÂ juliacall. R programs can do the same withÂ Râ€™s JuliaCall, which is demonstrated byÂ calling MixedModels.jl from R. Mathematica supportsÂ calling Julia through its External Evaluation System.\n\n\n\n\n\n1.0.3 Interact with your Data\nThe Julia data ecosystem providesÂ DataFrames.jlÂ to work with datasets, and perform common data manipulations.Â CSV.jlÂ is a fast multi-threaded package to read CSV files and integration with the Arrow ecosystem is in the works withÂ Arrow.jl. Online computations on streaming data can be performed withÂ OnlineStats.jl. TheÂ QueryverseÂ provides query, file IO and visualization functionality. In addition to working with tabular data, theÂ JuliaGraphsÂ packages make it easy to work with combinatorial data.\nJulia can work with almost all databases usingÂ JDBC.jlÂ andÂ ODBC.jlÂ drivers. In addition, it also integrates with the Spark ecosystem throughÂ Spark.jl.\n\n\n\n\n\n1.0.4 Scalable Machine Learning\nTheÂ MLJ.jlÂ package provides a unified interface to common machine learning algorithms, which includeÂ generalized linear models,Â decision trees, andÂ clustering.Â Flux.jlÂ andÂ Lux.jlÂ are powerful packages for Deep Learning. Packages such asÂ Metalhead.jl,Â ObjectDetector.jl, andÂ TextAnalysis.jlÂ provide ready to use pre-trained models for common tasks.Â AlphaZero.jlÂ provides a high performance implementation of the reinforcement learning algorithms from AlphaZero.Â Turing.jlÂ is a best in class package for probabilistic programming.\n\n\n\n\n\n1.0.5 Rich Ecosystem for Scientific Computing\nJulia is designed from the ground up to be very good at numerical and scientific computing. This can be seen in the abundance of scientific tooling written in Julia, such as the state-of-the-art differential equations ecosystemÂ (DifferentialEquations.jl), optimization tools (JuMP.jlÂ andÂ Optim.jl), iterative linear solversÂ (IterativeSolvers.jl), Fast Fourier transformsÂ (AbstractFFTs.jl), and much more. General purpose simulation frameworks are available forÂ Scientific Machine Learning,Â Quantum computingÂ and much more.\nJulia also offers a number of domain-specific ecosystems, such as in biologyÂ (BioJulia), operations researchÂ (JuMP Dev), image processingÂ (JuliaImages), quantum physicsÂ (QuantumBFS), nonlinear dynamicsÂ (JuliaDynamics), quantitative economicsÂ (QuantEcon), astronomyÂ (JuliaAstro)Â and ecologyÂ (EcoJulia). With a set of highly enthusiastic developers and maintainers, the scientific ecosystem in Julia continues to grow rapidly.\n\n\n\n\n\n1.0.6 Parallel and Heterogeneous Computing\nJulia is designed for parallelism, and provides built-in primitives for parallel computing at every level:Â instruction level parallelism,Â multi-threading,Â GPU computing, andÂ distributed computing. TheÂ Celeste.jlÂ projectÂ achieved 1.5 PetaFLOP/sÂ on theÂ Cori supercomputer at NERSCÂ using 650,000 cores.\nThe Julia compiler can also generate native code forÂ GPUs. Packages such asÂ DistributedArrays.jlÂ andÂ Dagger.jlÂ provide higher levels of abstraction for parallelism. Distributed Linear Algebra is provided by packages likeÂ Elemental.jlÂ andÂ TSVD.jl. MPI style parallelism is also available throughÂ MPI.jl.\n\n\n\n\nJulia is a modern language and comes with cloud computing and more, see JuliaHub webpage and the JuliaHub help page.\n\nThe Modern Platform for Technical Computing. A single place for modeling, simulation, and user built applications with the Julia language. Designed with access to CPUs and GPUs for multi-threading, parallel and distributed computing, JuliaHubâ€™s supercomputing infrastructure allows teams to model breakthrough science and technology.\n\nThe Julia programming language has its own conference, see the JuliaCon 2024.\n\nWelcome to JuliaCon 2024, the premier annual conference for the Julia programming language community! This exciting event brings together developers, researchers, and enthusiasts from around the globe to celebrate and explore the power and versatility of Julia."
  },
  {
    "objectID": "lecture1.html#code-execution",
    "href": "lecture1.html#code-execution",
    "title": "Julia course: Lecture 1",
    "section": "2 Code execution",
    "text": "2 Code execution\nThere are different ways to execute Julia code:\n\nwithin a .ipynb file, that is a Jupyter notebook;\ndirectly into the Julia REPL;\nfrom a script file .jl, either in the REPL or in the terminal;\nâ€¦\n\n\n2.1 Jupyter notebooks\n\nYou can write some Julia code inside a Jupyter notebook and execute the code. To interact with the Julia language using Jupyter notebook, please install IJulia.jl.\n\nIJulia is a Julia-language backend combined with the Jupyter interactive environment (also used by IPython). This combination allows you to interact with the Julia language using Jupyter/IPythonâ€™s powerful graphical notebook, which combines code, formatted text, math, and multimedia in a single document. IJulia is a Jupyter language kernel and works with a variety of notebook user interfaces. In addition to the classic Jupyter Notebook, IJulia also works with JupyterLab, a Jupyter-based integrated development environment for notebooks and code. The nteract notebook desktop supports IJulia with detailed instructions for its installation with nteract.\n\nTry to execute the code of example.ipynb.\n\n\n2.2 The Julia REPL\nJulia comes with a full-featured interactive command-line REPL (read-eval-print loop) built into the julia executable. In addition to allowing quick and easy evaluation of Julia statements, it has a searchable history, tab-completion, many helpful keybindings, and dedicated help and shell modes. The REPL can be started by simply calling julia with no arguments or double-clicking on the executable:\n\n\n$ julia\n\n               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type \"?\" for help, \"]?\" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.11.1 (2024-10-16)\n _/ |\\__'_|_|_|\\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\n\njulia&gt;\n\n\nAfter Julia is launched you can start computing.\n\n1+1\n\n2\n\n\nOr print some text.\n\nprint(\"Hello!\")\n\nHello!\n\n\n\n\n\n\n\n\nImportant\n\n\n\nThe Julia REPL has different prompt modes that can be very useful to install / remove packages, run shell commands, search for help, etc. The different modes are:\n\nThe Julian mode\nHelp mode\nShell mode\nPkg mode\nSearch modes\n\nVisit the command-line REPL page for more details.\n\n\n\n\n2.3 Julia scripts\nYou can also write some code in a .jl script.\n\n\n$ cat data/lecture1/example.jl\n\nprintln(\"Hello!\")\n\n\nand execute the code either in the REPL:\n\ninclude(\"data/lecture1/example.jl\")\n\nHello!\n\n\nor in a terminal with the command $ julia example.jl."
  },
  {
    "objectID": "lecture1.html#basic-examples-of-code",
    "href": "lecture1.html#basic-examples-of-code",
    "title": "Julia course: Lecture 1",
    "section": "3 Basic examples of code",
    "text": "3 Basic examples of code\n\nx = 1\n2x\n\n2\n\n\n\nx = sqrt(2)\n\n1.4142135623730951\n\n\n\n# unicode is great\nx = âˆš(2)\n\n1.4142135623730951\n\n\n\nğŸ˜„ = sqrt(2)\n2ğŸ˜„\n\n2.8284271247461903\n\n\nSome functions.\n\n# this is a function\nfunction f(x)\n  return 2x+1\nend\n\nf (generic function with 1 method)\n\n\n\n# this also\nf(x) = 2x+1\n\nf (generic function with 1 method)\n\n\n\n# this also: but f is not available anymore\ng = x -&gt; 2x^2\n\n#16 (generic function with 1 method)\n\n\n\n# be careful of the priorities\ng(1)\n\n2\n\n\n\nHello(name) = \"Hello \" * name * \"!\"\nHello(\"Alban\")\n\n\"Hello Alban!\"\n\n\n\nx = [1 3 12]\nprintln(\"x[2] = \", x[2])\nx[2] = 5\nprintln(\"x[2] = \", x[2])\n\nx[2] = 3\nx[2] = 5\n\n\nThe following function has side effects that can be dangerous.\n\nfunction f(x, y)\n    x[1] = 42      # mutates x\n    y = 7 + sum(x) # new binding for y, no mutation\n    return y\nend\n\na = [4, 5, 6]\nb = 3\n\nprintln(\"f($a, $b) = \", f(a, b))\nprintln(\"a = \", a, \" # a[1] is changed to 42 by f\")\nprintln(\"b = \", b, \" # not changed\")\n\nf([4, 5, 6], 3) = 60\na = [42, 5, 6] # a[1] is changed to 42 by f\nb = 3 # not changed\n\n\nWhen a function has side effects, please use the ! convention. See Argument Passing Behavior.\n\nfunction put_at_second_place!(x, value)\n  x[2] = value\n  return nothing\nend\n\nx = [1 3 12]\nprintln(\"x[2] = \", x[2])\n\nput_at_second_place!(x, 5)\nprintln(\"x[2] = \", x[2])\n\nput_at_second_place!(x[1:3], 15) # be careful if you give a slice\nprintln(\"x[2] = \", x[2])\n\nx[2] = 3\nx[2] = 5\nx[2] = 5\n\n\nA function may have several methods.\n\nÎ£(x::Float64, y::Float64) = 2x + y\n\nÎ£ (generic function with 1 method)\n\n\n\nÎ£(2.0, 3.0)\n\n7.0\n\n\n\nÎ£(2, 3.0)\n\n\nMethodError: no method matching Î£(::Int64, ::Float64)\nThe function `Î£` exists, but no method is defined for this combination of argument types.\n\nClosest candidates are:\n  Î£(::Float64, ::Float64)\n   @ Main In[19]:1\n\n\nStacktrace:\n [1] top-level scope\n   @ In[21]:1\n\n\n\n\nh(x::Number,  y::Number ) = 2x - y\nh(x::Int,     y::Int    ) = 2x * y\nh(x::Float64, y::Float64) = 2x + y\n\nh (generic function with 3 methods)\n\n\n\nprintln(\"h(2,   3.0) = \", h(2, 3.0))\nprintln(\"h(2,   3  ) = \", h(2, 3))\nprintln(\"h(2.0, 3.0) = \", h(2.0, 3.0))\n\nh(2,   3.0) = 1.0\nh(2,   3  ) = 12\nh(2.0, 3.0) = 7.0"
  },
  {
    "objectID": "lecture1.html#documentation",
    "href": "lecture1.html#documentation",
    "title": "Julia course: Lecture 1",
    "section": "4 Documentation",
    "text": "4 Documentation\n\nIn the Julia documentation, you may find:\n\nsome important Links;\na comparison to other languages;\na list of advantages of using Julia\n\nbut also:\n\nmanuals;\nbase documentation;\nstandard librairies documentation;\ndeveloper documentation.\n\n\n\n\n\n\n\nNote\n\n\n\nIn Julia, it is quite common to have the documentation in the form of manuals or tutorials. See Getting Started with Differential Equations in Julia for instance.\n\n\nExample. Search how to compute the norm of a vector.\n\nThe norm function comes from the standard librairy LinearAlgebra.\n\nHowever, we are not directly at the right place, so I recommend to use the Search docs field.\n\nAnd now, we have the documentation.\n\n\n\n\n\n\n\nNote\n\n\n\nIt is also possible to use the help mode:\nusing LinearAlgebra\n?norm"
  },
  {
    "objectID": "lecture1.html#editors-and-ides",
    "href": "lecture1.html#editors-and-ides",
    "title": "Julia course: Lecture 1",
    "section": "5 Editors and IDEs",
    "text": "5 Editors and IDEs\n\n\nVS Code    VS Code Extension \n\n\nJupyter    Jupyter kernel \n\n\nPluto.jl    Simple reactive notebooks \n\n\nVim    Vim plugin \n\n\nEmacs    Emacs plugin \n\n\nI recommend to use VS Code. See the Julia Visual Studio Code Documentation.\n\nJulia for Visual Studio Code is a powerful, free IDE for the Julia language. Visual Studio Code is a powerful and customizable editor. With a completely live environment, Julia for VS Code aims to take the frustration and guesswork out of programming and put the fun back in. We build on Juliaâ€™s unique combination of ease-of-use and performance. Beginners and experts can build better software more quickly, and get to a result faster. Julia is an officially supported language on the VS Code docs."
  },
  {
    "objectID": "lecture1.html#exercise",
    "href": "lecture1.html#exercise",
    "title": "Julia course: Lecture 1",
    "section": "6 Exercise",
    "text": "6 Exercise\n\n6.1 Context: Least Squares Regression Line\nWe propose a first exercise about simple linear regression. The data are excerpted from this example and saved into data.csv. We propose an ordinary least squares formulation which is a type of linear least squares method for choosing the unknown parameters in a linear regression model by the principle of least squares: minimizing the sum of the squares of the differences between the observed dependent variable (values of the variable being observed) in the input dataset and the output of the (linear) function of the independent variable.\n\nGiven a set ofÂ mÂ data pointsÂ y_{1}, y_{2}, \\dots, y_{m},Â consisting of experimentally measured values taken atÂ mÂ valuesÂ x_{1}, x_{2}, \\dots, x_{m}Â of an independent variable (x_iÂ may be scalar or vector quantities), and given a model functionÂ y=f(x,\\beta),Â withÂ \\beta =(\\beta_{1},\\beta_{2},\\dots ,\\beta_{n}),Â it is desired to find the parametersÂ \\beta_j such that the model function â€œbestâ€ fits the data. In linear least squares, linearity is meant to be with respect to parametersÂ \\beta_j, so \n  f(x, \\beta) = \\sum_{j=1}^n \\beta_j\\, \\varphi_j(x).\n In general, the functions \\varphi_j may be nonlinear. However, we consider linear regression, that is \n  f(x, \\beta) = \\beta_1 + \\beta_2 x.\n Ideally, the model function fits the data exactly, so \n  y_i = f(x_i, \\beta)\n for all i=1, 2, \\dots, m. This is usually not possible in practice, as there are more data points than there are parameters to be determined. The approach chosen then is to find the minimal possible value of the sum of squares of the residuals \n  r_i(\\beta) = y_i - f(x_i, \\beta), \\quad i=1, 2, \\dots, m\n so to minimize the function \n  S(\\beta) = \\sum_{i=1}^m r_i^2(\\beta).\n In the linear least squares case, the residuals are of the form \n  r(\\beta) = y - X\\, \\beta\n with y = (y_i)_{1\\le i\\le m} \\in \\mathbb{R}^m and X = (X_{ij})_{1\\le i\\le m, 1\\le j\\le n} \\in \\mathrm{M}_{mn}(\\mathbb{R}), where X_{ij} = \\varphi_j(x_i). Since we consider linear regression, the i-th row of the matrix X is given by \n  X_{i[:]} = [1 \\quad x_i].\n The objective function may be written \n  S(\\beta) = {\\Vert y - X\\, \\beta \\Vert}^2\n where the norm is the usual 2-norm. The solution to the linear least squares problem \n  \\underset{\\beta \\in \\mathbb{R}^n}{\\mathrm{minimize}}\\, {\\Vert y - X\\, \\beta \\Vert}^2\n is computed by solving the normal equation \n  X^\\top X = X^\\top y,\n where X^\\top denotes the transpose of X.\n\n\n6.2 Questions\nTo answer the questions you need to import the following packages.\n\nusing DataFrames\nusing CSV\nusing Plots\n\n\nUsing the packages DataFrames.jl and CSV.jl, load the dataset from data/lecture1/data.csv and save the result into a variable named dataset.\n\n\n\nShow the answer\ndataset = DataFrame(CSV.File(\"data/lecture1/data.csv\"))\n\n\n5Ã—2 DataFrame\n\n\n\nRow\nTime\nMass\n\n\n\nInt64\nInt64\n\n\n\n\n1\n5\n40\n\n\n2\n7\n120\n\n\n3\n12\n180\n\n\n4\n16\n210\n\n\n5\n20\n240\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nDo not hesitate to visit the documentation of CSV.jl and DataFrames.jl.\n\n\n\nUsing the package Plot.jl, plot the data.\n\n\n\nShow the answer\nplt = plot(\n  dataset.Time, \n  dataset.Mass,\n  seriestype=:scatter, \n  legend=false, \n  xlabel=\"Time\", \n  ylabel=\"Mass\"\n)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCreate the matrix X, the vector \\beta and solve the normal equation with the operator Base.\\.\n\n\n\n\n\n\n\nHint\n\n\n\n\n\nUse ones(m) to generate a vector of 1 of length m.\n\n\n\n\n\nShow the answer\nm = length(dataset.Time)\nX = [ones(m) dataset.Time]\ny = dataset.Mass\nÎ² = X\\y\n\n\n2-element Vector{Float64}:\n 11.506493506493449\n 12.207792207792208\n\n\n\nPlot the linear model on the same plot as the data. Use the plot! function. See the basic concepts for plotting.\n\n\n\nShow the answer\nx = [5, 20]\ny = Î²[1] .+ Î²[2]*x\nplot!(plt, x, y)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Julia course",
    "section": "",
    "text": "Lecture 1"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  }
]