[
  {
    "objectID": "tmp/exercices-syntax.html",
    "href": "tmp/exercices-syntax.html",
    "title": "Julia course",
    "section": "",
    "text": "Exercise 1: Temperature Converter\n\nfunction convert_temperature(T; unit)\n    if unit==\"C\" # convert in Fahrenheiht\n        return T * 9/5 + 32\n    elseif unit==\"F\" # convert to Celsius\n        return (T - 32) * 5/9\n    else\n        println(\"Please provide a godd unit! C or F\")\n    end\nend\n\nconvert_temperature (generic function with 1 method)\n\n\n\nconvert_temperature(20, unit=\"C\")\n\n68.0\n\n\n\nconvert_temperature(68, unit=\"F\")\n\n20.0\n\n\nExercise 2: Factorial Function with Closure\n\nfunction make_factorial()\n    counter = 0 # Variable to keep track of calls\n    function factorial(n::Int)\n        y = 1\n        for i âˆˆ 2:n\n            y *= i \n        end\n        counter += 1\n        return y, counter\n    end\n    return factorial \nend\n\nmake_factorial (generic function with 1 method)\n\n\n\nf = make_factorial()\ny, c = f(2)\n\n(2, 1)\n\n\n\ny, c = f(3)\n\n(6, 2)\n\n\nExercise 3: Filter Even Numbers\n\nfunction is_even(n::Int)\n    return n % 2 == 0\nend\n\nis_even (generic function with 1 method)\n\n\n\nis_even(1)\n\nfalse\n\n\n\nis_even(10)\n\ntrue\n\n\n\ntypeof(Int[])\n\n\nVector{Int64} (alias for Array{Int64, 1})\n\n\n\n\nfunction filter_even_int(array::Vector{Int})\n    new_array = Int[]\n    for n âˆˆ array\n        is_even(n) ? push!(new_array, n) : nothing\n    end \n    return new_array\nend\n\nfilter_even_int (generic function with 1 method)\n\n\n\nnumbers = [1.0, 2, 3, 4, 5, 6, 7, 8, 9, 10]\neven_numbers = filter_even_int(numbers)\nprintln(even_numbers)  # Outputs: [2, 4, 6, 8, 10]\n\nMethodError: MethodError: no method matching filter_even_int(::Vector{Float64})\nThe function `filter_even_int` exists, but no method is defined for this combination of argument types.\n\nClosest candidates are:\n  filter_even_int(!Matched::Vector{Int64})\n   @ Main ~/Courses/julia/course-tse-julia/tmp/jl_notebook_cell_df34fa98e69747e1a8f8a730347b8e2f_X23sZmlsZQ==.jl:1\n\nMethodError: no method matching filter_even_int(::Vector{Float64})\n\nThe function `filter_even_int` exists, but no method is defined for this combination of argument types.\n\n\n\nClosest candidates are:\n\n  filter_even_int(!Matched::Vector{Int64})\n\n   @ Main ~/Courses/julia/course-tse-julia/tmp/jl_notebook_cell_df34fa98e69747e1a8f8a730347b8e2f_X23sZmlsZQ==.jl:1\n\n\n\n\n\nStacktrace:\n\n [1] top-level scope\n\n   @ ~/Courses/julia/course-tse-julia/tmp/jl_notebook_cell_df34fa98e69747e1a8f8a730347b8e2f_X25sZmlsZQ==.jl:2\n\n\n\ntypeof(numbers)\n\n\nVector{Float64} (alias for Array{Float64, 1})\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "M2/index.html",
    "href": "M2/index.html",
    "title": "Julia Master 2 course",
    "section": "",
    "text": "This part is under construction.\n\n\n\n\n\nExercices\n\nIntroduction to Julia for statistics through practice\n\n\n\nDistribution of random variables\nLinear regression\n\n\n\n\n\nNo matching items\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Master 2"
    ]
  },
  {
    "objectID": "M2/resources/TP2-linear-regression.html",
    "href": "M2/resources/TP2-linear-regression.html",
    "title": "TP2 : Linear regression",
    "section": "",
    "text": "We suppose that for i=1,\\ldots,n Y_i=\\beta_0+\\beta_1 x+\\varepsilon_i\nwith - E(\\varepsilon_i)=0 - The (\\varepsilon_i)_{i=1,\\dots,n} are i.i.d. - The distributions of (\\varepsilon_i)_{i=1,\\dots,n} are \\mathcal{N}(0,\\sigma^2)\n\n\n\nWe use the mean square estimation of the parameters \\beta_0 and \\beta_1:\n\\begin{array}{ll}\nMin\\quad\nf(\\beta)=\\frac{1}{2}\\sum_{i=1}^{n}r_{i}^{2}(\\beta)& =\\frac{1}{2}\\|r(\\beta)\\|^2\\\\\n\\beta \\in \\mathbf{R}^{2}&\n\\end{array}\nwhere r is the residual function r:\\mathbf{R}^2\\rightarrow \\mathbf{R}^n r_i(\\beta) =  y_i - \\beta_{0}+\\beta_{1}x_{i}\nSo we can write r(\\beta) = y - X\\beta, where\ny = \\begin{pmatrix} y_1\\\\ \\vdots \\\\ y_n\\end{pmatrix}\\;\\,\\texttt{and}\\;\\;\nX = \\begin{pmatrix} 1 & x_1\\\\ \\vdots & \\vdots \\\\ 1 & x_n\\end{pmatrix}\n\nusing Test \nusing DataFrames\nusing Plots\nusing LaTeXStrings\nusing Statistics\nusing DataFrames\nusing GLM\n\ny=[1.8, 2.3, 2, 2.4, 2, 2.5, 2.6, 2.6, 2.9, 2.3, 2.4, 2.1, 2.5, 2.7, 2.7, 3, 3.1, 2.3, 2.5, 3, 3.3, 2.7, 3.1, 2.9, 3.4, 2.4, 3.4, 3.7, 2.8, 3.3, 3.5, 3.3, 2.6]\nx=[25, 25, 25, 25, 25, 25, 25, 35, 35, 35, 35, 35, 35, 35, 45, 45, 45, 45, 45, 45, 45, 45, 55, 55, 55, 55, 55, 65, 65, 65, 65, 65, 65]\nn = length(x)\n\np = plot(x,y, seriestype = :scatter, xlabel = (L\"x\"), ylabel = (L\"y\"))\na , b = .5 , 0.04\nplot!(p,x,a .+ b*x)\n\nr(a,b) = y - (a .+ b*x)\n\nr(a,b)\n\ni = 11\nplot!(p, [x[i],x[i]], [y[i],a+b*x[i]],linewidth=3)\nannotate!(p,x[i],mean([y[i],a+b*x[i]]),text(L\"r_{11}(a,b)\", :left, :green))\nplot(p,legend=false)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFor solving the optimization problem we have to sole the linear system X^TX\\beta = X^Ty\nUse the Â operator for solving linear equation\n\n# \n# Use of the GLM Package\ndatas = DataFrame(age=x, chol = y)\nlm1 = lm(@formula(chol ~ age), datas)\nprintln(coef(lm1))\nprintln(lm1)\n\n# ... To complete\nX = [ones(n) x]\n\nÎ²hatâ‚€, Î²hatâ‚ = (X'*X)\\(X'*y)\nÎ²hat = [Î²hatâ‚€, Î²hatâ‚]\nprintln(\"Normal equation : Î²hatâ‚€, Î²hatâ‚ = \", Î²hatâ‚€, \", \", Î²hatâ‚)\nÎ²hatâ‚€, Î²hatâ‚ = X\\y\nprintln(\"\\\\ of julia : Î²hatâ‚€, Î²hatâ‚ = \", Î²hatâ‚€, \", \", Î²hatâ‚)\np = plot(x,y, seriestype = :scatter, xlabel = (L\"x\"), ylabel = (L\"y\"))\nplot!(p,x,Î²hatâ‚€ .+ Î²hatâ‚*x)\n\nprintln(@test Î²hat â‰ˆ coef(lm1))\n\n[1.639575381679391, 0.024909351145038124]\nStatsModels.TableRegressionModel{LinearModel{GLM.LmResp{Vector{Float64}}, GLM.DensePredChol{Float64, LinearAlgebra.CholeskyPivoted{Float64, Matrix{Float64}, Vector{Int64}}}}, Matrix{Float64}}\n\nchol ~ 1 + age\n\nCoefficients:\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n                 Coef.  Std. Error     t  Pr(&gt;|t|)  Lower 95%  Upper 95%\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n(Intercept)  1.63958    0.189994    8.63    &lt;1e-09  1.25208    2.02707\nage          0.0249094  0.00413632  6.02    &lt;1e-05  0.0164733  0.0333454\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nNormal equation : Î²hatâ‚€, Î²hatâ‚ = 1.6395753816793879, 0.0249093511450382\n\\ of julia : Î²hatâ‚€, Î²hatâ‚ = 1.6395753816793897, 0.02490935114503816\nTest Passed\n\n\n\n\n\n\nWe note r_i = y_i - (\\hat{\\beta}_0 + \\hat{\\beta}_1x_i), then the unbiased estimation of the variance \\sigma^2 is\n\n\\hat{\\sigma}^2\\frac{\\sum_ir_i^2}{n-2}\n\nAs \\hat{\\beta} = (X^TX)^{-1}X^Ty the statistic B=(X^TX)^{-1}X^TY = (X^TX)^{-1}X^T(X\\beta+\\varepsilon)=\\beta +(X^TX)^{-1}X^T\\varepsilon as the \\mathcal{N}(\\beta,\\sigma^2(X^TX)^{-1}) distribution.\n\nSi les postulats sont vÃ©rifiÃ©s alors les intervalles de confiances de \\beta _{0},\\beta _{1} et \\sigma ^{2} au seuil (1-\\alpha ) sont:\n\n\n\\sigma ^{2}\\in \\left[ \\frac{\\sum_{i=1}^{n}r_{i}^{2}}{\\chi _{1-\\alpha /2}};%\n\\frac{\\sum_{i=1}^{n}r_{i}^{2}}{\\chi _{\\alpha /2}}\\right]\n\n\nwhere \\chi _{1-\\alpha /2} and \\chi _{\\alpha /2} sont lues dans le table du Khi-2 Ã  \\nu =n-2 ddl.\n\n\\begin{array}{ccc}\n\\beta _{1} & \\in  & [\\hat{\\beta}_{1}-t_{1-\\alpha /2}\\hat{\\sigma}%\n_{B_{1}}^{{}};\\hat{\\beta}_{1}+t_{1-\\alpha /2}\\hat{\\sigma}_{B_{1}}^{{}}] \\\\\n\\beta _{0} & \\in  & [\\hat{\\beta}_{0}-t_{1-\\alpha /2}\\hat{\\sigma}%\n_{B_{0}}^{{}};\\hat{\\beta}_{0}+t_{1-\\alpha /2}\\hat{\\sigma}_{B_{0}}^{{}}]\n\\end{array}\n\noÃ¹ - ${B{1}}^{2} = $ - \\hat{\\sigma}_{B_{0}}^{2} = \\hat{\\sigma}^{2}(\\dfrac{1}{n}+\\dfrac{\\bar{x}^{2}}{SCE_{x}}) - t_{1-\\alpha /2} from the Student law with n-2 degrees of freedom\n\n\n\n\nCompute the n residuals in the vector res\nCompute the estimation of residual variance \\sigma^2 and of the standard error \\sigma\nCompute the estimation of the variance, covariance matrix \\Sigma.\nCompute the estimation of the standard error of \\hat{\\beta}_0 and \\hat{\\beta}_1.\nCompute the confidence intervalle of \\beta_0 and \\beta_1\n\n\n# Compute the residuals\nres = y-X*Î²hat       \nprintln(\"Test residuals : \",@test res â‰ˆ residuals(lm1))\n\n# estimation of ÏƒÂ²\nÏƒÂ²hat = sum(res.^2)/(n-2)  \nÏƒhat = sqrt(ÏƒÂ²hat)\nprintln(\"ÏƒÂ²hat = \", ÏƒÂ²hat)\n\n\nprintln(\"ÏƒÂ²hat = \", ÏƒÂ²hat)\n\n\n# Variances, covariances matrix of B\nÎ£ = ÏƒÂ²hat*inv(X'*X)      \nprintln(\"Î£ = \", Î£)\ncovB = vcov(lm1)       # GLM Package\nprintln(\"Test Variance, covariance matrix : \", @test Î£ â‰ˆ covB)\n\nusing Distributions\nusing HypothesisTests\nÎ± = 0.05\n\nt_crit = quantile(TDist(n-2),1-Î±/2)\n\nÏƒhatâ‚€ = sqrt(Î£[1,1])\nÏƒhatâ‚ = sqrt(Î£[2,2])\nprintln(\"test of the variance of Ïƒhatâ‚€ : \", @test Ïƒhatâ‚€ â‰ˆ stderror(lm1)[1])\nprintln(\"test of the variance of Ïƒhatâ‚ : \", @test Ïƒhatâ‚ â‰ˆ stderror(lm1)[2])\n\nprintln(\"Î²â‚€ âˆˆ [\", Î²hatâ‚€ - t_crit*Ïƒhatâ‚€, \",\",Î²hatâ‚€ + t_crit*Ïƒhatâ‚€,\"]\")\nprintln(\"Î²â‚ âˆˆ [\", Î²hatâ‚ - t_crit*Ïƒhatâ‚, \",\",Î²hatâ‚ + t_crit*Ïƒhatâ‚,\"]\")\n\nTest residuals : Test Passed\nÏƒÂ²hat = 0.10866889312977099\nÏƒÂ²hat = 0.10866889312977099\nÎ£ = [0.03609767024885643 -0.0007491724741055301; -0.0007491724741055301 1.710912916642387e-5]\nTest Variance, covariance matrix : Test Passed\ntest of the variance of Ïƒhatâ‚€ : Test Passed\ntest of the variance of Ïƒhatâ‚ : Test Passed\nÎ²â‚€ âˆˆ [1.2520803311678832,2.027070432190896]\nÎ²â‚ âˆˆ [0.016473274332038396,0.033345427958037924]\n\n\n\n\n\n\nThe condidence band for the mean is \\hat{\\beta}_0 +\\hat{\\beta}_1x \\pm t_{1-\\alpha/2}\\hat{\\sigma}\\sqrt{\\frac{1}{n}+\\frac{(x-\\bar{x})^2}{SCE_x}}\nThe Prediction band is \\hat{\\beta}_0 +\\hat{\\beta}_1x \\pm t_{1-\\alpha/2}\\hat{\\sigma}\\sqrt{1+\\frac{1}{n}+\\frac{(x-\\bar{x})^2}{SCE_x}}\n\n\n\n\nPlot these confidence and prevision bands on the graph p\n\nprintln(\"n= \", n)\nprintln(\"x = \", x)\n\n\nt_crit = quantile(TDist(n-2),1-Î±/2)\nxbar = mean(x)\nSCE = sum((x .- xbar).^2)\nxx = 20:1:70\np = plot(x,y, seriestype = :scatter, xlabel = (L\"x\"), ylabel = (L\"y\"), label=\"\")\nplot!(p,xx,Î²hatâ‚€ .+ Î²hatâ‚*xx, label=\"\")\n\n# Confidence Bands\n\nyy_sup = Î²hatâ‚€ .+ Î²hatâ‚*xx + t_crit*Ïƒhat*sqrt.(1/n .+ (xx .-xbar).^2/SCE)\nplot!(p, xx, yy_sup, c=:green, label = \"Confidence bands\")\nyy_inf = Î²hatâ‚€ .+ Î²hatâ‚*xx - t_crit*Ïƒhat*sqrt.(1/n .+ (xx .-xbar).^2/SCE)\nplot!(p, xx, yy_inf, c=:green, label = \"\")\n\n# Prevision Bands\nxx = 20:1:70\nyy_sup = Î²hatâ‚€ .+ Î²hatâ‚*xx + t_crit*Ïƒhat*sqrt.(1 .+ 1/n .+ (xx .-xbar).^2/SCE)\nplot!(p, xx, yy_sup, c=:blue, label = \"Prevision bands\")\nyy_inf = Î²hatâ‚€ .+ Î²hatâ‚*xx - t_crit*Ïƒhat*sqrt.(1 .+ 1/n .+ (xx .-xbar).^2/SCE)\nplot!(p, xx, yy_inf, c=:blue, label = \"\")\n\nn= 33\nx = [25, 25, 25, 25, 25, 25, 25, 35, 35, 35, 35, 35, 35, 35, 45, 45, 45, 45, 45, 45, 45, 45, 55, 55, 55, 55, 55, 65, 65, 65, 65, 65, 65]"
  },
  {
    "objectID": "M2/resources/TP2-linear-regression.html#parameters-estimation-by-least-square",
    "href": "M2/resources/TP2-linear-regression.html#parameters-estimation-by-least-square",
    "title": "TP2 : Linear regression",
    "section": "",
    "text": "We suppose that for i=1,\\ldots,n Y_i=\\beta_0+\\beta_1 x+\\varepsilon_i\nwith - E(\\varepsilon_i)=0 - The (\\varepsilon_i)_{i=1,\\dots,n} are i.i.d. - The distributions of (\\varepsilon_i)_{i=1,\\dots,n} are \\mathcal{N}(0,\\sigma^2)\n\n\n\nWe use the mean square estimation of the parameters \\beta_0 and \\beta_1:\n\\begin{array}{ll}\nMin\\quad\nf(\\beta)=\\frac{1}{2}\\sum_{i=1}^{n}r_{i}^{2}(\\beta)& =\\frac{1}{2}\\|r(\\beta)\\|^2\\\\\n\\beta \\in \\mathbf{R}^{2}&\n\\end{array}\nwhere r is the residual function r:\\mathbf{R}^2\\rightarrow \\mathbf{R}^n r_i(\\beta) =  y_i - \\beta_{0}+\\beta_{1}x_{i}\nSo we can write r(\\beta) = y - X\\beta, where\ny = \\begin{pmatrix} y_1\\\\ \\vdots \\\\ y_n\\end{pmatrix}\\;\\,\\texttt{and}\\;\\;\nX = \\begin{pmatrix} 1 & x_1\\\\ \\vdots & \\vdots \\\\ 1 & x_n\\end{pmatrix}\n\nusing Test \nusing DataFrames\nusing Plots\nusing LaTeXStrings\nusing Statistics\nusing DataFrames\nusing GLM\n\ny=[1.8, 2.3, 2, 2.4, 2, 2.5, 2.6, 2.6, 2.9, 2.3, 2.4, 2.1, 2.5, 2.7, 2.7, 3, 3.1, 2.3, 2.5, 3, 3.3, 2.7, 3.1, 2.9, 3.4, 2.4, 3.4, 3.7, 2.8, 3.3, 3.5, 3.3, 2.6]\nx=[25, 25, 25, 25, 25, 25, 25, 35, 35, 35, 35, 35, 35, 35, 45, 45, 45, 45, 45, 45, 45, 45, 55, 55, 55, 55, 55, 65, 65, 65, 65, 65, 65]\nn = length(x)\n\np = plot(x,y, seriestype = :scatter, xlabel = (L\"x\"), ylabel = (L\"y\"))\na , b = .5 , 0.04\nplot!(p,x,a .+ b*x)\n\nr(a,b) = y - (a .+ b*x)\n\nr(a,b)\n\ni = 11\nplot!(p, [x[i],x[i]], [y[i],a+b*x[i]],linewidth=3)\nannotate!(p,x[i],mean([y[i],a+b*x[i]]),text(L\"r_{11}(a,b)\", :left, :green))\nplot(p,legend=false)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFor solving the optimization problem we have to sole the linear system X^TX\\beta = X^Ty\nUse the Â operator for solving linear equation\n\n# \n# Use of the GLM Package\ndatas = DataFrame(age=x, chol = y)\nlm1 = lm(@formula(chol ~ age), datas)\nprintln(coef(lm1))\nprintln(lm1)\n\n# ... To complete\nX = [ones(n) x]\n\nÎ²hatâ‚€, Î²hatâ‚ = (X'*X)\\(X'*y)\nÎ²hat = [Î²hatâ‚€, Î²hatâ‚]\nprintln(\"Normal equation : Î²hatâ‚€, Î²hatâ‚ = \", Î²hatâ‚€, \", \", Î²hatâ‚)\nÎ²hatâ‚€, Î²hatâ‚ = X\\y\nprintln(\"\\\\ of julia : Î²hatâ‚€, Î²hatâ‚ = \", Î²hatâ‚€, \", \", Î²hatâ‚)\np = plot(x,y, seriestype = :scatter, xlabel = (L\"x\"), ylabel = (L\"y\"))\nplot!(p,x,Î²hatâ‚€ .+ Î²hatâ‚*x)\n\nprintln(@test Î²hat â‰ˆ coef(lm1))\n\n[1.639575381679391, 0.024909351145038124]\nStatsModels.TableRegressionModel{LinearModel{GLM.LmResp{Vector{Float64}}, GLM.DensePredChol{Float64, LinearAlgebra.CholeskyPivoted{Float64, Matrix{Float64}, Vector{Int64}}}}, Matrix{Float64}}\n\nchol ~ 1 + age\n\nCoefficients:\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n                 Coef.  Std. Error     t  Pr(&gt;|t|)  Lower 95%  Upper 95%\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n(Intercept)  1.63958    0.189994    8.63    &lt;1e-09  1.25208    2.02707\nage          0.0249094  0.00413632  6.02    &lt;1e-05  0.0164733  0.0333454\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nNormal equation : Î²hatâ‚€, Î²hatâ‚ = 1.6395753816793879, 0.0249093511450382\n\\ of julia : Î²hatâ‚€, Î²hatâ‚ = 1.6395753816793897, 0.02490935114503816\nTest Passed\n\n\n\n\n\n\nWe note r_i = y_i - (\\hat{\\beta}_0 + \\hat{\\beta}_1x_i), then the unbiased estimation of the variance \\sigma^2 is\n\n\\hat{\\sigma}^2\\frac{\\sum_ir_i^2}{n-2}\n\nAs \\hat{\\beta} = (X^TX)^{-1}X^Ty the statistic B=(X^TX)^{-1}X^TY = (X^TX)^{-1}X^T(X\\beta+\\varepsilon)=\\beta +(X^TX)^{-1}X^T\\varepsilon as the \\mathcal{N}(\\beta,\\sigma^2(X^TX)^{-1}) distribution.\n\nSi les postulats sont vÃ©rifiÃ©s alors les intervalles de confiances de \\beta _{0},\\beta _{1} et \\sigma ^{2} au seuil (1-\\alpha ) sont:\n\n\n\\sigma ^{2}\\in \\left[ \\frac{\\sum_{i=1}^{n}r_{i}^{2}}{\\chi _{1-\\alpha /2}};%\n\\frac{\\sum_{i=1}^{n}r_{i}^{2}}{\\chi _{\\alpha /2}}\\right]\n\n\nwhere \\chi _{1-\\alpha /2} and \\chi _{\\alpha /2} sont lues dans le table du Khi-2 Ã  \\nu =n-2 ddl.\n\n\\begin{array}{ccc}\n\\beta _{1} & \\in  & [\\hat{\\beta}_{1}-t_{1-\\alpha /2}\\hat{\\sigma}%\n_{B_{1}}^{{}};\\hat{\\beta}_{1}+t_{1-\\alpha /2}\\hat{\\sigma}_{B_{1}}^{{}}] \\\\\n\\beta _{0} & \\in  & [\\hat{\\beta}_{0}-t_{1-\\alpha /2}\\hat{\\sigma}%\n_{B_{0}}^{{}};\\hat{\\beta}_{0}+t_{1-\\alpha /2}\\hat{\\sigma}_{B_{0}}^{{}}]\n\\end{array}\n\noÃ¹ - ${B{1}}^{2} = $ - \\hat{\\sigma}_{B_{0}}^{2} = \\hat{\\sigma}^{2}(\\dfrac{1}{n}+\\dfrac{\\bar{x}^{2}}{SCE_{x}}) - t_{1-\\alpha /2} from the Student law with n-2 degrees of freedom\n\n\n\n\nCompute the n residuals in the vector res\nCompute the estimation of residual variance \\sigma^2 and of the standard error \\sigma\nCompute the estimation of the variance, covariance matrix \\Sigma.\nCompute the estimation of the standard error of \\hat{\\beta}_0 and \\hat{\\beta}_1.\nCompute the confidence intervalle of \\beta_0 and \\beta_1\n\n\n# Compute the residuals\nres = y-X*Î²hat       \nprintln(\"Test residuals : \",@test res â‰ˆ residuals(lm1))\n\n# estimation of ÏƒÂ²\nÏƒÂ²hat = sum(res.^2)/(n-2)  \nÏƒhat = sqrt(ÏƒÂ²hat)\nprintln(\"ÏƒÂ²hat = \", ÏƒÂ²hat)\n\n\nprintln(\"ÏƒÂ²hat = \", ÏƒÂ²hat)\n\n\n# Variances, covariances matrix of B\nÎ£ = ÏƒÂ²hat*inv(X'*X)      \nprintln(\"Î£ = \", Î£)\ncovB = vcov(lm1)       # GLM Package\nprintln(\"Test Variance, covariance matrix : \", @test Î£ â‰ˆ covB)\n\nusing Distributions\nusing HypothesisTests\nÎ± = 0.05\n\nt_crit = quantile(TDist(n-2),1-Î±/2)\n\nÏƒhatâ‚€ = sqrt(Î£[1,1])\nÏƒhatâ‚ = sqrt(Î£[2,2])\nprintln(\"test of the variance of Ïƒhatâ‚€ : \", @test Ïƒhatâ‚€ â‰ˆ stderror(lm1)[1])\nprintln(\"test of the variance of Ïƒhatâ‚ : \", @test Ïƒhatâ‚ â‰ˆ stderror(lm1)[2])\n\nprintln(\"Î²â‚€ âˆˆ [\", Î²hatâ‚€ - t_crit*Ïƒhatâ‚€, \",\",Î²hatâ‚€ + t_crit*Ïƒhatâ‚€,\"]\")\nprintln(\"Î²â‚ âˆˆ [\", Î²hatâ‚ - t_crit*Ïƒhatâ‚, \",\",Î²hatâ‚ + t_crit*Ïƒhatâ‚,\"]\")\n\nTest residuals : Test Passed\nÏƒÂ²hat = 0.10866889312977099\nÏƒÂ²hat = 0.10866889312977099\nÎ£ = [0.03609767024885643 -0.0007491724741055301; -0.0007491724741055301 1.710912916642387e-5]\nTest Variance, covariance matrix : Test Passed\ntest of the variance of Ïƒhatâ‚€ : Test Passed\ntest of the variance of Ïƒhatâ‚ : Test Passed\nÎ²â‚€ âˆˆ [1.2520803311678832,2.027070432190896]\nÎ²â‚ âˆˆ [0.016473274332038396,0.033345427958037924]\n\n\n\n\n\n\nThe condidence band for the mean is \\hat{\\beta}_0 +\\hat{\\beta}_1x \\pm t_{1-\\alpha/2}\\hat{\\sigma}\\sqrt{\\frac{1}{n}+\\frac{(x-\\bar{x})^2}{SCE_x}}\nThe Prediction band is \\hat{\\beta}_0 +\\hat{\\beta}_1x \\pm t_{1-\\alpha/2}\\hat{\\sigma}\\sqrt{1+\\frac{1}{n}+\\frac{(x-\\bar{x})^2}{SCE_x}}\n\n\n\n\nPlot these confidence and prevision bands on the graph p\n\nprintln(\"n= \", n)\nprintln(\"x = \", x)\n\n\nt_crit = quantile(TDist(n-2),1-Î±/2)\nxbar = mean(x)\nSCE = sum((x .- xbar).^2)\nxx = 20:1:70\np = plot(x,y, seriestype = :scatter, xlabel = (L\"x\"), ylabel = (L\"y\"), label=\"\")\nplot!(p,xx,Î²hatâ‚€ .+ Î²hatâ‚*xx, label=\"\")\n\n# Confidence Bands\n\nyy_sup = Î²hatâ‚€ .+ Î²hatâ‚*xx + t_crit*Ïƒhat*sqrt.(1/n .+ (xx .-xbar).^2/SCE)\nplot!(p, xx, yy_sup, c=:green, label = \"Confidence bands\")\nyy_inf = Î²hatâ‚€ .+ Î²hatâ‚*xx - t_crit*Ïƒhat*sqrt.(1/n .+ (xx .-xbar).^2/SCE)\nplot!(p, xx, yy_inf, c=:green, label = \"\")\n\n# Prevision Bands\nxx = 20:1:70\nyy_sup = Î²hatâ‚€ .+ Î²hatâ‚*xx + t_crit*Ïƒhat*sqrt.(1 .+ 1/n .+ (xx .-xbar).^2/SCE)\nplot!(p, xx, yy_sup, c=:blue, label = \"Prevision bands\")\nyy_inf = Î²hatâ‚€ .+ Î²hatâ‚*xx - t_crit*Ïƒhat*sqrt.(1 .+ 1/n .+ (xx .-xbar).^2/SCE)\nplot!(p, xx, yy_inf, c=:blue, label = \"\")\n\nn= 33\nx = [25, 25, 25, 25, 25, 25, 25, 35, 35, 35, 35, 35, 35, 35, 45, 45, 45, 45, 45, 45, 45, 45, 55, 55, 55, 55, 55, 65, 65, 65, 65, 65, 65]"
  },
  {
    "objectID": "M2/resources/TP2-linear-regression.html#simulation-of-the-distribution-the-estimates-of-beta_0-and-beta_1",
    "href": "M2/resources/TP2-linear-regression.html#simulation-of-the-distribution-the-estimates-of-beta_0-and-beta_1",
    "title": "TP2 : Linear regression",
    "section": "Simulation of the distribution the estimates of \\beta_0 and \\beta_1",
    "text": "Simulation of the distribution the estimates of \\beta_0 and \\beta_1\nWe consider the model Y_i = \\beta_0 + \\beta_1 x_i + \\varepsilon_i with - (\\varepsilon_i)_{i=1,\\ldots,n} i.i.d. - The \\varepsilon_i have the \\mathcal{N}(0,\\sigma^2) distribution - (x_1,\\ldots,x_n) = (1,2,\\ldots,10) - \\beta_0 = 2.0, \\beta_1 = 1.5 and \\sigma = 1.5\nWe recall that the statistic B which estimate the parameter \\beta follows the \\mathcal{N}(\\beta,\\Sigma) distribution, with \\Sigma=\\sigma^2(X^TX)^{-1}.\n\nExercise (more difficult)\n\nDefine a function coefEst() with return the estimation of the parameters \\beta_0 and \\beta_1. We generate a sample of size n=10 of the (y_i)_{i=1,\\ldots,n} inside the fonction\nCompute N samples of the estimation \\hat{\\beta}\nCompute \\Sigma^{-1}\n\n\n\nusing LinearAlgebra\n# initialisation for generating the datas\nÎ²â‚€, Î²â‚ = 2.0, 1.5\nÎ² = [Î²â‚€, Î²â‚]\nÏƒ = 2.5\nn, N = 10, 10^4     # n = size of samples, N = number of samples\nÎ± = 0.05\n\nxVals = collect(1:n) # return the vector [1,2,...,n]\nX = [ones(n) xVals]\nfunction  coefEst()\n    \"\"\" the function first generate the y1,... , yn \n    The values of x and y are then set in a DataFrame, and the linear model is created\n    We return the value in a 2 dimensional vector coeff(model)\n    \"\"\"\n    yVals = Î²â‚€ .+ Î²â‚*xVals +rand(Normal(0,Ïƒ),n)   # genetating a sample\n    data = DataFrame([xVals,yVals], [:x, :y])     # create a DataFrame from the datas\n    model = lm(@formula(y ~ x), data)             # linear regresseion\n    return (coef(model))                          # return the estimation of Î²â‚€ and Î²â‚\nend\n\nests = [coefEst() for _ in  1:N]    # generating N sample of the parameters (in an array)\n\n# The statistic B which estimate Î² follows the N(Î²,Î£) distribution with, Î£ = ÏƒÂ²(Xáµ€X)â»Â¹\nÎ£â»Â¹ = (1/Ïƒ^2)*X'*X    # Compute the inverse of the variance, covariance matrix \nA = cholesky(Î£â»Â¹).U   # Z = A(B-Î²) follows the N(0,I) distribution\nAâ»Â¹ = inv(A)\n# The radius of a standard bidimensional normal distribution follows a Rayleigh law\nradius = quantile(Rayleigh(),1-Î±)  # Zâ‚Â² + Zâ‚‚Â² follows a Ï‡^2 with 2 dof distribution\nisInEllipse(b) = norm(A*(b-Î²)) &lt;= radius # function which indicate if b is in the ellipse or not.\n                                         # A*(b-Î²) transform an ellipse to a circle\nestIn = isInEllipse.(ests)       # Vectorize the function\n\nprintln(\"Percentage of points inside the ellipse : \", sum(estIn)/N)\nscatter(first.(ests[estIn]), last.(ests[estIn]), color = :green, ms=2, msw=0) # display points inside the ellipse \nscatter!(first.(ests[.!estIn]), last.(ests[.!estIn]), color = :red, ms=2, msw=0) # display points outside the ellipse\n# Calculus of the ellipse\nellipsePts = [radius*Aâ»Â¹*[cos(t),sin(t)] + Î² for t in 0:0.01:2*pi] # compute the ellipse\nscatter!([Î²â‚€], [Î²â‚], c=:red, ms=5, msw=2)   # display the center of the ellipse\nplot!(first.(ellipsePts), last.(ellipsePts), c=:blue, lw=2, legend=false,xlabel=L\"\\hat{\\beta}_0\", ylabel=L\"\\hat{\\beta}_1\")\n\nPercentage of points inside the ellipse : 0.9495"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n\n\n Back to top"
  },
  {
    "objectID": "M1/foretaste_of_julia_code.html",
    "href": "M1/foretaste_of_julia_code.html",
    "title": "Foretaste of Julia Code",
    "section": "",
    "text": "Julia is a high-level, high-performance programming language primarily designed for numerical and scientific computing. Its syntax is familiar to users of other technical computing environments, while its flexibility and performance make it an excellent choice for a wide range of applications. In this section, we will look at a few simple examples to illustrate some core features of Julia and demonstrate its intuitive and powerful design.",
    "crumbs": [
      "Master 1",
      "Foretaste of Julia Code"
    ]
  },
  {
    "objectID": "M1/foretaste_of_julia_code.html#variables",
    "href": "M1/foretaste_of_julia_code.html#variables",
    "title": "Foretaste of Julia Code",
    "section": "Variables",
    "text": "Variables\n\nSimple Assignment\nIn Julia, you can assign values to variables directly:\n\nx = 1   # Assign an integer to x\n2x      # The result of 2 * x\n\n2\n\n\n\n\nMathematical Operations\nYou can also perform mathematical operations directly on variables:\n\nx = sqrt(2)    # Assign the square root of 2 to x\nx              # Output the value of x\n\n1.4142135623730951\n\n\n\n\nUsing Unicode\nJulia allows you to use Unicode characters in your code, which makes it more expressive:\n\n# Unicode is great\nx = âˆš(2)        # Square root symbol for 2\nx               # The value of x is the square root of 2\n\n1.4142135623730951\n\n\n\n\nCustom Variable Names\nJulia even allows using emojis for variable names:\n\nğŸ˜„ = sqrt(2)    # Assign the square root of 2 to the emoji variable\n2ğŸ˜„              # Result of 2 times ğŸ˜„\n\n2.8284271247461903\n\n\n\n\n\n\n\n\nNote\n\n\n\nVisit the list of Unicode Input for more examples.",
    "crumbs": [
      "Master 1",
      "Foretaste of Julia Code"
    ]
  },
  {
    "objectID": "M1/foretaste_of_julia_code.html#functions",
    "href": "M1/foretaste_of_julia_code.html#functions",
    "title": "Foretaste of Julia Code",
    "section": "Functions",
    "text": "Functions\n\nSimple Function Definition\nIn Julia, you can define a function using the function keyword:\n\n# this is a function\nfunction f(x)\n  return 2x + 1   # Return a value that is double x plus 1\nend\n\nf (generic function with 2 methods)\n\n\nTo evaluate a function, simply call it with an argument:\n\nf(2)  # Output: 5\n\n5\n\n\n\n\nFunction Definition in Assignment Form\nJulia also supports defintion of functions in assignement form, which are often used for short operations:\n\n# This is also a function\ng(x) = 2x + 1   # A shorthand for defining a function\ng(2)            # Output: 5\n\n5\n\n\n\n\nAnonymous Functions\nJulia also supports anonymous functions (functions without a name):\n\n# Another example with anonymous function\nh = x -&gt; 2x^2    # Function definition using the arrow syntax\nh(1)             # Output: 2, since 2 * 1^2 = 2\n\n2\n\n\n\n\nFunction Priority and Operator Precedence\nIn some cases, you need to be cautious about operator precedence:\n\n# Be careful of operator priorities\nh(1 + 1)  # The correct evaluation is 2 * (1+1)^2 = 8\n\n8",
    "crumbs": [
      "Master 1",
      "Foretaste of Julia Code"
    ]
  },
  {
    "objectID": "M1/foretaste_of_julia_code.html#side-effects",
    "href": "M1/foretaste_of_julia_code.html#side-effects",
    "title": "Foretaste of Julia Code",
    "section": "Side Effects",
    "text": "Side Effects\nIn Julia, functions can have side effects, meaning they modify variables or objects outside the scope of the function. Hereâ€™s an example:\n\nMutating Vectors\nLetâ€™s consider the following vector:\n\nx = [1, 3, 12]\n\n3-element Vector{Int64}:\n  1\n  3\n 12\n\n\nYou can access an element of the vector like this:\n\nx[2]  # Output: 3, the second element of the array\n\n3\n\n\nTo update an element, simply reassign it:\n\nx[2] = 5  # Changes the second element to 5\nx         # Now x = [1, 5, 12]\n\n3-element Vector{Int64}:\n  1\n  5\n 12\n\n\n\n\nSide Effects in Functions\nIf you mutate data inside a function, it will have side effects. For example, consider this function:\n\nfunction f(x, y)\n    x[1] = 42        # Mutates x\n    y = 7 + sum(x)   # New binding for y, no mutation\n    return y\nend\n\na = [4, 5, 6]\nb = 3\n\nprintln(\"f($a, $b) = \", f(a, b))  # f modifies 'a' but not 'b'\nprintln(\"a = \", a, \" # a[1] is changed to 42 by f\")\nprintln(\"b = \", b, \" # b remains unchanged\")\n\nf([4, 5, 6], 3) = 60\na = [42, 5, 6] # a[1] is changed to 42 by f\nb = 3 # b remains unchanged\n\n\n\n\nThe Bang Convention\nWhen a function has side effects, itâ€™s a good practice to use the ! symbol at the end of the functionâ€™s name. This is called the bang convention, and it signals that the function mutates its arguments:\n\nfunction put_at_second_place!(x, value)\n  x[2] = value\n  return nothing  # No explicit return, it's just a side effect\nend\n\nx = [1, 3, 12]\nprintln(\"x[2] before: \", x[2])\n\nput_at_second_place!(x, 5)  # Mutates x\nprintln(\"x[2] after: \", x[2])\n\nx[2] before: 3\nx[2] after: 5\n\n\n\n\nCaution with Slices\nWhen you pass a slice of an array to a function in Julia, the slice is actually a copy, so modifying it does not alter the original array:\n\nx = [1, 2, 3, 4]\nprintln(\"x[2] before slice modification: \", x[2])\n\nput_at_second_place!(x[1:3], 15)  # Safe to modify the slice\n\nprintln(\"x[2] after slice modification: \", x[2])  # Original array remains unchanged\n\nx[2] before slice modification: 2\nx[2] after slice modification: 2\n\n\n\n\n\n\n\n\nTip\n\n\n\nWhen working with slices, remember that they are copies in Julia. Modifying a slice will not impact the original array, which helps prevent unintentional changes to your data.",
    "crumbs": [
      "Master 1",
      "Foretaste of Julia Code"
    ]
  },
  {
    "objectID": "M1/foretaste_of_julia_code.html#methods",
    "href": "M1/foretaste_of_julia_code.html#methods",
    "title": "Foretaste of Julia Code",
    "section": "Methods",
    "text": "Methods\nJulia supports multiple methods for the same function name, which allows for more flexible and dynamic behavior. Hereâ€™s an example:\n\nMethod Overloading\nYou can define several methods for the same function with different types:\n\nÎ£(x::Float64, y::Float64) = 2x + y   # Method for Float64 inputs\n\nÎ£ (generic function with 1 method)\n\n\nCalling the function:\n\nÎ£(2.0, 3.0)  # Output: 7.0\n\n7.0\n\n\nIf you call Î£ with arguments that donâ€™t match the types, Julia will throw an error:\n\nÎ£(2, 3.0)  # Error: no method matching Î£(::Int64, ::Float64)\n\n\nMethodError: no method matching Î£(::Int64, ::Float64)\nThe function `Î£` exists, but no method is defined for this combination of argument types.\n\nClosest candidates are:\n  Î£(::Float64, ::Float64)\n   @ Main In[325]:1\n\n\nStacktrace:\n [1] top-level scope\n   @ In[327]:1\n\n\n\n\n\nMultiple Methods for Different Types\nYou can define more methods that work with different types:\n\nÏ†(x::Number, y::Number) = 2x - y           # General method for numbers\nÏ†(x::Int, y::Int)     = 2x * y             # Method for integers\nÏ†(x::Float64, y::Float64) = 2x + y         # Method for Float64\n\nÏ† (generic function with 3 methods)\n\n\n\n\nMethod Dispatch Example\nJulia will select the appropriate method based on the argument types:\n\nprintln(\"Ï†(2,   3.0) = \", Ï†(2, 3.0))       # Uses general method\nprintln(\"Ï†(2,   3)   = \", Ï†(2, 3))         # Uses the integer method\nprintln(\"Ï†(2.0, 3.0) = \", Ï†(2.0, 3.0))     # Uses the Float64 method\n\nÏ†(2,   3.0) = 1.0\nÏ†(2,   3)   = 12\nÏ†(2.0, 3.0) = 7.0",
    "crumbs": [
      "Master 1",
      "Foretaste of Julia Code"
    ]
  },
  {
    "objectID": "M1/foretaste_of_julia_code.html#iterators",
    "href": "M1/foretaste_of_julia_code.html#iterators",
    "title": "Foretaste of Julia Code",
    "section": "Iterators",
    "text": "Iterators\nIn Julia, iterators allow you to loop through collections in a memory-efficient way. Hereâ€™s an example of using 1:5 as an iterator:\n\nfor i in 1:5\n    println(i)\nend\n\n1\n2\n3\n4\n5\n\n\nThis prints the numbers from 1 to 5. You can also iterate through ranges and collections:\n\nfor i in [10, 20, 30]\n    println(i)\nend\n\n10\n20\n30\n\n\n\nWorking with Lazy Collections\nJuliaâ€™s Iterators package allows for lazy collections, where values are computed on demand. Hereâ€™s an example:\n\nusing Base.Iterators: cycle\nround = 1\nfor i in cycle([1, 2, 3])\n    println(i)\n    if i == 3\n      if round == 2\n        break\n      else\n        round += 1\n      end\n    end\nend\n\n1\n2\n3\n1\n2\n3\n\n\nThis loops over the values 1, 2, and 3, repeating as a cycle.",
    "crumbs": [
      "Master 1",
      "Foretaste of Julia Code"
    ]
  },
  {
    "objectID": "M1/foretaste_of_julia_code.html#type-stability",
    "href": "M1/foretaste_of_julia_code.html#type-stability",
    "title": "Foretaste of Julia Code",
    "section": "Type Stability",
    "text": "Type Stability\nJulia has type stability for fast compilation and execution. When writing functions, itâ€™s important to ensure that the type of the return value can be determined without ambiguity.\nExample of type instability:\n\nfunction f(x)\n    if x &gt; 0\n        return 1\n    else\n        return 0.0\n    end\nend\n\nprintln(\"The value  2 of type \", typeof( 2), \" produces an output of type \", typeof(f( 2)))\nprintln(\"The value -2 of type \", typeof(-2), \" produces an output of type \", typeof(f(-2)))\n\nThe value  2 of type Int64 produces an output of type Int64\nThe value -2 of type Int64 produces an output of type Float64\n\n\nJulia is dynamically typed, but ensuring type stability within functions helps the compiler optimize code for better performance.\n\n\n\n\n\n\nTip\n\n\n\nFor better performance, always try to ensure type stability in your functions. This can be achieved by making the return type predictable, from the types of input variables and not their values.",
    "crumbs": [
      "Master 1",
      "Foretaste of Julia Code"
    ]
  },
  {
    "objectID": "M1/foretaste_of_julia_code.html#exercise",
    "href": "M1/foretaste_of_julia_code.html#exercise",
    "title": "Foretaste of Julia Code",
    "section": "Exercise",
    "text": "Exercise\n\nLeast Squares Regression Line\nWe propose a first exercise about simple linear regression. The data are excerpted from this example and saved into data.csv. We propose an ordinary least squares formulation which is a type of linear least squares method for choosing the unknown parameters in a linear regression model by the principle of least squares: minimizing the sum of the squares of the differences between the observed dependent variable (values of the variable being observed) in the input dataset and the output of the (linear) function of the independent variable.\n\nGiven a set ofÂ mÂ data pointsÂ y_{1}, y_{2}, \\dots, y_{m},Â consisting of experimentally measured values taken atÂ mÂ valuesÂ x_{1}, x_{2}, \\dots, x_{m}Â of an independent variable (x_iÂ may be scalar or vector quantities), and given a model functionÂ y=f(x,\\beta),Â withÂ \\beta =(\\beta_{1},\\beta_{2},\\dots ,\\beta_{n}),Â it is desired to find the parametersÂ \\beta_j such that the model function â€œbestâ€ fits the data. In linear least squares, linearity is meant to be with respect to parametersÂ \\beta_j, so \n  f(x, \\beta) = \\sum_{j=1}^n \\beta_j\\, \\varphi_j(x).\n In general, the functions \\varphi_j may be nonlinear. However, we consider linear regression, that is \n  f(x, \\beta) = \\beta_1 + \\beta_2 x.\n Ideally, the model function fits the data exactly, so \n  y_i = f(x_i, \\beta)\n for all i=1, 2, \\dots, m. This is usually not possible in practice, as there are more data points than there are parameters to be determined. The approach chosen then is to find the minimal possible value of the sum of squares of the residuals \n  r_i(\\beta) = y_i - f(x_i, \\beta), \\quad i=1, 2, \\dots, m\n so to minimize the function \n  S(\\beta) = \\sum_{i=1}^m r_i^2(\\beta).\n In the linear least squares case, the residuals are of the form \n  r(\\beta) = y - X\\, \\beta\n with y = (y_i)_{1\\le i\\le m} \\in \\mathbb{R}^m and X = (X_{ij})_{1\\le i\\le m, 1\\le j\\le n} \\in \\mathrm{M}_{mn}(\\mathbb{R}), where X_{ij} = \\varphi_j(x_i). Since we consider linear regression, the i-th row of the matrix X is given by \n  X_{i[:]} = [1 \\quad x_i].\n The objective function may be written \n  S(\\beta) = {\\Vert y - X\\, \\beta \\Vert}^2\n where the norm is the usual 2-norm. The solution to the linear least squares problem \n  \\underset{\\beta \\in \\mathbb{R}^n}{\\mathrm{minimize}}\\, {\\Vert y - X\\, \\beta \\Vert}^2\n is computed by solving the normal equation \n  X^\\top X\\, \\beta = X^\\top y,\n where X^\\top denotes the transpose of X.\n\n\nQuestions\nTo answer the questions you need to import the following packages.\n\nusing DataFrames\nusing CSV\nusing Plots\n\nYou also need to download the csv file. Click on the following image.\n  \n\nUsing the packages DataFrames.jl and CSV.jl, load the dataset from data/introduction/data.csv and save the result into a variable named dataset.\n\n\n\nShow the answer\npath = \"data/introduction/data.csv\" # update depending on the location of your file\ndataset = DataFrame(CSV.File(path))\n\n\n5Ã—2 DataFrame\n\n\n\nRow\nTime\nMass\n\n\n\nInt64\nInt64\n\n\n\n\n1\n5\n40\n\n\n2\n7\n120\n\n\n3\n12\n180\n\n\n4\n16\n210\n\n\n5\n20\n240\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nDo not hesitate to visit the documentation of CSV.jl and DataFrames.jl.\n\n\n\nUsing the package Plot.jl, plot the data.\n\n\n\n\n\n\n\nHint\n\n\n\n\n\nUse names(dataset) to get the list of data names. If Time is a name you can access to the associated data by dataset.Time.\n\n\n\n\n\nShow the answer\nplt = plot(\n  dataset.Time, \n  dataset.Mass,\n  seriestype=:scatter, \n  legend=false, \n  xlabel=\"Time\", \n  ylabel=\"Mass\"\n)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCreate the matrix X, the vector \\beta and solve the normal equation with the operator Base.\\.\n\n\n\n\n\n\n\nHint\n\n\n\n\n\nUse ones(m) to generate a vector of 1 of length m.\n\n\n\n\n\nShow the answer\nm = length(dataset.Time)\nX = [ones(m) dataset.Time]\ny = dataset.Mass\nÎ² = X\\y\n\n\n2-element Vector{Float64}:\n 11.506493506493449\n 12.207792207792208\n\n\n\nPlot the linear model on the same plot as the data. Use the plot! function. See the basic concepts for plotting.\n\n\n\nShow the answer\nx = [5, 20]\ny = Î²[1] .+ Î²[2]*x\nplot!(plt, x, y)",
    "crumbs": [
      "Master 1",
      "Foretaste of Julia Code"
    ]
  },
  {
    "objectID": "M1/advanced-types.html",
    "href": "M1/advanced-types.html",
    "title": "Advanced Types and Error Handling in Julia",
    "section": "",
    "text": "In this section, we will delve into some of the more advanced features of Juliaâ€™s type system and error handling. We will explore the hierarchical structure of types, how to define and work with parametric types, as well as how to handle type conversions and promotions. Additionally, we will look at how to manage errors in Julia, including common error types and exception handling mechanisms.\nBy the end of this page, youâ€™ll have a deeper understanding of Juliaâ€™s flexible and powerful type system, which is essential for writing efficient, type-safe code. We will also cover how to manage and handle errors gracefully to ensure that your programs run smoothly.\nTopics Covered:",
    "crumbs": [
      "Master 1",
      "Advanced Types"
    ]
  },
  {
    "objectID": "M1/advanced-types.html#type-hierarchies",
    "href": "M1/advanced-types.html#type-hierarchies",
    "title": "Advanced Types and Error Handling in Julia",
    "section": "Type Hierarchies",
    "text": "Type Hierarchies\nIn Julia, types are organized into a hierarchy with Any as the root. At the top, Any is the most general type, and all other types are subtypes of Any. The type hierarchy enables Julia to provide flexibility while supporting efficient dispatch based on types.\n\nAbstract and Concrete Types\nTypes in Julia can be abstract or concrete: - Abstract types serve as nodes in the hierarchy but cannot be instantiated. They provide a framework for organizing related types. - Concrete types can be instantiated and are the actual types used for values.\nFor example, Juliaâ€™s Real and AbstractFloat types are abstract, while Int64 and Float64 are concrete subtypes.\n\nprintln(Int64 &lt;: Real)          # true\nprintln(Float64 &lt;: AbstractFloat) # true\n\ntrue\ntrue\n\n\n\n\nChecking if a Type is Concrete\nIn Julia, you can use the isconcretetype function to check if a type is concrete (meaning it can be instantiated) or abstract (which serves as a blueprint for other types but cannot be instantiated directly).\n\nprintln(isconcretetype(Int64))        # true, Int64 is a concrete type\nprintln(isconcretetype(AbstractFloat)) # false, AbstractFloat is an abstract type\n\ntrue\nfalse\n\n\nThe isconcretetype function returns true for concrete types (like Int64 or Float64) and false for abstract types (like AbstractFloat or Real). This can be useful when writing functions that need to differentiate between abstract and co\n\n\nGet the Type of a Variable\nYou can use the typeof() function to get the type of a variable:\n\na = 42\ntypeof(a)  # Output: Int64\n\nInt64\n\n\nThe typeof() function returns the concrete type of the variable.\n\n\nThe isa Operator\nThe isa operator is used to check if a value is an instance of a specific type:\n\na = 42\nprintln(a isa Int64)  # true\nprintln(a isa Number)  # true\nprintln(a isa Float64) # false\n\ntrue\ntrue\nfalse\n\n\nThe isa operator is often used for type checking within functions or when validating data.\n\n\nThe &lt;: Operator\nThe &lt;: operator checks if a type is a subtype of another type in the hierarchy. It can be used for checking if one type is a more general or more specific type than another:\n\nprintln(Int64 &lt;: Real)       # true, Int64 is a subtype of Real\nprintln(Float64 &lt;: Real)     # true, Float64 is a subtype of Real\nprintln(Float64 &lt;: Number)     # true, Float64 is a subtype of Number\nprintln(Int64 &lt;: AbstractFloat) # false\n\ntrue\ntrue\ntrue\nfalse\n\n\n\n\nQuiz\n\n\n\n\n\n\nQuiz: Type Hierarchies in Julia\n\n\n\n\n\n\n\nQuestion 1. What is the purpose of an abstract type in Julia?\n\n\n\n\n\n\n\n\n  \n    \n      \n        \n    \nSelect an item\n\n    \n      \n      \n      \n        It defines a concrete implementation for other types.\n      \n    \n\n\n    \n      \n      \n      \n        It can be instantiated and used directly.\n      \n    \n\n\n    \n      \n      \n      \n        It provides a blueprint for organizing related types but cannot be instantiated.\n      \n    \n\n\n    \n      \n      \n      \n        It is used for type annotations in functions.\n      \n    \n\n\n\n    \n        \n      \n      \n    \n  \n\n\n\n\n\n\n\n\nQuestion 2. Which of the following types is a concrete type?\n\n\n\n\n\n\n\n\n  \n    \n      \n        \n    \nSelect an item\n\n    \n      \n      \n      \n        AbstractFloat\n      \n    \n\n\n    \n      \n      \n      \n        Real\n      \n    \n\n\n    \n      \n      \n      \n        Number\n      \n    \n\n\n    \n      \n      \n      \n        Int64\n      \n    \n\n\n\n    \n        \n      \n      \n    \n  \n\n\n\n\n\n\n\n\nQuestion 3. What does the isconcretetype function return for AbstractFloat?\n\n\n\n\n\n\n\n\n  \n    \n      \n        \n    \nSelect an item\n\n    \n      \n      \n      \n        false\n      \n    \n\n\n    \n      \n      \n      \n        null\n      \n    \n\n\n    \n      \n      \n      \n        Error: Undefined type\n      \n    \n\n\n    \n      \n      \n      \n        true\n      \n    \n\n\n\n    \n        \n      \n      \n    \n  \n\n\n\n\n\n\n\n\nQuestion 4. What will the following code return?\n\n\n\n\ntypeof(42)\n\n\n\n\n\n\n  \n    \n      \n        \n    \nSelect an item\n\n    \n      \n      \n      \n        Integer\n      \n    \n\n\n    \n      \n      \n      \n        Number\n      \n    \n\n\n    \n      \n      \n      \n        Real\n      \n    \n\n\n    \n      \n      \n      \n        Int64\n      \n    \n\n\n\n    \n        \n      \n      \n    \n  \n\n\n\n\n\n\n\n\nQuestion 5. What is the purpose of the isa operator in Julia?\n\n\n\n\n\n\n\n\n  \n    \n      \n        \n    \nSelect an item\n\n    \n      \n      \n      \n        To check if a variable is a subtype of Any.\n      \n    \n\n\n    \n      \n      \n      \n        To check if a variable's value matches a specific type.\n      \n    \n\n\n    \n      \n      \n      \n        To check if a type is concrete.\n      \n    \n\n\n    \n      \n      \n      \n        To check if a variable is an instance of a specific type or any of its subtypes.\n      \n    \n\n\n\n    \n        \n      \n      \n    \n  \n\n\n\n\n\n\n\n\nQuestion 6. What will be the result of the following code?\n\n\n\n\nprintln(Int64 &lt;: Real)\n\n\n\n\n\n\n  \n    \n      \n        \n    \nSelect an item\n\n    \n      \n      \n      \n        true for Float64 but not for Int64\n      \n    \n\n\n    \n      \n      \n      \n        false\n      \n    \n\n\n    \n      \n      \n      \n        true\n      \n    \n\n\n    \n      \n      \n      \n        Error: Type mismatch\n      \n    \n\n\n\n    \n        \n      \n      \n    \n  \n\n\n\n\n\n\n\n\nQuestion 7. In the context of Juliaâ€™s type system, what is the difference between an abstract type and a concrete type?\n\n\n\n\n\n\n\n\n  \n    \n      \n        \n    \nSelect an item\n\n    \n      \n      \n      \n        Abstract types have fields, while concrete types do not.\n      \n    \n\n\n    \n      \n      \n      \n        Abstract types can be instantiated, whereas concrete types cannot.\n      \n    \n\n\n    \n      \n      \n      \n        Concrete types can be instantiated, whereas abstract types cannot.\n      \n    \n\n\n    \n      \n      \n      \n        Concrete types are slower than abstract types.\n      \n    \n\n\n\n    \n        \n      \n      \n    \n  \n\n\n\n\n\n\n\n\nQuestion 8. What does the following code output?\n\n\n\n\na = 42\nprintln(a isa Int64)\n\n\n\n\n\n\n  \n    \n      \n        \n    \nSelect an item\n\n    \n      \n      \n      \n        true\n      \n    \n\n\n    \n      \n      \n      \n        false\n      \n    \n\n\n    \n      \n      \n      \n        true only for Float64\n      \n    \n\n\n    \n      \n      \n      \n        Error: Undefined type\n      \n    \n\n\n\n    \n        \n      \n      \n    \n  \n\n\n\n\n\n\n\n\nQuestion 9. What does the &lt;: operator check in Julia?\n\n\n\n\n\n\n\n\n  \n    \n      \n        \n    \nSelect an item\n\n    \n      \n      \n      \n        If a type is abstract.\n      \n    \n\n\n    \n      \n      \n      \n        If one type is a subtype of another.\n      \n    \n\n\n    \n      \n      \n      \n        If a type can be instantiated.\n      \n    \n\n\n    \n      \n      \n      \n        If two types are exactly the same.\n      \n    \n\n\n\n    \n        \n      \n      \n    \n  \n\n\n\n\n\n\n\n\nQuestion 10. Which of the following is a correct use of a type annotation in Julia?\n\n\n\n\nx::Int = 10\ny::Float64 = 3.14\n\n\n\n\n\n\n  \n    \n      \n        \n    \nSelect an item\n\n    \n      \n      \n      \n        Type annotations are not allowed in Julia.\n      \n    \n\n\n    \n      \n      \n      \n        x and y are type-annotated, meaning they must hold values of type Int and Float64, respectively.\n      \n    \n\n\n    \n      \n      \n      \n        x can be assigned any value, but y must be of type Float64.\n      \n    \n\n\n    \n      \n      \n      \n        x and y are type-annotated, meaning they can hold any type of value.",
    "crumbs": [
      "Master 1",
      "Advanced Types"
    ]
  },
  {
    "objectID": "M1/advanced-types.html#type-annotations-and-declarations",
    "href": "M1/advanced-types.html#type-annotations-and-declarations",
    "title": "Advanced Types and Error Handling in Julia",
    "section": "Type Annotations and Declarations",
    "text": "Type Annotations and Declarations\nIn Julia, you can specify types for variables, function arguments, and return values. Type annotations help to provide clarity in your code, and in some cases, they can enable Juliaâ€™s just-in-time (JIT) compiler to generate more efficient code. While type annotations are optional, they are recommended for improving code readability and performance.\n\nVariable Type Annotations\nYou can explicitly declare the type of a variable by using a type annotation:\n\nx::Int = 10  # x is an integer\ny::Float64 = 3.14  # y is a Float64\n\nIn this example, x is explicitly declared as an integer (Int), and y is declared as a Float64. Type annotations can also be used with mutable and immutable structs.\n\n\nFunction Argument Type Annotations\nYou can specify types for function arguments to ensure that the function only accepts values of a specific type:\n\nfunction add(a::Int, b::Int)\n    return a + b\nend\n\nprintln(add(3, 4))  # Valid\nprintln(add(3, \"4\"))  # Error: Argument \"4\" is a String, not an Integer\n\n7\n\n\n\nMethodError: no method matching add(::Int64, ::String)\nThe function `add` exists, but no method is defined for this combination of argument types.\n\nClosest candidates are:\n  add(::Int64, ::Int64)\n   @ Main In[30]:1\n\n\nStacktrace:\n [1] top-level scope\n   @ In[30]:6\n\n\n\nIn the above example, a and b must both be Ints. If you try to pass a value of the wrong type (like \"4\"), Julia will throw a type error.\n\n\nReturn Type Annotations\nYou can also annotate the return type of a function:\n\nfunction multiply(a::Int, b::Int)::Int\n    return a * b\nend\n\nmultiply (generic function with 1 method)\n\n\nHere, the function multiply is declared to return an Int, ensuring that the result will always be an integer.\n\n\nType Constraints in Functions\nType constraints can be added in function signatures to specify more precisely what types are allowed. This is especially useful for parametric types, as discussed in the next section.\n\nfunction display_number(x::T) where T &lt;: Real\n    println(\"The number is: \", x)\nend\n\ndisplay_number(3)  # Valid\ndisplay_number(3.5)  # Valid\ndisplay_number(\"Hello\")  # Error: Argument \"Hello\" is not a subtype of Real\n\nThe number is: 3\nThe number is: 3.5\n\n\n\nMethodError: no method matching display_number(::String)\nThe function `display_number` exists, but no method is defined for this combination of argument types.\n\nClosest candidates are:\n  display_number(::T) where T&lt;:Real\n   @ Main In[32]:1\n\n\nStacktrace:\n [1] top-level scope\n   @ In[32]:7\n\n\n\nIn the above function, the argument x must be of type Real or a subtype of Real, which includes Int, Float64, and others.\n\n\nQuiz\n\n\n\n\n\n\nQuiz: Type Annotations and Declarations in Julia\n\n\n\n\n\n\n\nQuestion 1. What is the primary purpose of type annotations in Julia?\n\n\n\n\n\n\n\n\n  \n    \n      \n        \n    \nSelect an item\n\n    \n      \n      \n      \n        To make code run faster by skipping type checks.\n      \n    \n\n\n    \n      \n      \n      \n        To specify the exact memory address of a variable.\n      \n    \n\n\n    \n      \n      \n      \n        To prevent errors from occurring in the code.\n      \n    \n\n\n    \n      \n      \n      \n        To provide clarity in the code and enable optimizations by the compiler.\n      \n    \n\n\n\n    \n        \n      \n      \n    \n  \n\n\n\n\n\n\n\n\nQuestion 2. Which of the following correctly applies a type annotation to a variable?\n\n\n\n\n\n\n\n\n  \n    \n      \n        \n    \nSelect an item\n\n    \n      \n      \n      \n        a::Int = 10\n      \n    \n\n\n    \n      \n      \n      \n        a:Int = 10\n      \n    \n\n\n    \n      \n      \n      \n        Int::a = 10\n      \n    \n\n\n    \n      \n      \n      \n        a = 10::Int\n      \n    \n\n\n\n    \n        \n      \n      \n    \n  \n\n\n\n\n\n\n\n\nQuestion 3. What will happen if the following code is executed?\n\n\n\n\nfunction add(a::Int, b::Int)\n    return a + b\nend\n\nadd(3, \"4\")\n\n\n\n\n\n\n  \n    \n      \n        \n    \nSelect an item\n\n    \n      \n      \n      \n        It will throw a syntax error.\n      \n    \n\n\n    \n      \n      \n      \n        It will ignore the type annotation and return 7.\n      \n    \n\n\n    \n      \n      \n      \n        It will convert \"4\" to an Int and return 7.\n      \n    \n\n\n    \n      \n      \n      \n        It will throw a type error because \"4\" is a String, not an Int.\n      \n    \n\n\n\n    \n        \n      \n      \n    \n  \n\n\n\n\n\n\n\n\nQuestion 4. In Julia, what will the following code output?\n\n\n\n\nfunction multiply(a::Int, b::Int)::Int\n    return a * b\nend\nprintln(multiply(3, 4))\n\n\n\n\n\n\n  \n    \n      \n        \n    \nSelect an item\n\n    \n      \n      \n      \n        12\n      \n    \n\n\n    \n      \n      \n      \n        Nothing\n      \n    \n\n\n    \n      \n      \n      \n        12.0\n      \n    \n\n\n    \n      \n      \n      \n        Error: Incorrect type\n      \n    \n\n\n\n    \n        \n      \n      \n    \n  \n\n\n\n\n\n\n\n\nQuestion 5. What will happen when the following code is executed?\n\n\n\n\nfunction display_number(x::T) where T &lt;: Real\n    println(\"The number is: \", x)\nend\n\ndisplay_number(\"Hello\")\n\n\n\n\n\n\n  \n    \n      \n        \n    \nSelect an item\n\n    \n      \n      \n      \n        It will output: 'The number is: Hello'\n      \n    \n\n\n    \n      \n      \n      \n        It will throw a type error because \"Hello\" is not a subtype of Real.\n      \n    \n\n\n    \n      \n      \n      \n        It will print nothing.\n      \n    \n\n\n    \n      \n      \n      \n        It will convert 'Hello' to a Real type.",
    "crumbs": [
      "Master 1",
      "Advanced Types"
    ]
  },
  {
    "objectID": "M1/advanced-types.html#parametric-types-and-functions",
    "href": "M1/advanced-types.html#parametric-types-and-functions",
    "title": "Advanced Types and Error Handling in Julia",
    "section": "Parametric Types and Functions",
    "text": "Parametric Types and Functions\nParametric types in Julia allow you to create types that can work with multiple data types, providing flexibility and enabling generic programming. This is particularly useful when you want to create functions, structs, or methods that can handle various types without needing to duplicate code.\n\nParametric Composite Types\nA parametric struct can take one or more type parameters:\n\nstruct Pair{T, S}\n    first::T\n    second::S\nend\n\npair1 = Pair(1, \"apple\")  # Pair of Int and String\npair2 = Pair(3.14, true)  # Pair of Float64 and Bool\n\n@show pair1\n@show pair2\n\npair1 = Pair{Int64, String}(1, \"apple\")\npair2 = Pair{Float64, Bool}(3.14, true)\n\n\nIn this case, Pair can be instantiated with any two types T and S, making it more versatile.\n\n\nParametric Abstract Types\nIn Julia, parametric abstract types allow you to define an abstract type that is parameterized by another type. This enables the creation of more flexible and reusable abstractions, where the typeâ€™s behavior can be customized based on the type of its parameter.\nParametric abstract types are used to create a family of types that can represent a wide range of concrete types, without specifying exactly which type is being used. The parameter can be a single type or even a tuple of types.\n\nSyntax:\n\nabstract type AbstractContainer{T} end\n\nHere, AbstractContainer is an abstract type that takes a type parameter T. Any concrete type that is a subtype of AbstractContainer can specify the concrete type for T.\n\n\nExample:\n\nabstract type AbstractContainer{T} end\n\nstruct VectorContainer{T} &lt;: AbstractContainer{T}\n    data::Vector{T}\nend\n\nstruct SetContainer{T} &lt;: AbstractContainer{T}\n    data::Set{T}\nend\n\nfunction print_container_info(container::AbstractContainer{T}) where T\n    println(\"Container holds values of type: \", T)\nend\n\n# Usage:\nvec = VectorContainer([1, 2, 3])\nset = SetContainer(Set([1, 2, 3]))\n\nprint_container_info(vec)\nprint_container_info(set)\n\nContainer holds values of type: Int64\nContainer holds values of type: Int64\n\n\n\n\nExplanation:\n\nAbstractContainer{T} is a parametric abstract type, where T represents the type of elements contained within the container.\nVectorContainer and SetContainer are concrete subtypes of AbstractContainer, each using a different data structure (Vector and Set) to store elements of type T.\nThe function print_container_info accepts any container that is a subtype of AbstractContainer and prints the type of elements inside the container.\n\n\n\nBenefits:\n\nFlexibility: You can create containers (or other structures) that work with a wide range of types without needing to explicitly define separate types for each use case.\nCode Reusability: By using parametric types, you avoid duplicating code for different types of containers or structures, making your codebase more maintainable.\nStatic Type Checking: Juliaâ€™s type system ensures that the correct type is used at compile-time, providing both flexibility and safety.\n\nParametric abstract types are useful for designing generic libraries, where behavior can be customized according to the types being used.\n\n\n\nParametric Functions\nYou can also define parametric functions that can work with different types:\n\nfunction identity(x::T) where T\n    return x\nend\n\nprintln(identity(5))  # Integer\nprintln(identity(3.14))  # Float64\nprintln(identity(\"Hello\"))  # String\n\n5\n3.14\nHello\n\n\nThe function identity works for any type T, and you can pass an Int, Float64, String, or any other type.\n\n\nConstraints on Parametric Functions\nYou can add constraints to parametric functions, ensuring that the parametric type parameter must be a subtype of a specific type. For example, you might want a function to only accept numerical types:\n\nfunction add_one(x::T) where T &lt;: Number\n    return x + 1\nend\n\nprintln(add_one(3))  # Valid: 3 + 1 = 4\nprintln(add_one(3.14))  # Valid: 3.14 + 1 = 4.14\nprintln(add_one(\"Hello\"))  # Error: String is not a subtype of Number\n\n4\n4.140000000000001\n\n\n\nMethodError: no method matching add_one(::String)\nThe function `add_one` exists, but no method is defined for this combination of argument types.\n\nClosest candidates are:\n  add_one(::T) where T&lt;:Number\n   @ Main In[48]:1\n\n\nStacktrace:\n [1] top-level scope\n   @ In[48]:7\n\n\n\nIn the above example, T is constrained to be a subtype of Number, so only numbers can be passed to the add_one function.\n\n\nQuiz\n\n\n\n\n\n\nQuiz: Parametric Types and Functions in Julia\n\n\n\n\n\n\n\nQuestion 1. What is a parametric type in Julia?\n\n\n\n\n\n\n\n\n  \n    \n      \n        \n    \nSelect an item\n\n    \n      \n      \n      \n        A special type used to store generic data.\n      \n    \n\n\n    \n      \n      \n      \n        A type that is parameterized by another type, allowing flexibility.\n      \n    \n\n\n    \n      \n      \n      \n        A type that only works with a single data type.\n      \n    \n\n\n    \n      \n      \n      \n        A type that can be instantiated with any number of arguments.\n      \n    \n\n\n\n    \n        \n      \n      \n    \n  \n\n\n\n\n\n\n\n\nQuestion 2. What does the following code define?\n\n\n\n\nstruct Pair{T, S}\n    first::T\n    second::S\nend\n\n\n\n\n\n\n  \n    \n      \n        \n    \nSelect an item\n\n    \n      \n      \n      \n        A union of two types, T and S.\n      \n    \n\n\n    \n      \n      \n      \n        A parametric type that enforces a specific type for each field.\n      \n    \n\n\n    \n      \n      \n      \n        A struct that pairs two values, where the types can vary.\n      \n    \n\n\n    \n      \n      \n      \n        A function that accepts two parameters of any type.\n      \n    \n\n\n\n    \n        \n      \n      \n    \n  \n\n\n\n\n\n\n\n\nQuestion 3. What is the output of the following code?\n\n\n\n\nabstract type AbstractContainer{T} end\n\nstruct VectorContainer{T} &lt;: AbstractContainer{T}\n    data::Vector{T}\nend\n\nvec = VectorContainer([1, 2, 3])\n\n\n\n\n\n\n  \n    \n      \n        \n    \nSelect an item\n\n    \n      \n      \n      \n        A parametric type defining a container for vectors of a specific type.\n      \n    \n\n\n    \n      \n      \n      \n        A type that can only contain integers.\n      \n    \n\n\n    \n      \n      \n      \n        A concrete container type for storing vectors of any type.\n      \n    \n\n\n    \n      \n      \n      \n        A generic type for any container.\n      \n    \n\n\n\n    \n        \n      \n      \n    \n  \n\n\n\n\n\n\n\n\nQuestion 4. What is the advantage of using parametric abstract types in Julia?\n\n\n\n\n\n\n\n\n  \n    \n      \n        \n    \nSelect an item\n\n    \n      \n      \n      \n        They make the code harder to read but more flexible.\n      \n    \n\n\n    \n      \n      \n      \n        They are used to limit the types that can be instantiated.\n      \n    \n\n\n    \n      \n      \n      \n        They provide the flexibility to create reusable abstractions with customizable types.\n      \n    \n\n\n    \n      \n      \n      \n        They allow type constraints to be added to functions.\n      \n    \n\n\n\n    \n        \n      \n      \n    \n  \n\n\n\n\n\n\n\n\nQuestion 5. What does the following function do?\n\n\n\n\nfunction add_one(x::T) where T &lt;: Number\n    return x + 1\nend\n\n\n\n\n\n\n  \n    \n      \n        \n    \nSelect an item\n\n    \n      \n      \n      \n        It adds one to a string and returns the result.\n      \n    \n\n\n    \n      \n      \n      \n        It adds one to any type.\n      \n    \n\n\n    \n      \n      \n      \n        It adds one to a number, but throws an error for non-numbers.\n      \n    \n\n\n    \n      \n      \n      \n        It adds one to any type, even strings.",
    "crumbs": [
      "Master 1",
      "Advanced Types"
    ]
  },
  {
    "objectID": "M1/advanced-types.html#type-stability-in-julia",
    "href": "M1/advanced-types.html#type-stability-in-julia",
    "title": "Advanced Types and Error Handling in Julia",
    "section": "Type Stability in Julia",
    "text": "Type Stability in Julia\nIn Julia, type stability is a key concept for writing efficient code. Type stability means that the type of a variable or expression can be determined at compile time, enabling the Julia compiler to optimize the code. When working with advanced types, such as parametric abstract types, itâ€™s important to ensure that your code remains type stable, as this allows Juliaâ€™s Just-In-Time (JIT) compiler to generate more efficient machine code.\n\nWhy is Type Stability Important?\nType instability can cause the JIT compiler to generate multiple versions of a function or method, which can degrade performance. Type stability, on the other hand, helps Julia avoid unnecessary runtime checks and ensures that the type of every variable is known before runtime.\nFor instance, if you define a function where the type of its output cannot be predicted based on the input types, Julia may have to fall back to a slower, more generic approach.\n\n\nExample of Type Instability and Stability\nLetâ€™s consider an example using parametric types:\n\nfunction sum_elements(arr::Vector{T}) where T\n    s = 0\n    for x in arr\n        s += x  # Type instability: T is not known to be a number\n    end\n    return s\nend\n\nsum_elements (generic function with 1 method)\n\n\nIn this case, the function sum_elements is type unstable because Julia cannot guarantee that T will always be a numeric type. This can lead to inefficiencies.\nNow, letâ€™s fix this by enforcing type stability:\n\nfunction sum_elements(arr::Vector{T}) where T &lt;: Number\n    s = zero(T)  # Start with the appropriate type for T\n    for x in arr\n        s += x\n    end\n    return s\nend\n\nsum_elements (generic function with 2 methods)\n\n\nIn this version, we restrict the type of T to be a subtype of Number, ensuring that the type of s is always numeric and enabling better performance through type stability.\n\n\nKey Points for Ensuring Type Stability\n\nUse specific type annotations whenever possible, especially with parametric types.\nAvoid mixing types that could lead to ambiguities in the functionâ€™s return type.\nAlways initialize variables with types that are known, such as using zero(T) for numeric types.\nWhen dealing with generic code, try to define methods that narrow the possible types of variables (e.g., T &lt;: Number).\n\nEnsuring type stability not only helps with performance but also aids in catching potential type errors early during development.\n\n\nQuiz\n\n\n\n\n\n\nQuiz: Type Stability in Julia\n\n\n\n\n\n\n\nQuestion 1. Why is type stability important in Julia?\n\n\n\n\n\n\n\n\n  \n    \n      \n        \n    \nSelect an item\n\n    \n      \n      \n      \n        It allows the Julia compiler to optimize code and avoid unnecessary runtime checks.\n      \n    \n\n\n    \n      \n      \n      \n        It prevents type errors from occurring in the code.\n      \n    \n\n\n    \n      \n      \n      \n        It forces the use of static typing in all functions.\n      \n    \n\n\n    \n      \n      \n      \n        It makes code easier to write and debug.\n      \n    \n\n\n\n    \n        \n      \n      \n    \n  \n\n\n\n\n\n\n\n\nQuestion 2. What is the issue with the following function in terms of type stability?\n\n\n\n\nfunction sum_elements(arr::Vector{T}) where T\n    s = 0\n    for x in arr\n        s += x  # Type instability: T is not known to be a number\n    end\n    return s\nend\n\n\n\n\n\n\n  \n    \n      \n        \n    \nSelect an item\n\n    \n      \n      \n      \n        The variable s is not initialized properly.\n      \n    \n\n\n    \n      \n      \n      \n        The function does not return anything.\n      \n    \n\n\n    \n      \n      \n      \n        The loop does not iterate over the array correctly.\n      \n    \n\n\n    \n      \n      \n      \n        The type of T is not restricted to numeric types, leading to type instability.\n      \n    \n\n\n\n    \n        \n      \n      \n    \n  \n\n\n\n\n\n\n\n\nQuestion 3. How is type stability ensured in the following corrected version of the code?\n\n\n\n\nfunction sum_elements(arr::Vector{T}) where T &lt;: Number\n    s = zero(T)  # Start with the appropriate type for T\n    for x in arr\n        s += x\n    end\n    return s\nend\n\n\n\n\n\n\n  \n    \n      \n        \n    \nSelect an item\n\n    \n      \n      \n      \n        By defining a default return type for the function.\n      \n    \n\n\n    \n      \n      \n      \n        By initializing s with a numeric zero value (zero(T)) and restricting T to Number.\n      \n    \n\n\n    \n      \n      \n      \n        By using an abstract type for the argument arr.\n      \n    \n\n\n    \n      \n      \n      \n        By ensuring that arr is always of type Vector{Int}.\n      \n    \n\n\n\n    \n        \n      \n      \n    \n  \n\n\n\n\n\n\n\n\nQuestion 4. What does type instability typically cause in Julia?\n\n\n\n\n\n\n\n\n  \n    \n      \n        \n    \nSelect an item\n\n    \n      \n      \n      \n        It allows Julia to use static typing for optimization.\n      \n    \n\n\n    \n      \n      \n      \n        It can cause the JIT compiler to generate multiple versions of a function, degrading performance.\n      \n    \n\n\n    \n      \n      \n      \n        It improves code readability and makes debugging easier.\n      \n    \n\n\n    \n      \n      \n      \n        It can lead to more efficient code execution.\n      \n    \n\n\n\n    \n        \n      \n      \n    \n  \n\n\n\n\n\n\n\n\nQuestion 5. Which of the following is a recommended strategy for ensuring type stability in Julia?\n\n\n\n\n\n\n\n\n  \n    \n      \n        \n    \nSelect an item\n\n    \n      \n      \n      \n        Always avoid parametric types in functions.\n      \n    \n\n\n    \n      \n      \n      \n        Use generic types in functions to handle various types without constraints.\n      \n    \n\n\n    \n      \n      \n      \n        Avoid using any type annotations for function arguments.\n      \n    \n\n\n    \n      \n      \n      \n        Use specific type annotations and initialize variables with known types.",
    "crumbs": [
      "Master 1",
      "Advanced Types"
    ]
  },
  {
    "objectID": "M1/advanced-types.html#type-conversion-and-promotion",
    "href": "M1/advanced-types.html#type-conversion-and-promotion",
    "title": "Advanced Types and Error Handling in Julia",
    "section": "Type Conversion and Promotion",
    "text": "Type Conversion and Promotion\nIn Julia, type conversion and promotion are mechanisms that allow for flexibility when working with different types, enabling smooth interactions and arithmetic between varying data types. Conversion changes the type of a value, while promotion ensures two values have a common type for an operation.\n\nType Conversion\nType conversion in Julia is typically achieved with the convert function, which tries to change a value from one type to another. For conversions between Float64 and Int, methods like round and floor are commonly used to handle fractional parts safely. To convert numbers to strings, use the string() function instead.\n\nprintln(round(Int, 3.14))   # Rounds 3.14 to the nearest integer, output: 3\nprintln(floor(Int, 3.14))   # Floors 3.14 to the nearest integer, output: 3\nprintln(convert(Float64, 5))  # Converts Int to Float64, output: 5.0\nprintln(string(123))         # Converts Int to String, output: \"123\"\n\n3\n3\n5.0\n123\n\n\nIn these examples:\n\nround rounds a Float64 to the nearest Int.\nfloor converts a Float64 to the nearest lower Int.\nConverting an Int to Float64 represents the integer as a floating-point number.\nstring() converts an integer to its string representation.\n\n\n\nAutomatic Conversion\nIn many cases, Julia will automatically convert types when it is unambiguous. For instance, you can directly assign an integer to a floating-point variable, and Julia will automatically convert it.\n\ny::Float64 = 10  # The integer 10 is automatically converted to 10.0 (Float64)\nprintln(y)       # Output: 10.0\n\n10.0\n\n\n\n\nType Promotion\nType promotion is used when combining two values of different types in an operation. Julia promotes values to a common type using the promote function, which returns values in their promoted type. This is useful when performing arithmetic on values of different types.\n\na, b = promote(3, 4.5)  # Promotes both values to Float64\nprintln(a)              # Output: 3.0\nprintln(b)              # Output: 4.5\nprintln(typeof(a))      # Output: Float64\nprintln(typeof(b))      # Output: Float64\n\n3.0\n4.5\nFloat64\nFloat64\n\n\nIn this example, promote converts both 3 (an Int) and 4.5 (a Float64) to Float64 so they can be added, subtracted, or multiplied without any type conflicts.\n\n\nSummary\n\nconvert(Type, value): Converts value to the specified Type, if possible.\npromote(x, y): Returns both x and y promoted to a common type.\nType promotion rules allow Julia to handle operations between different types smoothly, making the language both powerful and flexible for numerical and data processing tasks.\n\n\n\nQuiz\n\n\n\n\n\n\nQuiz: Type Conversion and Promotion in Julia\n\n\n\n\n\n\n\nQuestion 1. What does the convert function do in Julia?\n\n\n\n\n\n\n\n\n  \n    \n      \n        \n    \nSelect an item\n\n    \n      \n      \n      \n        It converts a value from one type to another, if possible.\n      \n    \n\n\n    \n      \n      \n      \n        It automatically promotes values to a common type.\n      \n    \n\n\n    \n      \n      \n      \n        It changes a value to a boolean type.\n      \n    \n\n\n    \n      \n      \n      \n        It converts numbers to strings.\n      \n    \n\n\n\n    \n        \n      \n      \n    \n  \n\n\n\n\n\n\n\n\nQuestion 2. What is the output of the following code?\n\n\n\n\nprintln(round(Int, 3.14))   # Rounds 3.14 to the nearest integer, output: 3\nprintln(floor(Int, 3.14))   # Floors 3.14 to the nearest integer, output: 3\nprintln(convert(Float64, 5))  # Converts Int to Float64, output: 5.0\nprintln(string(123))         # Converts Int to String, output: \"123\"\n\n\n\n\n\n\n  \n    \n      \n        \n    \nSelect an item\n\n    \n      \n      \n      \n        3, 3, 5.0, 123\n      \n    \n\n\n    \n      \n      \n      \n        5.0, 3, 5, '123'\n      \n    \n\n\n    \n      \n      \n      \n        3, 3.14, 5, '123'\n      \n    \n\n\n    \n      \n      \n      \n        3, 3, 5.0, '123'\n      \n    \n\n\n\n    \n        \n      \n      \n    \n  \n\n\n\n\n\n\n\n\nQuestion 3. What happens when an integer is assigned to a Float64 variable in Julia?\n\n\n\n\ny::Float64 = 10  # The integer 10 is automatically converted to 10.0 (Float64)\nprintln(y)       # Output: 10.0\n\n\n\n\n\n\n  \n    \n      \n        \n    \nSelect an item\n\n    \n      \n      \n      \n        Julia throws a type error because of the type mismatch.\n      \n    \n\n\n    \n      \n      \n      \n        The conversion needs to be done explicitly using convert.\n      \n    \n\n\n    \n      \n      \n      \n        The variable y will be set to the integer value of 10.\n      \n    \n\n\n    \n      \n      \n      \n        Julia automatically converts the integer to a Float64.\n      \n    \n\n\n\n    \n        \n      \n      \n    \n  \n\n\n\n\n\n\n\n\nQuestion 4. What does the promote function do in Julia?\n\n\n\n\na, b = promote(3, 4.5)  # Promotes both values to Float64\nprintln(a)              # Output: 3.0\nprintln(b)              # Output: 4.5\nprintln(typeof(a))      # Output: Float64\nprintln(typeof(b))      # Output: Float64\n\n\n\n\n\n\n  \n    \n      \n        \n    \nSelect an item\n\n    \n      \n      \n      \n        It converts values to strings for display.\n      \n    \n\n\n    \n      \n      \n      \n        It converts both values to integers.\n      \n    \n\n\n    \n      \n      \n      \n        It promotes two values to a common type for an operation.\n      \n    \n\n\n    \n      \n      \n      \n        It checks if two values have the same type.\n      \n    \n\n\n\n    \n        \n      \n      \n    \n  \n\n\n\n\n\n\n\n\nQuestion 5. What will happen if we try to add an Int and a String in Julia?\n\n\n\n\nprintln(3 + \"Hello\")  # Attempting to add Int and String\n\n\n\n\n\n\n  \n    \n      \n        \n    \nSelect an item\n\n    \n      \n      \n      \n        It will promote the number to a string.\n      \n    \n\n\n    \n      \n      \n      \n        It will throw a type error.\n      \n    \n\n\n    \n      \n      \n      \n        Julia will automatically convert both to a common type.\n      \n    \n\n\n    \n      \n      \n      \n        It will concatenate the string and the number.",
    "crumbs": [
      "Master 1",
      "Advanced Types"
    ]
  },
  {
    "objectID": "M1/advanced-types.html#union-types",
    "href": "M1/advanced-types.html#union-types",
    "title": "Advanced Types and Error Handling in Julia",
    "section": "Union Types",
    "text": "Union Types\nIn Julia, Union types are used to create variables or function arguments that can accept multiple types. This is particularly useful when you want to allow a function to work with multiple types without needing to write separate methods for each one.\n\nUsing Union Types\nA Union type is created by specifying a list of types within Union{}. This allows a variable to hold values of any type listed in the union.\n\n# Example of a Union type allowing both Int and Float64\nfunction process_number(x::Union{Int, Float64})\n    println(\"The input is: \", x)\nend\n\nprocess_number(5)       # Works with an Int\nprocess_number(3.14)    # Works with a Float64\n\nThe input is: 5\nThe input is: 3.14\n\n\nIn this example, process_number can accept both Int and Float64 types, making it versatile across multiple input types.\n\n\nPractical Use Cases for Union\nUnions are useful when you want a function or variable to be flexible about the types it accepts. For example, you may want to accept either an integer or a floating-point number in a calculation function. You can also use Union in type annotations to define fields in structs or arguments in functions that accept multiple types.\n\n# Example using Union to handle multiple types in a function\nfunction add_one(x::Union{Int, Float64})\n    return x + 1\nend\n\nprintln(add_one(3))     # Output: 4 (Int)\nprintln(add_one(2.5))   # Output: 3.5 (Float64)\n\n4\n3.5\n\n\nIn this example, add_one accepts both Int and Float64, enabling it to work flexibly with different numerical types.\n\n\nQuiz\n\n\n\n\n\n\nQuiz: Union Types in Julia\n\n\n\n\n\n\n\nQuestion 1. What is a Union type in Julia?\n\n\n\n\n\n\n\n\n  \n    \n      \n        \n    \nSelect an item\n\n    \n      \n      \n      \n        A built-in function for type conversion.\n      \n    \n\n\n    \n      \n      \n      \n        A type that allows a variable to accept multiple types.\n      \n    \n\n\n    \n      \n      \n      \n        A type that restricts a variable to only one type.\n      \n    \n\n\n    \n      \n      \n      \n        A type that can only accept floating-point numbers.\n      \n    \n\n\n\n    \n        \n      \n      \n    \n  \n\n\n\n\n\n\n\n\nQuestion 2. What is the output of the following code?\n\n\n\n\nfunction process_number(x::Union{Int, Float64})\n    println(\"The input is: \", x)\nend\n\nprocess_number(5)       # Works with an Int\nprocess_number(3.14)    # Works with a Float64\n\n\n\n\n\n\n  \n    \n      \n        \n    \nSelect an item\n\n    \n      \n      \n      \n        The input is: 5, The input is: 3\n      \n    \n\n\n    \n      \n      \n      \n        The input is: 3.14, The input is: 5\n      \n    \n\n\n    \n      \n      \n      \n        The input is: 5, The input is: 3.0\n      \n    \n\n\n    \n      \n      \n      \n        The input is: 5, The input is: 3.14\n      \n    \n\n\n\n    \n        \n      \n      \n    \n  \n\n\n\n\n\n\n\n\nQuestion 3. Which of the following scenarios would benefit from using a Union type?\n\n\n\n\n# Example using Union to handle multiple types in a function\nfunction add_one(x::Union{Int, Float64})\n    return x + 1\nend\n\nprintln(add_one(3))     # Output: 4 (Int)\nprintln(add_one(2.5))   # Output: 3.5 (Float64)\n\n\n\n\n\n\n  \n    \n      \n        \n    \nSelect an item\n\n    \n      \n      \n      \n        When a function accepts only integers.\n      \n    \n\n\n    \n      \n      \n      \n        When a function needs to accept both integers and floating-point numbers.\n      \n    \n\n\n    \n      \n      \n      \n        When a function is only designed to accept floating-point numbers.\n      \n    \n\n\n    \n      \n      \n      \n        When there is a strict requirement to accept a specific type.\n      \n    \n\n\n\n    \n        \n      \n      \n    \n  \n\n\n\n\n\n\n\n\nQuestion 4. What happens when a value of a type not listed in the Union is passed to a function?\n\n\n\n\nfunction process_number(x::Union{Int, Float64})\n    println(\"The input is: \", x)\nend\n\nprocess_number(\"Hello\")  # Trying to pass a String\n\n\n\n\n\n\n  \n    \n      \n        \n    \nSelect an item\n\n    \n      \n      \n      \n        It will throw a MethodError because String is not part of the Union.\n      \n    \n\n\n    \n      \n      \n      \n        It will throw a TypeError due to the type mismatch.\n      \n    \n\n\n    \n      \n      \n      \n        It will automatically convert the string to an integer.\n      \n    \n\n\n    \n      \n      \n      \n        It will work without issue because String is compatible with Union.\n      \n    \n\n\n\n    \n        \n      \n      \n    \n  \n\n\n\n\n\n\n\n\nQuestion 5. How does the add_one function handle both Int and Float64 types?\n\n\n\n\nfunction add_one(x::Union{Int, Float64})\n    return x + 1\nend\n\nprintln(add_one(3))     # Output: 4 (Int)\nprintln(add_one(2.5))   # Output: 3.5 (Float64)\n\n\n\n\n\n\n  \n    \n      \n        \n    \nSelect an item\n\n    \n      \n      \n      \n        It requires type checking before execution.\n      \n    \n\n\n    \n      \n      \n      \n        It only works for Float64 types.\n      \n    \n\n\n    \n      \n      \n      \n        It works for both types without needing separate methods.\n      \n    \n\n\n    \n      \n      \n      \n        It throws an error for Int but works for Float64.",
    "crumbs": [
      "Master 1",
      "Advanced Types"
    ]
  },
  {
    "objectID": "M1/advanced-types.html#special-types",
    "href": "M1/advanced-types.html#special-types",
    "title": "Advanced Types and Error Handling in Julia",
    "section": "Special Types",
    "text": "Special Types\nJulia provides several special types to handle different programming needs, including types for flexible assignments, missing values, and functions without specific return values.\n\nNothing\nThe Nothing type represents the absence of a meaningful value, commonly used when a function does not return anything. Itâ€™s similar to void in other programming languages. Functions in Julia that do not return a value explicitly return nothing by default.\n\n# Example of a function that returns `Nothing`\nfunction print_message(msg::String)\n    println(msg)\n    return nothing  # Explicitly returns `nothing`\nend\n\nresult = print_message(\"Hello!\")  # Returns `nothing`\nprintln(result === nothing)       # Output: true\n\nHello!\ntrue\n\n\nUsing Nothing is useful when you want to indicate that a function has no specific return value, yet you still want to call it as part of a larger program flow.\n\n\nAny\nAny is the most general type in Julia and serves as the root of Juliaâ€™s type hierarchy. Declaring a variable or argument as Any allows it to hold values of any type, making it versatile but potentially less performant since Julia cannot infer a specific type.\n\n# Example of using `Any` as a type\nfunction describe(value::Any)\n    println(\"Value: \", value)\n    println(\"Type: \", typeof(value))\nend\n\ndescribe(42)         # Works with Int\ndescribe(\"Hello\")    # Works with String\ndescribe(3.14)       # Works with Float64\n\nValue: 42\nType: Int64\nValue: Hello\nType: String\nValue: 3.14\nType: Float64\n\n\nUsing Any can be beneficial when handling inputs of unpredictable types, such as in data processing functions where input data may be heterogeneous.\n\n\nMissing\nThe Missing type is used to represent missing or unknown data, especially useful in data analysis. Juliaâ€™s missing value is an instance of Missing and can be assigned to variables or included in data structures like arrays and tables. Operations with missing generally propagate missing to indicate the presence of missing data.\n\n# Example of using `missing` in an array\ndata = [1, 2, missing, 4, 5]\n\n# Check for missing values in the array\nfor item in data\n    if item === missing\n        println(\"Missing data detected.\")\n    else\n        println(\"Value: \", item)\n    end\nend\n\nValue: 1\nValue: 2\nMissing data detected.\nValue: 4\nValue: 5\n\n\nThe missing value enables handling of incomplete data in Julia programs without causing errors, making it especially useful in fields like data science.\nIn data analysis, you often want to perform calculations or operations on data while ignoring missing values. Julia provides the skipmissing function, which creates an iterator that skips over any missing values in a collection.\n\nusing Statistics\n\n# Example array with missing values\ndata = [1, 2, missing, 4, 5, missing, 7]\n\n# Summing values while skipping missing entries\nsum_no_missing = sum(skipmissing(data))\nprintln(\"Sum without missing values: \", sum_no_missing)  # Output: 19\n\n# Calculating the mean while skipping missing values\nmean_no_missing = mean(skipmissing(data))\nprintln(\"Mean without missing values: \", mean_no_missing)  # Output: 3.8\n\nSum without missing values: 19\nMean without missing values: 3.8\n\n\nIn this example:\n\nskipmissing(data) returns an iterator that excludes missing values from the data array.\nUsing sum(skipmissing(data)) and mean(skipmissing(data)) allows us to calculate the sum and mean, respectively, without considering any missing entries.\n\nThe skipmissing function is especially useful when handling datasets with incomplete data, enabling accurate calculations without manually filtering out missing values.\n\n\nQuiz\n\n\n\n\n\n\nQuiz: Special Types in Julia\n\n\n\n\n\n\n\nQuestion 1. What does the Nothing type represent in Julia?\n\n\n\n\n\n\n\n\n  \n    \n      \n        \n    \nSelect an item\n\n    \n      \n      \n      \n        It is used for undefined variables.\n      \n    \n\n\n    \n      \n      \n      \n        It is a placeholder for missing data.\n      \n    \n\n\n    \n      \n      \n      \n        It represents the absence of a meaningful value.\n      \n    \n\n\n    \n      \n      \n      \n        It is a special type for numeric values.\n      \n    \n\n\n\n    \n        \n      \n      \n    \n  \n\n\n\n\n\n\n\n\nQuestion 2. What is the result of calling the following function in Julia?\n\n\n\n\n# Example of a function that returns `Nothing`\nfunction print_message(msg::String)\n    println(msg)\n    return nothing  # Explicitly returns `nothing`\nend\n\nresult = print_message(\"Hello!\")\nprintln(result === nothing)  # Output: true\n\n\n\n\n\n\n  \n    \n      \n        \n    \nSelect an item\n\n    \n      \n      \n      \n        The function throws an error because nothing cannot be returned.\n      \n    \n\n\n    \n      \n      \n      \n        nothing is returned and the output is true.\n      \n    \n\n\n    \n      \n      \n      \n        nothing is returned but the output is false.\n      \n    \n\n\n    \n      \n      \n      \n        The function returns a string 'nothing'.\n      \n    \n\n\n\n    \n        \n      \n      \n    \n  \n\n\n\n\n\n\n\n\nQuestion 3. What is the advantage of using Any as a type in Julia?\n\n\n\n\n# Example of using `Any` as a type\nfunction describe(value::Any)\n    println(\"Value: \", value)\n    println(\"Type: \", typeof(value))\nend\n\ndescribe(42)         # Works with Int\ndescribe(\"Hello\")    # Works with String\ndescribe(3.14)       # Works with Float64\n\n\n\n\n\n\n  \n    \n      \n        \n    \nSelect an item\n\n    \n      \n      \n      \n        It allows variables to hold any type, making the code flexible.\n      \n    \n\n\n    \n      \n      \n      \n        It prevents runtime errors related to data types.\n      \n    \n\n\n    \n      \n      \n      \n        It increases performance by restricting the type of variable.\n      \n    \n\n\n    \n      \n      \n      \n        It makes type inference more precise.\n      \n    \n\n\n\n    \n        \n      \n      \n    \n  \n\n\n\n\n\n\n\n\nQuestion 4. What does the following code do in Julia?\n\n\n\n\ndata = [1, 2, missing, 4, 5]\nfor item in data\n    if item === missing\n        println(\"Missing data detected.\")\n    else\n        println(\"Value: \", item)\n    end\nend\n\n\n\n\n\n\n  \n    \n      \n        \n    \nSelect an item\n\n    \n      \n      \n      \n        It throws an error when encountering missing data.\n      \n    \n\n\n    \n      \n      \n      \n        It replaces missing data with a default value.\n      \n    \n\n\n    \n      \n      \n      \n        It sums all the values and skips missing ones.\n      \n    \n\n\n    \n      \n      \n      \n        It checks for missing values and prints a message for each.\n      \n    \n\n\n\n    \n        \n      \n      \n    \n  \n\n\n\n\n\n\n\n\nQuestion 5. What is the purpose of the skipmissing function in Julia?\n\n\n\n\nusing Statistics\n\n# Example array with missing values\ndata = [1, 2, missing, 4, 5, missing, 7]\n\n# Summing values while skipping missing entries\nsum_no_missing = sum(skipmissing(data))\nprintln(\"Sum without missing values: \", sum_no_missing)  # Output: 19\n\n# Calculating the mean while skipping missing values\nmean_no_missing = mean(skipmissing(data))\nprintln(\"Mean without missing values: \", mean_no_missing)  # Output: 3.8\n\n\n\n\n\n\n  \n    \n      \n        \n    \nSelect an item\n\n    \n      \n      \n      \n        It replaces missing values with 0.\n      \n    \n\n\n    \n      \n      \n      \n        It prints out the number of missing values.\n      \n    \n\n\n    \n      \n      \n      \n        It raises an error if missing values are encountered.\n      \n    \n\n\n    \n      \n      \n      \n        It creates an iterator that skips missing values during computations.\n      \n    \n\n\n\n    \n        \n      \n      \n    \n  \n\n\n\n\n\n\n\n\nQuestion 6. What is the main use of the Missing type in Julia?\n\n\n\n\n# Example of using `missing` in an array\ndata = [1, 2, missing, 4, 5]\n\n# Check for missing values in the array\nfor item in data\n    if item === missing\n        println(\"Missing data detected.\")\n    else\n        println(\"Value: \", item)\n    end\nend\n\n\n\n\n\n\n  \n    \n      \n        \n    \nSelect an item\n\n    \n      \n      \n      \n        To represent variables with no value assigned.\n      \n    \n\n\n    \n      \n      \n      \n        To hold any type of data including missing entries.\n      \n    \n\n\n    \n      \n      \n      \n        To represent missing or unknown data in a collection.\n      \n    \n\n\n    \n      \n      \n      \n        To prevent errors when dealing with Nothing.",
    "crumbs": [
      "Master 1",
      "Advanced Types"
    ]
  },
  {
    "objectID": "M1/advanced-types.html#errors-and-exception-handling",
    "href": "M1/advanced-types.html#errors-and-exception-handling",
    "title": "Advanced Types and Error Handling in Julia",
    "section": "Errors and Exception Handling",
    "text": "Errors and Exception Handling\nJulia provides a powerful framework for managing and handling errors, which helps in writing robust programs. Error handling in Julia involves various built-in error types and mechanisms, including throw for raising errors and try/catch blocks for handling exceptions.\n\nCommon Error Types in Julia\nJulia has several built-in error types that are commonly used:\n\nArgumentError: Raised when a function receives an argument that is inappropriate or out of expected range.\nBoundsError: Occurs when trying to access an index that is out of bounds for an array or collection.\nDivisionByZeroError: Triggered when an attempt is made to divide by zero.\nIOError: Raised for errors related to input/output operations, such as reading from or writing to files.\n\n\n\nRaising Errors with throw\nIn Julia, you can explicitly raise an error using the throw function. This is useful for defining custom error conditions in your code. To throw an error, call throw with an instance of an error type:\n\nfunction divide(a, b)\n    if b == 0\n        throw(DivisionByZeroError(\"Division by zero is not allowed\"))\n    end\n    return a / b\nend\n\ndivide (generic function with 1 method)\n\n\nIn this example, the function divide will throw a DivisionByZeroError if the second argument b is zero, making the function safer and more robust.\n\n\nHandling Errors with try/catch\nJulia provides try/catch blocks for managing exceptions gracefully. Code within a try block runs until an error is encountered. If an error is thrown, control passes to the catch block, where you can handle the error.\nHereâ€™s an example of using try/catch with the divide function:\n\ntry\n    println(divide(10, 0))  # Will raise an error\ncatch e\n    println(\"Error: \", e)  # Handles the error\nend\n\nError: UndefVarError(:DivisionByZeroError, Main)\n\n\nIn this example: - If divide(10, 0) raises an error, the program catches it and prints a custom message instead of stopping execution. - The variable e holds the error, which can be printed or used for further handling.\n\n\nUsing finally for Cleanup\nIn Julia, finally is a block used in conjunction with try and catch to ensure that certain cleanup actions are executed regardless of whether an error occurs or not. This is useful for tasks like closing files, releasing resources, or resetting variables that need to be done after the execution of a try-catch block.\nThe code inside the finally block is always executed, even if an exception is thrown and caught. This makes it ideal for situations where you need to guarantee that some actions occur after the main code runs, like resource deallocation.\n\nSyntax:\n\ntry\n    # Code that might throw an error\ncatch exception\n    # Code to handle the error\nfinally\n    # Cleanup code that will always run\nend\n\n\n\nExample:\n\nfunction safe_file_read(filename::String)\n    file = nothing\n    try\n        file = open(filename, \"r\")\n        data = read(file, String)\n        return data\n    catch e\n        println(\"An error occurred: \", e)\n    finally\n        if file !== nothing\n            close(file)\n            println(\"File closed.\")\n        end\n    end\nend\n\n# Test with a valid file\nprintln(safe_file_read(\"example.txt\"))\n\n# Test with an invalid file\nprintln(safe_file_read(\"nonexistent.txt\"))\n\nFile closed.\n\nAn error occurred: SystemError(\"opening file \\\"nonexistent.txt\\\"\", 2, nothing)\nnothing\n\n\n\n\nExplanation:\n\nThe finally block ensures that the file is always closed after reading, even if an error occurs (e.g., file not found, read error).\nIf the open operation is successful, the finally block will still execute and close the file, ensuring proper resource management.\nIf an exception is thrown in the try block (like a non-existent file), it will be caught and handled by the catch block, but the finally block will still execute to close the file (if opened).\n\n\n\nUse Cases for finally:\n\nClosing files or network connections.\nReleasing resources (e.g., database connections, locks).\nResetting the program state to a known clean state.\n\n\n\n\nQuiz\n\n\n\n\n\n\nQuiz: Errors and Exception Handling in Julia\n\n\n\n\n\n\n\nQuestion 1. Which error type is raised when an index is out of bounds in an array?\n\n\n\n\n\n\n\n\n  \n    \n      \n        \n    \nSelect an item\n\n    \n      \n      \n      \n        ArgumentError\n      \n    \n\n\n    \n      \n      \n      \n        IOError\n      \n    \n\n\n    \n      \n      \n      \n        DivisionByZeroError\n      \n    \n\n\n    \n      \n      \n      \n        BoundsError\n      \n    \n\n\n\n    \n        \n      \n      \n    \n  \n\n\n\n\n\n\n\n\nQuestion 2. What does the following code do in Julia?\n\n\n\n\nfunction divide(a, b)\n    if b == 0\n        throw(DivisionByZeroError(\"Division by zero is not allowed\"))\n    end\n    return a / b\nend\n\n\n\n\n\n\n  \n    \n      \n        \n    \nSelect an item\n\n    \n      \n      \n      \n        It performs division and returns the result.\n      \n    \n\n\n    \n      \n      \n      \n        It raises an ArgumentError when a or b is invalid.\n      \n    \n\n\n    \n      \n      \n      \n        It raises a DivisionByZeroError when b equals 0.\n      \n    \n\n\n    \n      \n      \n      \n        It throws a BoundsError if a or b are not numbers.\n      \n    \n\n\n\n    \n        \n      \n      \n    \n  \n\n\n\n\n\n\n\n\nQuestion 3. What happens when the following try/catch block is executed?\n\n\n\n\ntry\n    println(divide(10, 0))  # Will raise an error\ncatch e\n    println(\"Error: \", e)  # Handles the error\nend\n\n\n\n\n\n\n  \n    \n      \n        \n    \nSelect an item\n\n    \n      \n      \n      \n        The error is caught and a custom error message is printed.\n      \n    \n\n\n    \n      \n      \n      \n        The program prints the result of the division.\n      \n    \n\n\n    \n      \n      \n      \n        The program silently ignores the error.\n      \n    \n\n\n    \n      \n      \n      \n        The program throws an error and stops execution.\n      \n    \n\n\n\n    \n        \n      \n      \n    \n  \n\n\n\n\n\n\n\n\nQuestion 4. What is the purpose of the finally block in Juliaâ€™s exception handling?\n\n\n\n\n\n\n\n\n  \n    \n      \n        \n    \nSelect an item\n\n    \n      \n      \n      \n        To perform the main logic of the program.\n      \n    \n\n\n    \n      \n      \n      \n        To rethrow any errors that are caught.\n      \n    \n\n\n    \n      \n      \n      \n        To catch all errors and handle them.\n      \n    \n\n\n    \n      \n      \n      \n        To ensure that cleanup code runs regardless of whether an error occurs.\n      \n    \n\n\n\n    \n        \n      \n      \n    \n  \n\n\n\n\n\n\n\n\nQuestion 5. What is the output of the following code?\n\n\n\n\nfunction safe_file_read(filename::String)\n    file = nothing\n    try\n        file = open(filename, \"r\")\n        data = read(file, String)\n        return data\n    catch e\n        println(\"An error occurred: \", e)\n    finally\n        if file !== nothing\n            close(file)\n            println(\"File closed.\")\n        end\n    end\nend\n\n# Test with a valid file\nprintln(safe_file_read(\"example.txt\"))\n\n# Test with an invalid file\nprintln(safe_file_read(\"nonexistent.txt\"))\n\n\n\n\n\n\n  \n    \n      \n        \n    \nSelect an item\n\n    \n      \n      \n      \n        The program prints the error but skips file closing.\n      \n    \n\n\n    \n      \n      \n      \n        The program raises an error and does not close the file.\n      \n    \n\n\n    \n      \n      \n      \n        The program tries to read a file, catches errors, and always closes the file.\n      \n    \n\n\n    \n      \n      \n      \n        The program prints data from the file and closes it.\n      \n    \n\n\n\n    \n        \n      \n      \n    \n  \n\n\n\n\n\n\n\n\nQuestion 6. Which of the following is an appropriate use case for the finally block?\n\n\n\n\n\n\n\n\n  \n    \n      \n        \n    \nSelect an item\n\n    \n      \n      \n      \n        Ensuring a file is closed after reading, regardless of errors.\n      \n    \n\n\n    \n      \n      \n      \n        To handle errors and return a value from the finally block.\n      \n    \n\n\n    \n      \n      \n      \n        To catch all exceptions without handling them.\n      \n    \n\n\n    \n      \n      \n      \n        To prevent specific types of errors from being raised.",
    "crumbs": [
      "Master 1",
      "Advanced Types"
    ]
  },
  {
    "objectID": "M1/index.html",
    "href": "M1/index.html",
    "title": "Julia Master 1 course",
    "section": "",
    "text": "This course is adressed to the students of the Master 1 â€œEconomÃ©trie, Statistiquesâ€ of Toulouse School of Economics. It is part of the topic Software for Data science. The Julia course is composed of 5 slots of 3 hours. In this course, we introduce the Julia ecosystem, we present the Julia programming language and some relevant packages.\n\n\n\n\n Back to top",
    "crumbs": [
      "Master 1"
    ]
  },
  {
    "objectID": "M1/syntax.html",
    "href": "M1/syntax.html",
    "title": "Julia Syntax Essentials and Variable Scoping",
    "section": "",
    "text": "In this page, we present the fundamentals of Julia syntax. If you want a cheatsheet, please visit this page.",
    "crumbs": [
      "Master 1",
      "Syntax"
    ]
  },
  {
    "objectID": "M1/syntax.html#basics",
    "href": "M1/syntax.html#basics",
    "title": "Julia Syntax Essentials and Variable Scoping",
    "section": "Basics",
    "text": "Basics\n\nAssignment\nIn Julia, variables are assigned using the = operator:\n\nx = 5\ny = \"Hello, Julia!\"\n\nJulia is dynamically typed, which means variables do not require explicit type declarations. Types are inferred based on the assigned value.\n\ntypeof(x)\n\nInt64\n\n\n\ntypeof(y)\n\nString\n\n\n\n\nUnicode Characters\nJulia supports Unicode characters, allowing you to use symbols and mathematical notation in variable names and operations. For instance, Greek letters and symbols like Î± and Î² can be typed using the tab completion shortcut:\n\nType \\alpha, then press Tab to get Î±.\nType \\beta, then press Tab to get Î².\n\n\nÎ± = 10\nÎ² = Î± + 5\n\nUnicode is especially helpful when writing mathematical code, making it more readable and expressive.\n\n\nComments\nComments are written with the # symbol. Julia also supports multiline comments with #= and =#:\n\n# This is a single-line comment\n\n#= \nThis is a \nmultiline comment \n=#\n\n\n\nPrint\nTo display output in Julia, you can use the println function:\n\nprintln(\"Hello, Julia!\")  # Prints: Hello, Julia!\nprintln(\"The value of Î± is \", Î±)\n\nHello, Julia!\nThe value of Î± is 10\n\n\nPrinting output is helpful for debugging and tracking variable values in your code.\n\n\nThe @show Macro\nJulia also provides the @show macro, which is particularly useful for debugging. It prints both the name of a variable and its value in the following format: variable_name = value.\n\nx = 42\n@show x   # Prints: x = 42\n\nx = 42\n\n\nYou can also use @show with multiple variables or expressions:\n\na = 10\nb = 20\n@show a + b  # Prints: a + b = 30\n@show a, b   # Prints: a = 10, b = 20\n\na + b = 30\n(a, b) = (10, 20)\n\n\nThe @show macro is convenient for quick checks on variable values and expressions without needing to construct strings manually.",
    "crumbs": [
      "Master 1",
      "Syntax"
    ]
  },
  {
    "objectID": "M1/syntax.html#control-flows-and-logical-operators",
    "href": "M1/syntax.html#control-flows-and-logical-operators",
    "title": "Julia Syntax Essentials and Variable Scoping",
    "section": "Control Flows and Logical Operators",
    "text": "Control Flows and Logical Operators\nControl flow in Julia is managed through conditional statements and loops. Logical operators allow for conditions to be combined or negated.\n\nConditional Statements\nJulia supports if, elseif, and else for conditional checks:\n\nx = 10\n\nif x &gt; 5\n    println(\"x is greater than 5\")\nelseif x == 5\n    println(\"x is equal to 5\")\nelse\n    println(\"x is less than 5\")\nend\n\nx is greater than 5\n\n\nIn Julia, blocks for if, elseif, and else are closed with end. Indentation is not required by syntax but is recommended for readability.\n\n\n\n\n\n\nTip\n\n\n\nYou can follow the Blue Style conventions for Julia code. If you want to format your code you can use the package JuliaFormatter.jl.\n\n\n\n\nTernary Operator\nFor simple conditional assignments, Julia has a ternary operator ? ::\n\ny = (x &gt; 5) ? \"Greater\" : \"Not greater\"\nprintln(y)  # Outputs \"Greater\" if x &gt; 5, otherwise \"Not greater\"\n\nGreater\n\n\n\n\nLogical Operators\nJulia includes standard logical operators to build more complex conditions:\n\n&& for logical AND\n|| for logical OR\n! for logical NOT\n\n\na = true\nb = false\n\nprintln(a && b)  # Outputs: false\nprintln(a || b)  # Outputs: true\nprintln(!a)      # Outputs: false\n\nfalse\ntrue\nfalse\n\n\n\n\nLoops\nJulia provides for and while loops for iterative tasks.\nFor Loop: The for loop iterates over a range or collection:\n\nfor i in 1:5\n    println(i)\nend\n\n1\n2\n3\n4\n5\n\n\nThis loop prints numbers from 1 to 5. The range 1:5 uses Juliaâ€™s : operator to create a sequence.\n\n\n\n\n\n\nNote\n\n\n\nThe for construct can loop on any iterable object. Visit the documentation for details.\n\n\nWhile Loop: The while loop executes as long as a condition is true:\n\ncount = 1\n\nwhile count &lt;= 5\n    println(count)\n    count += 1\nend\n\n1\n2\n3\n4\n5\n\n\nThis loop will print numbers from 1 to 5 by incrementing count each time.\n\n\nBreaking and Continuing\nJulia also has break and continue for loop control.\n\nbreak exits the loop completely.\ncontinue skips the current iteration and moves to the next one.\n\n\nfor i in 1:5\n    if i == 3\n        continue  # Skips the number 3\n    end\n    println(i)\nend\n\n1\n2\n4\n5\n\n\n\nfor i in 1:5\n    if i == 4\n        break  # Exits the loop when i is 4\n    end\n    println(i)\nend\n\n1\n2\n3\n\n\nThese control flows and logical operators allow for flexibility in executing conditional logic and repeated operations in Julia.",
    "crumbs": [
      "Master 1",
      "Syntax"
    ]
  },
  {
    "objectID": "M1/syntax.html#arithmetics",
    "href": "M1/syntax.html#arithmetics",
    "title": "Julia Syntax Essentials and Variable Scoping",
    "section": "Arithmetics",
    "text": "Arithmetics\nJulia supports a variety of arithmetic operations that can be performed on numeric types. Below are some of the most commonly used operations:\n\nBasic Arithmetic Operations\nYou can perform basic arithmetic operations using standard operators:\n\nAddition: +\nSubtraction: -\nMultiplication: *\nDivision: / (returns a floating-point result) and // (returns a rational number)\n\n\na = 10\nb = 3\n\nsum = a + b           # Outputs: 13\ndifference = a - b    # Outputs: 7\nproduct = a * b       # Outputs: 30\nquotient = a / b      # Outputs: 3.3333...\nrational = a // b     # Outputs: 10//3\n\n\n\nModulo Operation\nThe modulo operator % returns the remainder of a division operation. It is useful for determining if a number is even or odd, or for wrapping around values.\n\nmodulus_result = a % b  # Outputs: 1 (remainder of 10 divided by 3)\n\n1\n\n\n\n\nExponentiation\nYou can perform exponentiation using the ^ operator.\n\nb = a ^ 2          # Outputs: 100 (10 squared)\n\n100\n\n\n\n\nUsing Arithmetic in Control Flow\nYou can combine arithmetic operations with control flow statements. For example, you can use the modulo operation to check if a number is even or odd:\n\nif a % 2 == 0\n    println(\"$a is even\")\nelse\n    println(\"$a is odd\")\nend\n\n10 is even\n\n\n\n\nSummary of Arithmetic Operations\n\n\n\nOperation\nSymbol\nExample\nResult\n\n\n\n\nAddition\n+\n5 + 3\n8\n\n\nSubtraction\n-\n5 - 3\n2\n\n\nMultiplication\n*\n5 * 3\n15\n\n\nDivision\n/\n5 / 2\n2.5\n\n\nModulo\n%\n5 % 2\n1\n\n\nExponentiation\n^\n2 ^ 3\n8\n\n\n\nThese arithmetic operations can be combined and nested to perform complex calculations as needed.",
    "crumbs": [
      "Master 1",
      "Syntax"
    ]
  },
  {
    "objectID": "M1/syntax.html#functions",
    "href": "M1/syntax.html#functions",
    "title": "Julia Syntax Essentials and Variable Scoping",
    "section": "Functions",
    "text": "Functions\nJulia offers flexible ways to define functions, with options for positional arguments, keyword arguments, optional arguments with default values, and variable-length arguments. Letâ€™s explore each of these in detail.\n\nDefining Functions\nFunctions in Julia can be defined using either the function keyword or the assignment syntax.\n\n# Using the `function` keyword\nfunction add(a, b)\n    return a + b\nend\n\n# Using assignment syntax\nmultiply(a, b) = a * b\n\nprintln(add(2, 3))         # Outputs: 5\nprintln(multiply(2, 3))    # Outputs: 6\n\n5\n6\n\n\n\n\nPositional and Keyword Arguments\nIn Julia, functions can take both positional arguments and keyword arguments.\n\nPositional Arguments: These are listed first in the parameter list and must be provided in the correct order when the function is called. Positional arguments can have default values, but itâ€™s not required.\nKeyword Arguments: Keyword arguments are specified after a semicolon (;) in the parameter list. These arguments must be provided by name when calling the function. Like positional arguments, keyword arguments can have default values, but they donâ€™t have to.\n\n\nfunction greet(name; punctuation = \"!\")\n    return \"Hello, \" * name * punctuation\nend\n\nprintln(greet(\"Alice\"))                     # Outputs: \"Hello, Alice!\"\nprintln(greet(\"Alice\", punctuation = \"?\"))   # Outputs: \"Hello, Alice?\"\n\nHello, Alice!\nHello, Alice?\n\n\nIn this example, punctuation is a keyword argument with a default value of \"!\". You could also define a keyword argument without a default value if needed.\n\n\nVariable Number of Arguments\nJulia functions can accept an arbitrary number of arguments using the splatting operator .... These arguments are gathered into a tuple.\n\nfunction sum_all(args...)\n    total = 0\n    for x in args\n        total += x\n    end\n    return total\nend\n\nprintln(sum_all(1, 2, 3, 4))  # Outputs: 10\n\n10\n\n\n\n\nDefault Values for Optional Arguments\nIn Julia, you can assign default values to both positional and keyword arguments. When the function is called without specifying a value for an argument with a default, the default value is used.\n\nfunction power(base, exponent=2)\n    return base ^ exponent\nend\n\nprintln(power(3))      # Outputs: 9 (since exponent defaults to 2)\nprintln(power(3, 3))   # Outputs: 27\n\n9\n27\n\n\n\n\nMultiple Optional Positional Arguments\nWhen a function has multiple optional positional arguments, Julia will use the default values for any arguments not provided, allowing flexible combinations.\n\nfunction calculate(a=1, b=2, c=3)\n    return a + b * c\nend\n\nprintln(calculate())        # Outputs: 7 (1 + 2 * 3)\nprintln(calculate(5))       # Outputs: 11 (5 + 2 * 3)\nprintln(calculate(5, 4))    # Outputs: 17 (5 + 4 * 3)\nprintln(calculate(5, 4, 1)) # Outputs: 9  (5 + 4 * 1)\n\n7\n11\n17\n9\n\n\nHereâ€™s how the argument combinations work:\n\ncalculate() uses all default values: a=1, b=2, c=3.\ncalculate(5) overrides a, leaving b and c as defaults.\ncalculate(5, 4) overrides a and b, leaving c as the default.\ncalculate(5, 4, 1) overrides all arguments.\n\nThis flexibility makes it easy to call functions with varying levels of detail without explicitly specifying each parameter.\n\n\nMutation and the Bang ! Convention\nIn Julia, functions that modify or mutate their arguments typically end with a !, following the â€œbangâ€ convention. This is not enforced by the language but is a widely followed convention in Julia to indicate mutation.\n\nfunction add_one!(array)\n    for i in eachindex(array)\n        array[i] += 1\n    end\nend\n\narr = [1, 2, 3]\nadd_one!(arr)\n@show arr  # Outputs: arr = [2, 3, 4]\n\narr = [2, 3, 4]\n\n\nIn this example, add_one! modifies the elements of the array arr. By convention, the ! at the end of the function name indicates that the function mutates its input.\n\n\nReturn Values\nIn Julia, functions automatically return the last evaluated expression. However, you can use the return keyword to explicitly specify the output if needed.\n\nfunction multiply(a, b)\n    a * b  # Returns the result of a * b\nend\n\nmultiply (generic function with 1 method)",
    "crumbs": [
      "Master 1",
      "Syntax"
    ]
  },
  {
    "objectID": "M1/syntax.html#scoping-and-closure",
    "href": "M1/syntax.html#scoping-and-closure",
    "title": "Julia Syntax Essentials and Variable Scoping",
    "section": "Scoping and Closure",
    "text": "Scoping and Closure\nIn Julia, scoping rules determine the visibility and lifetime of variables. Understanding scope and closures is essential for writing efficient and error-free code.\n\nVariable Scope\nScope in Julia refers to the region of code where a variable is accessible. There are two primary scopes: global and local.\n\nGlobal Scope: Variables defined at the top level of a module or script are in the global scope and can be accessed from anywhere in that file. However, modifying global variables from within functions is generally discouraged.\n\n\nglobal_var = 10\n\nfunction access_global()\n    return global_var\nend\n\naccess_global()  # Outputs: 10\n\n10\n\n\n\nLocal Scope: Variables defined within a function or a block (e.g., loops or conditionals) have local scope and cannot be accessed outside of that block.\n\n\nfunction local_scope_example()\n    local_var = 5\n    return local_var\nend\n\nprintln(local_scope_example())  # Outputs: 5\nprintln(local_var)  # This would cause an error, as local_var is not accessible here\n\n5\n\n\nLoadError: UndefVarError: `local_var` not defined in `Main`\nSuggestion: check for spelling errors or missing imports.\nUndefVarError: `local_var` not defined in `Main`\nSuggestion: check for spelling errors or missing imports.\n\nStacktrace:\n [1] top-level scope\n   @ In[30]:7\n\n\n\n\nScope of Variables in for Loops\nIn Julia, a for loop does create a new local scope for its loop variable when inside a function or another local scope. This means that a variable used as the loop variable will not overwrite an existing global variable with the same name in that context.\nHereâ€™s an example:\n\ni = 10  # Define a global variable `i`\n\nfor i = 1:3\n    println(i)  # Prints 1, 2, and 3\nend\n\nprintln(\"Outside loop: i = \", i)  # Outputs: 10\n\n1\n2\n3\nOutside loop: i = 10\n\n\nIn this case, the initial value of i (10) is not affected by the loop because the for loop has its own local scope for i. After the loop completes, the global variable i retains its original value (10), demonstrating that the for loop did not alter it.\nHowever, if this code were inside a function, i would be entirely scoped within that functionâ€™s local environment, meaning any loop variables would only affect other variables within the function itself.\n\n\nNested Scopes\nJulia allows for nested functions, which can access variables in their enclosing scopes. This is known as lexical scoping.\n\nfunction outer_function(x)\n    y = 2\n    function inner_function(z)\n        return x + y + z\n    end\n    return inner_function\nend\n\nclosure = outer_function(3)\nclosure(4)  # Outputs: 9 (3 + 2 + 4)\n\n9\n\n\nIn this example, inner_function forms a closure over the variables x and y, retaining access to them even after outer_function has finished executing.\n\n\nClosures\nA closure is a function that captures variables from its surrounding lexical scope, allowing the function to use these variables even after the scope where they were defined has ended. Closures are especially useful for creating customized functions or â€œfunction factories.â€\n\nExample: Using a Global Variable vs.Â Capturing a Variable in a Closure\nTo illustrate the difference between referencing a global variable and capturing a variable in a closure, letâ€™s first create a function that uses a global variable:\n\nfactor = 2\n\nfunction multiply_by_global(x)\n    return x * factor\nend\n\nprintln(multiply_by_global(5))  # Outputs: 10\n\n# Update the global variable `factor`\nfactor = 3\nprintln(multiply_by_global(5))  # Outputs: 15 (factor is now 3)\n\n10\n15\n\n\nIn this example, multiply_by_global uses the global variable factor, so whenever factor is updated, the result of calling multiply_by_global changes.\n\n\nExample: Capturing a Variable in a Closure\nNow, letâ€™s use a closure to capture the factor variable inside a function. Here, the captured value of factor remains fixed at the time the closure was created, regardless of changes to the variable afterward.\n\nfunction make_multiplier(factor)\n    return (x) -&gt; x * factor  # Returns a closure that captures `factor`\nend\n\ndouble = make_multiplier(2)   # `factor` is captured as 2 in this closure\ntriple = make_multiplier(3)   # `factor` is captured as 3 in this closure\n\nprintln(double(5))  # Outputs: 10\nprintln(triple(5))  # Outputs: 15\n\n# Even if we change `factor` globally, it doesn't affect the closure\nfactor = 10\nprintln(double(5))  # Still outputs: 10\nprintln(triple(5))  # Still outputs: 15\n\n10\n15\n10\n15\n\n\nIn this example, make_multiplier returns a function that captures the factor variable when the closure is created. This means that double will always multiply by 2, and triple will always multiply by 3, regardless of any subsequent changes to factor.\n\n\n\nSummary\nUsing closures in Julia allows you to â€œlock inâ€ the values of variables from an outer scope at the time of the closureâ€™s creation. This differs from referencing global variables directly, where any changes to the variable are reflected immediately. Closures are particularly useful for creating function factories or callbacks that need to retain specific values independently of changes in the global scope.\nUnderstanding scope is crucial for performance in Julia. Defining variables within a local scope, such as inside functions, can lead to more efficient code execution. Global variables can lead to performance penalties due to type instability.\nIn summary, scoping rules in Julia allow for clear management of variable accessibility and lifespan, while closures enable powerful programming patterns by capturing the context in which they are created. Understanding these concepts is key to writing effective Julia code.",
    "crumbs": [
      "Master 1",
      "Syntax"
    ]
  },
  {
    "objectID": "M1/syntax.html#exercices",
    "href": "M1/syntax.html#exercices",
    "title": "Julia Syntax Essentials and Variable Scoping",
    "section": "Exercices",
    "text": "Exercices\n\nExercise 1: Temperature Converter\nWrite a function convert_temperature that takes a temperature value and a keyword argument unit that can either be \"C\" for Celsius or \"F\" for Fahrenheit. The function should convert the temperature to the other unit and return the converted value. Use a conditional statement to determine the conversion formula:\n\nIf the unit is \"C\", convert to Fahrenheit using the formula: \n  F = C \\times \\frac{9}{5} + 32\n\nIf the unit is \"F\", convert to Celsius using the formula: \n  C = (F - 32) \\times \\frac{5}{9}\n\n\nExample Output:\nprintln(convert_temperature(100, unit=\"C\"))  # Outputs: 212.0\nprintln(convert_temperature(32, unit=\"F\"))    # Outputs: 0.0\n\n\n\n\n\n\nTo go further for Exercise 1: Temperature Converter\n\n\n\n\n\nIf the unit provided is not \"C\" or \"F\", you can raise an error using the throw statement along with ArgumentError. This way, you can inform the user that the input is invalid.\n\n\n\n\n\n\n\n\n\nCorrection of Exercise 1: Temperature Converter\n\n\n\n\n\n\nfunction convert_temperature(value; unit)\n    if unit == \"C\"\n        return value * 9/5 + 32  # Convert Celsius to Fahrenheit\n    elseif unit == \"F\"\n        return (value - 32) * 5/9  # Convert Fahrenheit to Celsius\n    else\n        throw(ArgumentError(\"Unit must be 'C' or 'F'\"))\n    end\nend\n\nprintln(convert_temperature(100, unit=\"C\"))  # Outputs: 212.0\nprintln(convert_temperature(32, unit=\"F\"))    # Outputs: 0.0\n\n212.0\n0.0\n\n\n\n\n\n\n\nExercise 2: Factorial Function with Closure\nCreate a function make_factorial that returns a closure. This closure should compute the factorial of a number. The closure should capture a variable that keeps track of the number of times it has been called. When the closure is called, it should return the factorial of the number and the call count.\nExample Output:\nfactorial_closure = make_factorial()\nresult, count = factorial_closure(5)\nprintln(result)  # Outputs: 120\nresult, count = factorial_closure(3)\nprintln(result)  # Outputs: 6\nprintln(\"Function called \", count, \" times\")  # Outputs: 2 times\n\n\n\n\n\n\nHint Exercise 2: Factorial Function with Closure\n\n\n\n\n\nWhen returning the results from the closure, you can return a pair of values by creating a tuple. In Julia, tuples are created using parentheses, like this: (value1, value2).\n\n\n\n\n\n\n\n\n\nCorrection of Exercise 2: Factorial Function with Closure\n\n\n\n\n\n\nfunction make_factorial()\n    counter = 0 # Variable to keep track of calls\n    function factorial(n::Int)\n        y = 1\n        for i âˆˆ 2:n\n            y *= i \n        end\n        counter += 1\n        return y, counter\n    end\n    return factorial \nend\n\nfactorial_closure = make_factorial()\nresult, count = factorial_closure(5)\nprintln(result)  # Outputs: 120\nresult, count = factorial_closure(3)\nprintln(result)  # Outputs: 6\nprintln(\"Function called \", count, \" times\")  # Outputs: 2 times\n\n120\n6\nFunction called 2 times\n\n\n\n\n\n\n\nExercise 3: Filter Even Numbers\nWrite a function filter_even that takes an array of integers as input and returns a new array containing only the even numbers from the input array. Use a loop and a conditional statement to check each number.\nAdditionally, implement a helper function is_even that checks if a number is even. Use the filter_even function to filter an array of numbers, and print the result.\nExample Output:\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\neven_numbers = filter_even(numbers)\nprintln(even_numbers)  # Outputs: [2, 4, 6, 8, 10]\n\n\n\n\n\n\nHint for Exercise 3: Filter Even Numbers\n\n\n\n\n\nTo add elements to an array in Julia, use the push! function. This function takes two arguments: the array you want to modify and the element to add to that array.\n\n\n\n\n\n\n\n\n\nCorrection of Exercise 3: Filter Even Numbers\n\n\n\n\n\n\nfunction is_even(x)\n    return x % 2 == 0\nend\n\nfunction filter_even(numbers)\n    even_numbers = []\n    for number in numbers\n        if is_even(number)\n            push!(even_numbers, number)\n        end\n    end\n    return even_numbers\nend\n\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\neven_numbers = filter_even(numbers)\nprintln(even_numbers)  # Outputs: [2, 4, 6, 8, 10]\n\nAny[2, 4, 6, 8, 10]\n\n\n\n\n\n\n\nExercise Instructions\n\nFor each exercise, implement the required functions in a new Julia script or interactive session.\nTest your functions with different inputs to ensure they work as expected.\nComment on your code to explain the logic behind each part, especially where you utilize control flow and scope.",
    "crumbs": [
      "Master 1",
      "Syntax"
    ]
  },
  {
    "objectID": "M1/why_julia.html",
    "href": "M1/why_julia.html",
    "title": "Why Julia?",
    "section": "",
    "text": "Paraphrasing Why Julia?, Julia is a fast and expressive programming language, delivering the speed of C++ and Fortran together with the productivity of Python, MATLAB, and R. This fundamentally empowers diverse teams to work together to develop and deploy performant programs at scale by solving the two language problem.",
    "crumbs": [
      "Master 1",
      "Why Julia?"
    ]
  },
  {
    "objectID": "M1/why_julia.html#benefits-of-julia",
    "href": "M1/why_julia.html#benefits-of-julia",
    "title": "Why Julia?",
    "section": "Benefits of Julia",
    "text": "Benefits of Julia\nJulia combines the speed of low-level languages like C++ and Fortran with the productivity of high-level languages like Python, MATLAB, and R. Here are some of its key benefits:\n\nHigh Performance: Optimized for native compilation, multi-threading, and GPU compute, Julia can achieve speeds close to C++.\nHigh Productivity: Expressive and dynamic, Julia is up to 100x faster than traditional high-level languages.\nEase of Use: Clear and simple syntax, making it easy to learn, write, and analyze.\nComposability: Packages are designed to work seamlessly together and with custom code.\nInteroperability: Julia integrates well with languages like Python, R, C++, and Java.\nUnified Language: Supports both prototyping and deployment, solving the two-language problem.\nRich Ecosystem: More than 10,000 registered packages and a large community of contributors.",
    "crumbs": [
      "Master 1",
      "Why Julia?"
    ]
  },
  {
    "objectID": "M1/why_julia.html#key-users-of-julia",
    "href": "M1/why_julia.html#key-users-of-julia",
    "title": "Why Julia?",
    "section": "Key Users of Julia",
    "text": "Key Users of Julia\n\nPharmaceuticals: AstraZeneca, Merck, Pfizer\nTechnology: Amazon, Apple, Google\nFinance: BlackRock, Federal Reserve Bank of New York\nSpace: NASA, INPE\nEnergy: Los Alamos, Mitsubishi Electric\nRobotics: MIT, UC Berkeley",
    "crumbs": [
      "Master 1",
      "Why Julia?"
    ]
  },
  {
    "objectID": "M1/why_julia.html#the-two-language-problem",
    "href": "M1/why_julia.html#the-two-language-problem",
    "title": "Why Julia?",
    "section": "The Two-Language Problem",
    "text": "The Two-Language Problem\nTraditionally, programming required both a high-level, slower language for prototyping and a low-level, faster language for production, causing inefficiencies. Julia unifies these two needs into one language, allowing:\n\n\n\n\n\n\n\n\nAspect\nHigh-Level Language (e.g., Python)\nLow-Level Language (e.g., C++)\n\n\n\n\nPros\nEasy to write and read\nFast in production\n\n\nCons\nSlow in production\nComplex, lengthy code\n\n\nJuliaâ€™s Solution\nCombines ease of high-level with speed of low-level, eliminating the need for separate languages for research and production.",
    "crumbs": [
      "Master 1",
      "Why Julia?"
    ]
  },
  {
    "objectID": "M1/why_julia.html#comparisons",
    "href": "M1/why_julia.html#comparisons",
    "title": "Why Julia?",
    "section": "Comparisons",
    "text": "Comparisons\nIf you want to know for instance the date of the first public release, the price and the names of the creators of numerical-analysis softwares, please visite the Wikipedia page.\nJulia is made for scientific computing as shown by the table below which compares some languages in terms of differential equation solvers. For more details visit this page.\n  \nYou can find here cheatsheets. One interesting is the comparison with Python and R.\n  \nOne goal of Julia is to be efficient and high-level. This is illustrated by the following figure given by the Mandelbrot benchmark project.",
    "crumbs": [
      "Master 1",
      "Why Julia?"
    ]
  },
  {
    "objectID": "M1/basic-types.html",
    "href": "M1/basic-types.html",
    "title": "Basic Types and Data Structures in Julia",
    "section": "",
    "text": "In Julia, understanding the fundamental types and data structures is essential for efficient coding and problem-solving. This page provides an introduction to some of the basic types in Julia, including integers, floating-point numbers, strings, and composite types like arrays and tuples. Weâ€™ll also explore more advanced data structures and their practical uses.\nYouâ€™ll learn about:\nWhether youâ€™re a beginner or looking to deepen your understanding of Juliaâ€™s type system, this page will help you get familiar with the core building blocks for handling data efficiently in Julia.",
    "crumbs": [
      "Master 1",
      "Basic Types"
    ]
  },
  {
    "objectID": "M1/basic-types.html#introduction-to-types-in-julia",
    "href": "M1/basic-types.html#introduction-to-types-in-julia",
    "title": "Basic Types and Data Structures in Julia",
    "section": "Introduction to Types in Julia",
    "text": "Introduction to Types in Julia\nJulia is a dynamically typed language, meaning that variable types are determined at runtime. However, Julia also supports strong typing, which means that types are important and can be explicitly specified when needed. Understanding types in Julia is essential for writing efficient code, as the language uses Just-In-Time (JIT) compilation to optimize based on variable types.\n\nDynamic Typing\nIn Julia, variables do not require explicit type declarations. The type of a variable is inferred based on the value assigned to it.\n\nx = 10          # x is inferred to be of type Int64\ny = 3.14        # y is inferred to be of type Float64\nz = \"Hello\"     # z is inferred to be of type String\n\nEven though Julia automatically infers types, you can still explicitly specify them when necessary, particularly for performance optimization or for ensuring that a variable matches a particular type.\n\n\nStrong Typing\nWhile Julia uses dynamic typing, it is strongly typed. This means that Julia will enforce type constraints on operations, and will raise errors when an operation is attempted with incompatible types.\n\na = 5           # Integer\nb = 2.0         # Float\n\n# This will raise an error because you can't add an integer and a string\nc = a + \"hello\"  # Error: cannot convert string to Int\n\n\nMethodError: no method matching +(::Int64, ::String)\nThe function `+` exists, but no method is defined for this combination of argument types.\n\nClosest candidates are:\n  +(::Any, ::Any, ::Any, ::Any...)\n   @ Base operators.jl:596\n  +(::Real, ::Complex{Bool})\n   @ Base complex.jl:322\n  +(::Integer, ::AbstractChar)\n   @ Base char.jl:247\n  ...\n\n\nStacktrace:\n [1] top-level scope\n   @ In[842]:5\n\n\n\nWe see from the error message that we can add an Integer and a Char: +(::Integer, ::AbstractChar) is a valid operation. This is because a Char can be treated as an integer in Julia.\n\nc = 'a'      # Char\nc + 128448   # This will work because Char can be treated as an integer\n\n'ğŸ˜¡': Unicode U+1F621 (category So: Symbol, other)\n\n\nJulia allows flexibility compared to statically typed languages like C or Java, but still ensures that operations make sense for the types involved.\n\n\nType System and Performance\nThe type system in Julia plays a key role in performance. By inferring or specifying types, Juliaâ€™s JIT compiler can optimize code for specific data types, leading to faster execution. For example, when types are known at compile time, Julia can generate machine code tailored for the specific types involved.\nJuliaâ€™s type system also supports abstract types, allowing for more flexible and generic code, as well as parametric types that let you define functions or types that work with any data type.\n\n\nSummary\n\nJulia is dynamically typed but enforces strong typing.\nTypes are inferred from the values assigned to variables.\nJulia optimizes performance based on types, making type information crucial.",
    "crumbs": [
      "Master 1",
      "Basic Types"
    ]
  },
  {
    "objectID": "M1/basic-types.html#basic-types",
    "href": "M1/basic-types.html#basic-types",
    "title": "Basic Types and Data Structures in Julia",
    "section": "Basic Types",
    "text": "Basic Types\nJulia has several basic (or primitive) types that are fundamental to working with the language. These include numerical types, characters, and strings. Understanding these types is crucial as they form the building blocks for more complex data structures.\n\nCommon Basic Types\n\nInt: Represents integer values. Julia has multiple types of integers, such as Int8, Int16, Int32, and Int64 depending on the desired size. By default, Int refers to the most appropriate integer type for the system (usually Int64 on modern systems).\nFloat64: Represents floating-point numbers with double precision.\nString: Represents sequences of characters.\nBool: Represents Boolean values, i.e., true or false.\nChar: Represents individual Unicode characters.\n\n\n\nExample Usage of Basic Types\n\n# Integer type (default is Int64)\na = 42         # a is of type Int64\n\n# Float type (default is Float64)\nb = 3.14       # b is of type Float64\n\n# String type\nc = \"Hello\"    # c is of type String\n\n# Boolean type\nd = true       # d is of type Bool\n\n# Char type\ne = 'Î±'        # e is of type Char\n\nThese basic types are often used for simple calculations and conditionals. Julia allows operations between different types, but it will raise an error if the types are incompatible.",
    "crumbs": [
      "Master 1",
      "Basic Types"
    ]
  },
  {
    "objectID": "M1/basic-types.html#collections-and-data-structures",
    "href": "M1/basic-types.html#collections-and-data-structures",
    "title": "Basic Types and Data Structures in Julia",
    "section": "Collections and Data Structures",
    "text": "Collections and Data Structures\n\nArrays, Vectors, and Matrices\nIn Julia, arrays are fundamental data structures that can hold elements of any type. Arrays can be one-dimensional (vectors) or two-dimensional (matrices), and they can hold data of various types.\n\nCreating an Array:\n\n\narr = [1, 2, 3, 4]  # A simple 1D array (vector)\n\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4\n\n\n\nmatrix = [1 2 3; 4 5 6]  # A 2D array (matrix)\n\n2Ã—3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n\n\n\nAccessing Array Elements:\n\n\narr[1]   # Access the first element of the array\n\n1\n\n\n\nmatrix[2, 3]  # Access the element in the second row, third column\n\n6\n\n\n\nSlicing of Vectors and Matrices\nYou can extract slices (sub-arrays) of vectors and matrices in Julia. The slicing syntax allows you to access specific portions of an array.\n\nSlicing a vector:\n\n\narr[2:4]  # Extracts elements from index 2 to 4: [2, 3, 4]\n\n3-element Vector{Int64}:\n 2\n 3\n 4\n\n\n\nSlicing a matrix:\n\n\nmatrix[1, :]   # Extracts the first row: [1, 2, 3]\n\n3-element Vector{Int64}:\n 1\n 2\n 3\n\n\n\nmatrix[:, 2]   # Extracts the second column: [2, 5]\n\n2-element Vector{Int64}:\n 2\n 5\n\n\n\n\nMutation of Arrays\nArrays in Julia are mutable, meaning their elements can be changed after creation. The .= operator is commonly used to apply element-wise operations.\n\nModify an individual element:\n\n\narr[2] = 99  # Change the second element to 99\n\n99\n\n\n\nElement-wise operation with .=:\n\n\narr .+= 10  # Adds 10 to each element of the array, resulting in [11, 12, 13, 14]\n\n4-element Vector{Int64}:\n  11\n 109\n  13\n  14\n\n\n\nmatrix .*= 2  # Multiplies each element of the matrix by 2, resulting in [2 4 6; 8 10 12]\n\n2Ã—3 Matrix{Int64}:\n 2   4   6\n 8  10  12\n\n\n\nPush an element into an array (mutates the array by adding a new element):\n\n\npush!(arr, 40)  # Adds 40 to the end of the array\n\n5-element Vector{Int64}:\n  11\n 109\n  13\n  14\n  40\n\n\n\nPop an element from an array (removes the last element):\n\n\npop!(arr)  # Removes the last element, which is 40 in this case\n\n40\n\n\n\n\nSpecial Arrays\nJulia has built-in functions to create arrays with predefined values:\n\nCreate an array of zeros:\n\n\nzeros(3)  # Creates an array of zeros with 3 elements: [0.0, 0.0, 0.0]\n\n3-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n\n\n\nCreate an array of ones:\n\n\nones(2, 3)  # Creates a 2x3 matrix filled with ones: [1.0 1.0 1.0; 1.0 1.0 1.0]\n\n2Ã—3 Matrix{Float64}:\n 1.0  1.0  1.0\n 1.0  1.0  1.0\n\n\n\n\n\nDictionaries (Dict)\nA Dict in Julia is an associative collection that maps keys to values. This allows for efficient lookups, insertions, and deletions based on unique keys.\n\nCreating a Dictionary:\n\n\nd = Dict(\"name\" =&gt; \"Alice\", \"age\" =&gt; 25)\n\nDict{String, Any} with 2 entries:\n  \"name\" =&gt; \"Alice\"\n  \"age\"  =&gt; 25\n\n\nThis creates a dictionary where \"name\" maps to \"Alice\" and \"age\" maps to 25.\n\nAccessing Values:\n\nYou can access values in a dictionary using their corresponding keys:\n\nd[\"name\"]  # Outputs: \"Alice\"\n\n\"Alice\"\n\n\n\nAdding and Updating Values:\n\nTo add a new key-value pair or update an existing one, you can use the following syntax:\n\nd[\"location\"] = \"Paris\"  # Adds a new key-value pair\nd[\"age\"] = 26            # Updates the value associated with the key \"age\"\ndisplay(d)\n\nDict{String, Any} with 3 entries:\n  \"name\"     =&gt; \"Alice\"\n  \"location\" =&gt; \"Paris\"\n  \"age\"      =&gt; 26\n\n\n\nRemoving Key-Value Pairs:\n\nTo remove a key-value pair, use the delete! function:\n\ndelete!(d, \"location\")\n\nDict{String, Any} with 2 entries:\n  \"name\" =&gt; \"Alice\"\n  \"age\"  =&gt; 26\n\n\n\nIteration over Key-Value Pairs:\n\nYou can iterate through the keys, values, or pairs in a dictionary using keys, values, and pairs respectively:\n\nfor (k, v) in pairs(d)\n    println(\"Key: $k, Value: $v\")\nend\n\nKey: name, Value: Alice\nKey: age, Value: 26\n\n\n\n\nTuples and Named Tuples\n\nBasic usage of Tuples and Named Tuples\n\nTuple is an ordered collection of elements, which can hold elements of different types.\n\n\nt = (1, \"Julia\", true)  # A tuple with three elements\n\n(1, \"Julia\", true)\n\n\n\nNamedTuple is a special kind of tuple where elements are associated with names (keys).\n\n\nnt = (name = \"Alice\", age = 25)  # A NamedTuple with named fields\n\n(name = \"Alice\", age = 25)\n\n\nYou can access the elements by their name:\n\nnt.name  # Access the field 'name' of the NamedTuple, returns \"Alice\"\n\n\"Alice\"\n\n\n\nMutation of a Tuple: Tuples are immutable, so attempting to change their elements will result in an error.\n\n\nt[1] = 99  # Trying to modify a tuple element will result in an error\n\nLoadError: MethodError: no method matching setindex!(::Tuple{Int64, String, Bool}, ::Int64, ::Int64)\nThe function `setindex!` exists, but no method is defined for this combination of argument types.\nMethodError: no method matching setindex!(::Tuple{Int64, String, Bool}, ::Int64, ::Int64)\nThe function `setindex!` exists, but no method is defined for this combination of argument types.\n\nStacktrace:\n [1] top-level scope\n   @ In[867]:1\n\n\nThe above line will raise an error because tuples are immutable in Julia, and their elements cannot be modified after creation.\n\n\nTuples in Function\nIn Julia, tuples and named tuples play an important role in function definitions and return values.\n\nPositional and Keyword Arguments:\n\nWhen defining functions with a variable number of arguments, Julia uses tuples to capture positional arguments and named tuples for keyword arguments:\n\nfunction example_function(args...; kwargs...)\n    println(\"Positional arguments type: \", typeof(args))\n    println(\"Keyword arguments type: \", typeof(kwargs))\n    return kwargs\nend\n\nkw = example_function(1, 2, 3; name=\"Alice\", age=30)\n\nPositional arguments type: Tuple{Int64, Int64, Int64}\nKeyword arguments type: Base.Pairs{Symbol, Any, Tuple{Symbol, Symbol}, @NamedTuple{name::String, age::Int64}}\n\n\nIn this example, args is of type Tuple, containing all positional arguments, while kwargs is based on a NamedTuple, containing all keyword arguments. The arguments are captured using the args... and kwargs... syntax. The kwargs argument is actually a â€˜Base.Pairsâ€™:\n\nkw\n\npairs(::NamedTuple) with 2 entries:\n  :name =&gt; \"Alice\"\n  :age  =&gt; 30\n\n\n\nprintln(\"Type of kw: \", typeof(kw))\nprintln(kw isa Base.Pairs)\nprintln(kw isa AbstractDict)\nprintln(\"Keys: \", keys(kw))\nprintln(\"Values: \", values(kw))\nprintln(\"Pairs: \", pairs(kw))\nprintln(\"kx[:name]: \", kw[:name])\nprintln(\"kx[:age]: \", kw[:age])\n\nType of kw: Base.Pairs{Symbol, Any, Tuple{Symbol, Symbol}, @NamedTuple{name::String, age::Int64}}\ntrue\ntrue\nKeys: (:name, :age)\nValues: (name = \"Alice\", age = 30)\nPairs: Base.Pairs{Symbol, Any, Tuple{Symbol, Symbol}, @NamedTuple{name::String, age::Int64}}(:name =&gt; \"Alice\", :age =&gt; 30)\nkx[:name]: Alice\nkx[:age]: 30\n\n\nActually, the values are a NamedTuple:\n\ntypeof(values(kw))\n\n@NamedTuple{name::String, age::Int64}\n\n\nContrary to a Dict, you cannot add entries to a Base.Pairs:\n\nkw[:height] = 5.9\n\nLoadError: MethodError: no method matching setindex!(::@NamedTuple{name::String, age::Int64}, ::Float64, ::Symbol)\nThe function `setindex!` exists, but no method is defined for this combination of argument types.\nMethodError: no method matching setindex!(::@NamedTuple{name::String, age::Int64}, ::Float64, ::Symbol)\nThe function `setindex!` exists, but no method is defined for this combination of argument types.\n\nStacktrace:\n [1] setindex!(v::@Kwargs{name::String, age::Int64}, value::Float64, key::Symbol)\n   @ Base.Iterators ./iterators.jl:325\n [2] top-level scope\n   @ In[872]:1\n\n\n\nReturning Tuples:\n\nIn Julia, when a function returns multiple values separated by commas, they are automatically returned as a tuple:\n\nfunction return_multiple_values()\n    return 1, \"Julia\", true\nend\n\nresult = return_multiple_values()\nprintln(\"Result type: \", typeof(result))\n\nResult type: Tuple{Int64, String, Bool}\n\n\nSo, return_multiple_values() returns a tuple with three elements.",
    "crumbs": [
      "Master 1",
      "Basic Types"
    ]
  },
  {
    "objectID": "M1/basic-types.html#composite-types",
    "href": "M1/basic-types.html#composite-types",
    "title": "Basic Types and Data Structures in Julia",
    "section": "Composite Types",
    "text": "Composite Types\n\nIntroduction to struct\nIn Julia, you can define your own custom data types using the struct keyword. Composite types are user-defined types that group together different pieces of data into one object. A struct is a great way to create a type that can represent a complex entity with multiple fields.\n\nCreating a custom struct:\n\n\n# Define a simple struct for a point in 2D space\nstruct Point\n    x::Float64\n    y::Float64\nend\n\nHere, we created a Point struct with two fields: x and y, both of which are of type Float64.\n\nCreating an instance of a struct:\n\n\np = Point(3.0, 4.0)  # Creates a Point with x = 3.0 and y = 4.0\n\nPoint(3.0, 4.0)\n\n\n\nAccessing fields of a struct:\n\n\np.x  # Access the 'x' field of the Point instance\np.y  # Access the 'y' field of the Point instance\n\n4.0\n\n\nYou can access the fields of a struct directly using dot notation, as shown above.\n\nGet the names of the fields:\n\n\nfieldnames(Point)  # Returns the names of the fields in the Point struct\n\n(:x, :y)\n\n\n\n\nMutability of struct\nIn Julia, structs are immutable by default, meaning once you create an instance of a struct, its fields cannot be changed. However, you can create mutable structs by using the mutable struct keyword, which allows modification of field values after creation.\n\nCreating a mutable struct:\n\n\nmutable struct MutablePoint\n    x::Float64\n    y::Float64\nend\n\nNow you can modify the fields of MutablePoint instances after they are created.\n\nmp = MutablePoint(1.0, 2.0)\nmp.x = 3.0  # Modify the 'x' field\n\n\n\nExample: struct for a Circle\nWe can create a more complex type, such as a Circle, which has a center represented by a Point and a radius:\n\nstruct Circle\n    center::Point\n    radius::Float64\nend\n\n\nCreating an instance of Circle:\n\n\nc = Circle(Point(0.0, 0.0), 5.0)  # Create a circle with center (0, 0) and radius 5\n\nCircle(Point(0.0, 0.0), 5.0)\n\n\n\nAccessing fields of a nested struct:\n\n\nc.center.x  # Access the x field of the center of the circle\nc.center.y  # Access the y field of the center of the circle\nc.radius    # Access the radius of the circle\n\n\n\nConclusion\nIn Julia, struct allows you to create complex custom types that can hold different types of data. By default, structs are immutable, but you can use mutable struct if you need to change the data after creation. This is useful for organizing and managing related data in your programs.",
    "crumbs": [
      "Master 1",
      "Basic Types"
    ]
  },
  {
    "objectID": "M1/basic-types.html#exercises",
    "href": "M1/basic-types.html#exercises",
    "title": "Basic Types and Data Structures in Julia",
    "section": "Exercises",
    "text": "Exercises\n\nExercise 1: Creating a Shape System\nCreate a system to represent different geometric shapes (like a Rectangle, Circle, and Point) using the following requirements:\n\nDefine a Point struct with x and y coordinates of type Float64.\nDefine a Rectangle struct with fields length and width of type Float64. Use the Point struct to represent the bottom-left corner of the rectangle.\nDefine a Circle struct with a Point for the center and a radius of type Float64.\nWrite a function area(shape) that computes the area of the given shape:\n\nThe area of a rectangle is length * width.\nThe area of a circle is Ï€ * radius^2.\n\n\n\n\n\n\n\n\nHint for Exercise 1:\n\n\n\n\n\n\nUse struct to define Point, Rectangle, and Circle.\nUse dot notation to access the fields of the structs.\nUse conditional logic (e.g., typeof()) to handle different shapes in the area function.\nFor the circle, use Ï€ = 3.141592653589793.\n\n\n\n\n\n\n\n\n\n\nCorrection of Exercise 1:\n\n\n\n\n\n\n# Define the Point struct\nstruct Point\n    x::Float64\n    y::Float64\nend\n\n# Define the Rectangle struct\nstruct Rectangle\n    bottom_left::Point\n    length::Float64\n    width::Float64\nend\n\n# Define the Circle struct\nstruct Circle\n    center::Point\n    radius::Float64\nend\n\n# Function to calculate the area\nfunction area(shape)\n    if typeof(shape) == Rectangle\n        return shape.length * shape.width\n    elseif typeof(shape) == Circle\n        return Ï€ * shape.radius^2\n    else\n        throw(ArgumentError(\"Unsupported shape\"))\n    end\nend\n\n# Example usage\np1 = Point(0.0, 0.0)\nr1 = Rectangle(p1, 3.0, 4.0)\nc1 = Circle(p1, 5.0)\n\nprintln(\"Area of rectangle: \", area(r1))  # Should print 12.0\nprintln(\"Area of circle: \", area(c1))     # Should print 78.53981633974483\n\nArea of rectangle: 12.0\nArea of circle: 78.53981633974483\n\n\n\n\n\n\n\nExercise 2: Working with Complex Numbers and Arrays\n\nCreate two complex numbers z1 and z2 of type Complex{Float64}.\nWrite a function add_complex(z1, z2) that adds two complex numbers and returns the result.\nCreate an array of complex numbers and use the map function to add 2.0 to the real part of each complex number.\nCreate a function max_real_part that returns the complex number with the largest real part from an array of complex numbers.\n\n\n\n\n\n\n\nHint for Exercise 2:\n\n\n\n\n\n\nUse the Complex{T} type to create complex numbers.\nYou can access the real and imaginary parts of a complex number with real(z) and imag(z).\nUse the map function to apply a transformation to each element of an array.\nCompare the real parts of the complex numbers using real(z) to find the maximum.\n\n\n\n\n\n\n\n\n\n\nCorrection of Exercise 2:\n\n\n\n\n\n\n# Create two complex numbers\nz1 = Complex{Float64}(3.0, 4.0)  # z1 = 3.0 + 4.0im\nz2 = Complex{Float64}(1.0, 2.0)  # z2 = 1.0 + 2.0im\n\n# Function to add two complex numbers\nfunction add_complex(z1, z2)\n    return z1 + z2\nend\n\n# Add 2.0 to the real part of each complex number in an array\narr = [Complex{Float64}(3.0, 4.0), Complex{Float64}(1.0, 2.0), Complex{Float64}(5.0, 6.0)]\nnew_arr = map(z -&gt; Complex(real(z) + 2.0, imag(z)), arr)\n\nprintln(\"New array with modified real parts: \", new_arr)\n\n# Function to find the complex number with the largest real part\nfunction max_real_part(arr)\n    max_z = arr[1]\n    for z in arr\n        if real(z) &gt; real(max_z)\n            max_z = z\n        end\n    end\n    return max_z\nend\n\n# Find the complex number with the largest real part\nmax_z = max_real_part(arr)\nprintln(\"Complex number with the largest real part: \", max_z)\n\nNew array with modified real parts: ComplexF64[5.0 + 4.0im, 3.0 + 2.0im, 7.0 + 6.0im]\nComplex number with the largest real part: 5.0 + 6.0im\n\n\n\n\n\n\n\nExercise 3: Manipulating Arrays and Tuples\n\nCreate an array arr of integers from 1 to 10.\nUse broadcasting (.=) to multiply all elements of the array by 2.\nCreate a tuple t with three elements: a string, an integer, and a float.\nTry to mutate the first element of the tuple and handle any errors using a try-catch block.\nCreate a NamedTuple nt with fields name, age, and height, and initialize it with your details.\n\n\n\n\n\n\n\nHint for Exercise 3:\n\n\n\n\n\n\nUse the . operator for broadcasting and mutation of arrays.\nRemember that tuples are immutable, so you canâ€™t modify their elements.\nUse a try-catch block to catch errors if an operation fails.\n\n\n\n\n\n\n\n\n\n\nCorrection of Exercise 3:\n\n\n\n\n\n\n# Create an array of integers from 1 to 10\narr = collect(1:10)  # Convert UnitRange to an array\n\n# Use broadcasting to multiply all elements of the array by 2\narr .= arr .* 2  # Broadcasting .*= operator\nprintln(\"Modified array: \", arr)\n\n# Create a tuple with three elements: a string, an integer, and a float\nt = (\"John\", 25, 5.9)\n\n# Attempt to mutate the first element of the tuple with error handling\ntry\n    t[1] = \"Alice\"  # This will raise an error because tuples are immutable\ncatch e\n    println(\"Error: \", e)\nend\n\n# Create a NamedTuple with fields: name, age, and height\nnt = (name = \"John\", age = 25, height = 5.9)\n\nprintln(\"NamedTuple: \", nt)\n\nModified array: [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\nError: MethodError(setindex!, ((\"John\", 25, 5.9), \"Alice\", 1), 0x0000000000006aa5)\nNamedTuple: (name = \"John\", age = 25, height = 5.9)",
    "crumbs": [
      "Master 1",
      "Basic Types"
    ]
  },
  {
    "objectID": "M1/fundamentals-multiple_dispatch.html",
    "href": "M1/fundamentals-multiple_dispatch.html",
    "title": "Multiple dispatch",
    "section": "",
    "text": "Back to top",
    "crumbs": [
      "Master 1",
      "Multiple Dispatch"
    ]
  },
  {
    "objectID": "M1/getting_started.html",
    "href": "M1/getting_started.html",
    "title": "Getting Started with Julia",
    "section": "",
    "text": "This page provides an introduction to the Julia programming language, including its key features and installation process. Youâ€™ll learn how to install Julia on different operating systems and how to verify the installation. It also covers using the Julia REPL for interactive coding, creating and running Julia scripts, and managing packages with Juliaâ€™s built-in package manager, Pkg. Additionally, this page provides resources for learning and getting help with Julia, including official documentation, community platforms, and an overview of the Julia ecosystem.\nKey Topics:",
    "crumbs": [
      "Master 1",
      "Getting started"
    ]
  },
  {
    "objectID": "M1/getting_started.html#introduction-to-julia-programming-language",
    "href": "M1/getting_started.html#introduction-to-julia-programming-language",
    "title": "Getting Started with Julia",
    "section": "Introduction to Julia Programming Language",
    "text": "Introduction to Julia Programming Language\nWelcome to the world of Julia! This section will introduce you to the language, explaining why itâ€™s gaining popularity, and highlighting some key features that make Julia a unique tool for scientific computing and general-purpose programming.\n\nWhat is Julia?\nJulia is a high-level, high-performance programming language primarily designed for technical computing. It combines the best features of other programming languages, including Pythonâ€™s ease of use, Câ€™s speed, and MATLABâ€™s support for numerical computation. Julia is open-source and has become a go-to language for scientific research, data analysis, and machine learning applications.\n\n\nWhy Julia?\n\nHigh performance: Julia is designed for performance from the ground up. It often performs on par with statically typed languages like C or Fortran, thanks to Just-In-Time (JIT) compilation using LLVM.\nMultiple dispatch: Julia uses multiple dispatch as its core paradigm, which allows for highly flexible and efficient function definitions.\nDesigned for scientific computing: Julia excels in areas such as linear algebra, numerical analysis, and optimization, making it a great choice for data-heavy fields like economics, physics, and engineering.\nEase of use: Julia offers a simple, intuitive syntax similar to Python and MATLAB, which makes it easy to learn and use, even for those with little programming experience.",
    "crumbs": [
      "Master 1",
      "Getting started"
    ]
  },
  {
    "objectID": "M1/getting_started.html#installing-julia",
    "href": "M1/getting_started.html#installing-julia",
    "title": "Getting Started with Julia",
    "section": "Installing Julia",
    "text": "Installing Julia\n\nDownload Julia\nTo get started with Julia, you first need to install the language on your computer. The official Julia website provides the installation files for various operating systems, including Windows, macOS, and Linux. Follow these steps:\n\nVisit the official Julia Downloads page.\nChoose the appropriate version of Julia for your operating system.\nDownload the installer (the latest stable version is recommended for most users).\n\n\n\nInstallation Instructions\nBefore you can start using Julia, you need to install it on your system. Below are the steps for installing Julia on different operating systems: Mac, Linux, and Windows.\n\nMac / LinuxWindows\n\n\nTo install the latest stable version of Julia on Mac or Linux, follow these simple steps:\n\nOpen your terminal.\nRun the following command to download and install Julia:\n\ncurl -fsSL https://install.julialang.org | sh\nThis command downloads the Julia installation script and runs it automatically. It will install Julia and place it in your /usr/local/bin directory by default.\n\n\nTo install Julia on Windows, follow these steps:\n\nOpen the Microsoft Store page for Julia.\nClick â€œGetâ€ to download and install the latest version of Julia from the Microsoft Store.\n\nAlternatively, you can install Julia using the Windows Package Manager (winget). Open the command prompt and run the following command:\nwinget install julia -s msstore\nAfter installation, you can launch Julia by searching for it in the Start menu or by running julia in the command prompt.\n\n\n\n\n\nVerify Installation\nAfter installation, you can verify that Julia is correctly installed by opening a terminal or command prompt and typing the following command:\njulia\nThis will launch the Julia REPL (Read-Eval-Print Loop), where you can start running Julia commands interactively. You should see something similar to the following:\n\n\n               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type \"?\" for help, \"]?\" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.11.1 (2024-10-16)\n _/ |\\__'_|_|_|\\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\n\njulia&gt;\n\n\nIf you see this prompt, it means Julia is installed and working correctly!\n\n\nInstalling Package Manager\nJulia includes a built-in package manager, Pkg, that allows you to easily manage external packages (libraries) for your projects.\n\nTo start using Pkg, open the Julia REPL and type:\nusing Pkg\nYou can install a package by running:\nPkg.add(\"PackageName\")\n\nFor example, to install the popular plotting package Plots, run:\nPkg.add(\"Plots\")\nThis will download and install the package, making it available for use in your Julia scripts.",
    "crumbs": [
      "Master 1",
      "Getting started"
    ]
  },
  {
    "objectID": "M1/getting_started.html#using-the-julia-repl",
    "href": "M1/getting_started.html#using-the-julia-repl",
    "title": "Getting Started with Julia",
    "section": "Using the Julia REPL",
    "text": "Using the Julia REPL\nThe Julia REPL (Read-Eval-Print Loop) is an interactive command-line environment for executing Julia code. It allows you to run Julia code line-by-line, evaluate expressions, and see the results immediately.\n\nStarting the REPL\nTo start the Julia REPL, open your terminal or command prompt and simply type:\njulia\nYou should see the Julia prompt, which looks like this:\n\n\n               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type \"?\" for help, \"]?\" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.11.1 (2024-10-16)\n _/ |\\__'_|_|_|\\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\n\njulia&gt;\n\n\nThis is the REPL where you can start typing Julia expressions.\n\n\nBasic Commands\nIn the REPL, you can type expressions and commands. For example:\n\nTo perform a simple arithmetic operation, type:\n\n3 + 4\nThe result will appear right below the command, like so:\n7\n\nTo assign a value to a variable, use the = sign:\n\nx = 10\nNow, x holds the value 10. You can use it in further expressions:\nx * 2\nThe result will be:\n20\n\n\nUsing REPL Features\nThe Julia REPL has several features that make it more convenient to use:\n\nHistory: You can use the up and down arrow keys to scroll through your command history and reuse previous commands.\nTab Completion: Type part of a function or variable name and press Tab to automatically complete it or show suggestions.\nHelp: Type ? followed by a function or type name to get documentation directly in the REPL. For example:\n\n?sum\nThis will show information about the sum function.\n\nExiting the REPL: To exit the REPL, simply type:\n\nexit()\nOr press Ctrl-D (on most systems).\n\n\nREPL Modes\nThe Julia REPL has different prompt modes that can be very useful to install / remove packages, run shell commands, search for help, etc. The different modes are:\n\nThe Julian mode\nHelp mode\nPackage mode\nShell mode\n\nVisit the command-line REPL page for more details.\n\nHelp modePackage modeShell mode\n\n\nBy pressing ? you can obtain information and metadata about Julia objects (functions, types, etc.) or unicode symbols. The query fetches the docstring of the object, which explains how to use it.\nhelp?&gt; println\nIf you donâ€™t know the exact name you are looking for, type a word surrounded by quotes to see in which docstrings it pops up. To come back to Julia mode, hit backspace.\n\n\nBy pressing ] you access Pkg.jl, Juliaâ€™s integrated package manager. Please visit the documentation for details. Pkg.jl allows you to:\n\n]activate different local, shared or temporary environments;\n]instantiate them by downloading the necessary packages;\n]add, ]update (or ]up) and ]remove (or ]rm) packages;\nget the ]status (or ]st) of your current environment.\n\nAs an illustration, we download the package Plots.jl inside our current environment:\npkg&gt; add Plots\nNote that you can do the same in Julia mode:\njulia&gt; using Pkg\njulia&gt; Pkg.rm(\"Plots\")\nThe package mode itself also has a help mode, accessed with ?. To come back to Julia mode, hit backspace.\n\n\nBy pressing ; you enter a terminal, where you can execute any command you want. Hereâ€™s an example for Unix systems:\nshell&gt; pwd\nTo come back to Julia mode, hit backspace.",
    "crumbs": [
      "Master 1",
      "Getting started"
    ]
  },
  {
    "objectID": "M1/getting_started.html#running-julia-scripts",
    "href": "M1/getting_started.html#running-julia-scripts",
    "title": "Getting Started with Julia",
    "section": "Running Julia Scripts",
    "text": "Running Julia Scripts\nWhile the Julia REPL is great for interactive experimentation, youâ€™ll often want to write and run larger programs. This is where running Julia scripts comes in.\n\nCreating a Julia Script\nA Julia script is a plain text file that contains Julia code. You can create a Julia script using any text editor, such as VS Code, Sublime Text, or even a simple text editor.\nSave the file with the .jl extension, for example myscript.jl.\n\n\nRunning a Julia Script\nTo run a Julia script, open your terminal or command prompt, navigate to the directory where the script is located, and then use the following command:\njulia myscript.jl\nThis will execute the code in myscript.jl and output any results in the terminal. If your script includes print statements, those outputs will be displayed.\n\n\nExample: Running a Script\nHereâ€™s an example of a simple Julia script:\n# myscript.jl\nprintln(\"Hello, World!\")\nx = 10\ny = 20\nprintln(\"The sum of x and y is \", x + y)\nTo run this script, save it as myscript.jl and use the command:\njulia myscript.jl\nThe output will look like this:\nHello, World!\nThe sum of x and y is 30\n\n\nRunning Scripts with Arguments\nYou can also pass command-line arguments to a Julia script. For example, letâ€™s modify the script to accept arguments:\n# args_example.jl\nprintln(\"Arguments passed to the script: \", ARGS)\nNow, when running the script, you can pass arguments like this:\njulia args_example.jl arg1 arg2 arg3\nThe output will be:\nArguments passed to the script: [\"arg1\", \"arg2\", \"arg3\"]\nYou can access the arguments as elements of the ARGS array within your script.\n\n\nRunning Julia Scripts from the REPL\nYou can also run Julia scripts directly from the REPL by using the include() function. To run the myscript.jl script, for example:\ninclude(\"myscript.jl\")\nThis command will execute the code in the script, and youâ€™ll see the output in the REPL.\n\n\nRunning Julia Scripts in IDEs\nIf youâ€™re using an IDE like VS Code with the Julia extension, you can run the script directly from within the editor by pressing the â€œRunâ€ button or using the appropriate keyboard shortcut. This is convenient for testing and iterating on your code without having to switch back and forth between the editor and the terminal.",
    "crumbs": [
      "Master 1",
      "Getting started"
    ]
  },
  {
    "objectID": "M1/getting_started.html#editors-and-ides",
    "href": "M1/getting_started.html#editors-and-ides",
    "title": "Getting Started with Julia",
    "section": "Editors and Ides",
    "text": "Editors and Ides\nWhile any text editor can be used to write Julia code, Integrated Development Environments (IDEs) significantly enhance the programming experience. Notable options for Julia include Visual Studio Code (VS Code), Jupyter, Pluto.jl, Vim, and Emacs. Each of these editors offers unique features like interactive environments, real-time code feedback, and specialized plugins for a smoother development process. For instance, VS Code with the Julia extension is the most feature-rich IDE for Julia, while Jupyter provides an interactive notebook environment. Pluto.jl focuses on reactive notebooks, and Vim and Emacs offer efficient, customizable text editing solutions.\nThe best IDE for Julia is Visual Studio Code, or VS Code, developed by Microsoft. Indeed, the Julia VS Code extension is the most feature-rich of all Julia IDE plugins. You can download it from the VS Code Marketplace and read its documentation.\n\n\n\n\n\n\nTip\n\n\n\nTo use Julia in Visual Studio Code, please follow these steps, where you can find how to install Julia, VS Code and the necessary extensions.\nTo gain time, you can learn the keyboard shortcuts for:\n\nWindows,\nmacOS,\nLinux.\n\n\n\n\nVS CodeJupyterPluto.jlVimEmacs\n\n\n  \nJulia for Visual Studio Code is a powerful, free IDE for the Julia language. Visual Studio Code is a powerful and customizable editor. With a completely live environment, Julia for VS Code aims to take the frustration and guesswork out of programming and put the fun back in. We build on Juliaâ€™s unique combination of ease-of-use and performance. Beginners and experts can build better software more quickly, and get to a result faster. Julia is an officially supported language on the VS Code documentation.\n\n\n  \nYou can write Jupyter notebooks and use the Jupyter interactive environment. To do so you need to install the IJulia.jl package. IJulia is a Julia-language backend combined with the Jupyter interactive environment (also used by IPython). This combination allows you to interact with the Julia language using Jupyter/IPythonâ€™s powerful graphical notebook, which combines code, formatted text, math, and multimedia in a single document. IJulia is a Jupyter language kernel and works with a variety of notebook user interfaces. In addition to the classic Jupyter Notebook, IJulia also works with JupyterLab, a Jupyter-based integrated development environment for notebooks and code. The nteract notebook desktop supports IJulia with detailed instructions for its installation with nteract. Please visit this webpage to get a tutorial on how to use Julia in Jupyter notebook.\n\n\n   Simple reactive notebooks\n\n\n   Vim plugin\n\n\n   Emacs plugin",
    "crumbs": [
      "Master 1",
      "Getting started"
    ]
  },
  {
    "objectID": "M1/getting_started.html#julia-documentation",
    "href": "M1/getting_started.html#julia-documentation",
    "title": "Getting Started with Julia",
    "section": "Julia Documentation",
    "text": "Julia Documentation\nOne of the key strengths of Julia is its comprehensive and easy-to-navigate documentation. Juliaâ€™s official documentation provides detailed explanations of the language features, standard libraries, and tools available for developers.\n\nOfficial Documentation\nThe official Julia documentation is a complete reference guide for the language. You can find it here:\n\nJulia Documentation Website\n\nThis documentation covers everything from basic syntax to advanced topics like parallel computing and package management.\nExample. Search how to compute the norm of a vector.\n\nThe norm function comes from the standard librairy LinearAlgebra.\n\nHowever, we are not directly at the right place, so I recommend to use the Search docs field.\n\nAnd now, we have the documentation.\n\n\n\n\n\n\n\nNote\n\n\n\nYou can also access the Julia documentation directly from the Julia REPL using the ? (help) command.\n\n\n\n\nAccessing Help in the REPL\nThe REPL provides a built-in help system that can assist you in looking up functions, types, and more. Hereâ€™s how you can use it:\n\nLook up a function or keyword: Type ? followed by the function name or keyword you want help with.\n?println\nThis will display the documentation for the println function.\nSearch for a keyword: You can also type just ? followed by a search term to find relevant functions or types in the documentation.\n?array\nThis will display documentation related to arrays in Julia.\n\n\n\nAdditional Resources\n\nJulia Language GitHub: Julia GitHub Repository â€” Contains the source code and development discussion.\nJulia Discourse: Julia Discourse Forum â€” A community forum where you can ask questions, share ideas, and discuss Julia-related topics.\nJuliaLang Slack: Join Slack Community â€” An official Slack workspace for the Julia community.\nJulia Community: Julia Community â€” A hub for Julia community resources, including events, blogs, and videos.",
    "crumbs": [
      "Master 1",
      "Getting started"
    ]
  },
  {
    "objectID": "M1/getting_started.html#working-with-julia-packages",
    "href": "M1/getting_started.html#working-with-julia-packages",
    "title": "Getting Started with Julia",
    "section": "Working with Julia Packages",
    "text": "Working with Julia Packages\nJulia has a rich ecosystem of packages that extend the languageâ€™s capabilities for various domains, such as machine learning, data science, optimization, and more. The Julia Packages webpage is the official source for Julia packages. This section will cover how to manage and use packages in Julia.\n\nStandard Libraries in Julia\nJulia comes with a set of standard libraries, which are built-in packages available with the installation. These libraries cover a wide range of functionality, from mathematical operations to file handling and system utilities. You do not need to install them separately; they are ready to be used as soon as you start Julia.\nOne commonly used standard library is LinearAlgebra, which provides tools for linear algebra, such as matrix factorizations and vector operations.\n\nExample: Computing the Norm of a Vector\nThe LinearAlgebra library can be used to compute the norm of a vector. Hereâ€™s how you can do that:\nusing LinearAlgebra\n\n# Define a vector\nv = [3, 4]\n\n# Compute the Euclidean norm (magnitude) of the vector\nnorm_v = norm(v)\n\nprintln(\"The norm of the vector is: \", norm_v)\nIn this example, the norm() function calculates the Euclidean norm (or 2-norm) of the vector v, which in this case is\n\n\\sqrt{3^2 + 4^2} = 5.\n\nThese standard libraries help you to get started quickly with common tasks, without the need to install additional packages.\n\n\n\nInstalling Packages\nTo install a package, you can use the Pkg module, which is part of Juliaâ€™s standard library. Hereâ€™s how to install a package:\n\nEnter the package manager mode by typing ] in the REPL.\nThen, use the add command to install a package.\n\nExample:\n] add DataFrames\nThis will install the DataFrames package, which is widely used for data manipulation in Julia. To get the list of installed packages, type:\n] status\n\n\n\n\n\n\nNote\n\n\n\nYou can also install the package directly from the Julia mode:\nusing Pkg\nPkg.add(\"DataFrames\")\n\n\n\n\nUsing Installed Packages\nOnce a package is installed, you can use it by importing it into your code using the using keyword. This makes the functions and types of the package available for use.\nExample:\n\nusing DataFrames\n\ndf = DataFrame(A = 1:4, B = [\"a\", \"b\", \"c\", \"d\"])\n\n4Ã—2 DataFrame\n\n\n\nRow\nA\nB\n\n\n\nInt64\nString\n\n\n\n\n1\n1\na\n\n\n2\n2\nb\n\n\n3\n3\nc\n\n\n4\n4\nd\n\n\n\n\n\n\nThis creates a simple DataFrame object with two columns A and B.\n\n\nUpdating Packages\nTo update the packages installed in your environment to their latest versions, use the update command in the package manager.\nExample:\n] update\nYou can also update a specific package by running:\n] update PackageName\n\n\n\n\n\n\nNote\n\n\n\nYou can also update packages directly from the Julia mode:\nusing Pkg\nPkg.update()\n# or\nPkg.update(\"PackageName\")\n\n\n\n\nRemoving Packages\nIf you no longer need a package, you can remove it using the rm command.\nExample:\n] rm DataFrames\nThis will uninstall the DataFrames package from your environment.\n\n\n\n\n\n\nNote\n\n\n\nYou can also remove packages directly from the Julia mode:\nusing Pkg\nPkg.rm(\"DataFrames\")\n\n\n\n\nPackage Environments\nIn Julia, you can manage different environments, each with its own set of installed packages. This allows you to work on multiple projects with different dependencies without conflicts. You can create a new environment by navigating to a directory and typing:\n] activate .\nThis will activate the environment in the current directory. You can also specify a different directory or environment path by providing it after activate. If you want to come back to the global environment, type:\n] activate\nNote that the packages installed in the global environment are visible from any other environment.\n\n\n\n\n\n\nNote\n\n\n\nYou can also activate environments directly from the Julia mode. For instance, for the current directory:\nusing Pkg\nPkg.activate(\".\")\n\n\n\n\nConclusion\nWorking with packages is essential to leveraging Juliaâ€™s powerful ecosystem. Understanding how to install, update, and remove packages, as well as using environments to manage project-specific dependencies, will help you make the most out of Juliaâ€™s vast libraries.",
    "crumbs": [
      "Master 1",
      "Getting started"
    ]
  },
  {
    "objectID": "M1/getting_started.html#julia-ecosystem",
    "href": "M1/getting_started.html#julia-ecosystem",
    "title": "Getting Started with Julia",
    "section": "Julia Ecosystem",
    "text": "Julia Ecosystem\nThe Julia programming language has a rich ecosystem of tools, platforms, and communities that can help you develop, deploy, and scale your applications. This section will introduce some key components of the Julia ecosystem, including JuliaHub, JuliaSim, JuliaCon, and other important resources. The Julia ecosystem is growing rapidly, offering a wide range of tools for scientific computing, data science, and application development. Platforms like JuliaHub, simulation tools like JuliaSim, and community events like JuliaCon are all central to the ecosystem and provide invaluable resources to Julia users.\n\nJuliaHub\nJuliaHub is an online platform developed by Julia Computing that provides cloud-based access to Julia environments. It offers managed Julia instances, making it easier to share and deploy Julia-based projects without the need to worry about local setup. JuliaHub also supports collaboration on Julia projects and integrates with popular tools such as Jupyter notebooks.\nFeatures of JuliaHub include:\n\nCloud-based Julia environments: Run Julia code on the cloud without any installation.\nPackage management: Seamless integration with Juliaâ€™s package manager.\nCollaboration: Share Julia code and data with colleagues and collaborators.\nJupyter notebooks: Use Jupyter notebooks hosted on JuliaHub for interactive computing.\n\n\n\nJuliaSim\nJuliaSim is a collection of tools and libraries for modeling and simulation, built using Julia. It is designed for systems simulation in fields such as engineering, physics, and finance. JuliaSim offers several packages and tools to help you build and simulate complex models, as well as visualize and analyze the results.\nFeatures of JuliaSim include:\n\nDifferential equation solving: Tools like DifferentialEquations.jl are used to solve complex systems of differential equations.\nSimulations in science and engineering: Use JuliaSim to simulate and analyze physical, chemical, and biological systems.\nFast performance: The high-performance capabilities of Julia make JuliaSim ideal for computationally intensive simulations.\n\n\n\nJuliaCon\nJuliaCon is the annual conference for the Julia community, where developers, researchers, and users come together to share the latest developments, discuss best practices, and showcase their Julia projects. JuliaCon features keynote speakers, tutorials, workshops, and talks on a wide range of topics related to Julia programming.\nKey features of JuliaCon:\n\nWorkshops and tutorials: Learn Julia directly from experts through hands-on workshops.\nNetworking: Meet fellow Julia users, contributors, and researchers to collaborate on projects and research.\nTalks and presentations: Hear about cutting-edge developments in Julia from experts in various fields.",
    "crumbs": [
      "Master 1",
      "Getting started"
    ]
  },
  {
    "objectID": "M1/fundamentals-interoperability.html",
    "href": "M1/fundamentals-interoperability.html",
    "title": "Interoperability",
    "section": "",
    "text": "Back to top",
    "crumbs": [
      "Master 1",
      "Interoperability"
    ]
  },
  {
    "objectID": "M1/fundamentals-metaprogramming.html",
    "href": "M1/fundamentals-metaprogramming.html",
    "title": "Metaprogramming",
    "section": "",
    "text": "Back to top",
    "crumbs": [
      "Master 1",
      "Metaprogramming"
    ]
  },
  {
    "objectID": "M1/fundamentals-modules_and_packages.html",
    "href": "M1/fundamentals-modules_and_packages.html",
    "title": "Modules and packages",
    "section": "",
    "text": "Back to top",
    "crumbs": [
      "Master 1",
      "Modules and Packages"
    ]
  },
  {
    "objectID": "M2/exercices-linear_regression.html",
    "href": "M2/exercices-linear_regression.html",
    "title": "Lecture 2",
    "section": "",
    "text": "Back to top",
    "crumbs": [
      "Master 2",
      "Tutorials",
      "Linear regression"
    ]
  },
  {
    "objectID": "M2/resources/TP1-distributions.html",
    "href": "M2/resources/TP1-distributions.html",
    "title": "Introduction to julia for statistic",
    "section": "",
    "text": "To contact me, here is my email : joseph.gergaud@toulouse-inp.fr\nThe files ares here :\nhttps://gitlab.irit.fr/toc/etu-n7/julia\ndirectory M2"
  },
  {
    "objectID": "M2/resources/TP1-distributions.html#empirical-cumulative-distribution-function-ecdf",
    "href": "M2/resources/TP1-distributions.html#empirical-cumulative-distribution-function-ecdf",
    "title": "Introduction to julia for statistic",
    "section": "empirical cumulative distribution function, eCDF",
    "text": "empirical cumulative distribution function, eCDF\n\nExercise 1\n\nBuild the empirical cumulative distribution function\n\n\n# use broadcasting\na = [1,2,3.5]\na .&lt; 2\n\n3-element BitVector:\n 1\n 0\n 0\n\n\n\nusing Test   # for tests\n\n\"\"\"\n   Compute de number of element in the vactor t less than a value x\n   input\n   t : Vector of Real\n   x : Real\n   Output\n   Integer\n\"\"\"\nfunction empirique(t::Vector{&lt;:Real}, x::Real)::Int\n    # to complete\n    return sum(t .&lt; x)  # .&lt; vectorial operation\nend\n\n\nprintln(\"empirique([1.,2,3],1.5) = \", empirique([1.,2,3],1.5))\n\nTest.@test empirique([1.,2,3],1.5) == 1\n\nempirique([1.,2,3],1.5) = 1\n\n\n\nTest Passed\n\n\n\n\n# If the type of the vector elements is not a real then there is an error\nprintln(\"empirique([1.+2im,2,3],1.5) = \", empirique([1.,2+2im,3],1.5))\n\nMethodError: MethodError: no method matching empirique(::Vector{ComplexF64}, ::Float64)\nThe function `empirique` exists, but no method is defined for this combination of argument types.\n\nClosest candidates are:\n  empirique(!Matched::Vector{&lt;:Real}, ::Real)\n   @ Main ~/Courses/julia/course-tse-julia/M2/resources/jl_notebook_cell_df34fa98e69747e1a8f8a730347b8e2f_W3sZmlsZQ==.jl:11\n\nMethodError: no method matching empirique(::Vector{ComplexF64}, ::Float64)\n\nThe function `empirique` exists, but no method is defined for this combination of argument types.\n\n\n\nClosest candidates are:\n\n  empirique(!Matched::Vector{&lt;:Real}, ::Real)\n\n   @ Main ~/Courses/julia/course-tse-julia/M2/resources/jl_notebook_cell_df34fa98e69747e1a8f8a730347b8e2f_W3sZmlsZQ==.jl:11\n\n\n\n\n\nStacktrace:\n\n [1] top-level scope\n\n   @ ~/Courses/julia/course-tse-julia/M2/resources/jl_notebook_cell_df34fa98e69747e1a8f8a730347b8e2f_W4sZmlsZQ==.jl:2\n\n\n\nGenerate a sample of N=1000 datas from a uniform distribution on [0,2] and plot the eCDF of this sample\n\n\nusing Plots  # for plots\nN = 1000 # number of datas\nu = 2*rand(N)   # uniform law on [0,2]\nx_grid = -1:0.1:3\n# Plot of the empirical cumulative distribution function\nusing Plots\nF(x) = empirique(u,x)/N\np_uniform_cdf = plot(x_grid,F,xlabel=\"x\", ylabel=\"F(x)\", legend=false)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAdd on the plot the Cumulative Distribution Function For thie use de Distributions Package\n\n\n# add the cumulative distribution function\nusing Distributions"
  },
  {
    "objectID": "M2/resources/TP1-distributions.html#distributions-package",
    "href": "M2/resources/TP1-distributions.html#distributions-package",
    "title": "Introduction to julia for statistic",
    "section": "Distributions Package",
    "text": "Distributions Package\n\nIntroduction\nThere is lots of libraries (Packages in julia) : https://julialang.org/packages/\nFor the documentation of the Distributions Package see\nhttps://juliastats.org/Distributions.jl/stable/\n\nusing Distributions\nusing Plots\nusing LaTeXStrings\na = 0; b = 2;\ndist = Uniform(a,b)  # dist is an object : the uniform distribution on [a,b]\nprintln(\"type de dist = \",typeof(dist))\n# you can acces to the mean or median of the distribution\nprintln(\"mean(dist) = \", mean(dist))\nprintln(\"median(dist) = \", median(dist))\n# and the the PDF, CDF and inverse CDF function of the distribution\nprintln(\"pdf(1.2) = \", pdf(dist,1.2))\nprintln(\"pdf(3) = \", pdf(dist,3))\nprintln(\"cdf(1.2) = \", cdf(dist,1.2))\nprintln(\"cdf(3) = \", cdf(dist,3))\nprintln(\"inverse of cdf(0.75) = \", quantile(dist,0.75))\n\ntype de dist = Uniform{Float64}\nmean(dist) = 1.0\nmedian(dist) = 1.0\npdf(1.2) = 0.5\npdf(3) = 0.0\ncdf(1.2) = 0.6\ncdf(3) = 1.0\ninverse of cdf(0.75) = 1.5\n\n\n\nExercise 2\nPlot on the same first graph the CFD of the uniform distribution on [0,2]\n\ncdf_uniform(x) = cdf(dist,x)\nplot!(p_uniform_cdf,x_grid,cdf_uniform,xlabel=\"x\", ylabel=\"F(x)\", legend=false)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTriangular Distribution\nWe consider the distribution with the following density distribution f(x) = \\begin{cases}\nx\\quad\\textrm{pour}\\quad x\\in[0,1]\\\\\n2-x\\quad\\textrm{pour}\\quad x\\in[1,2]\\\\\n0\\quad\\textrm{sinon}\n\\end{cases}\nPlot the density, cumulative dendity and inverse cumulative function\n\nusing Distributions\nusing Plots\nusing LaTeXStrings\na = 0; b = 2;\ndist = TriangularDist(a,b,1)  # min = a; max = b; mode = 1\nprintln(\"type de dist = \",typeof(dist))\nprintln(\"params(dist) = \", params(dist))\n\n\n# Density function\np1 = plot(x_grid, x-&gt;pdf(dist,x), color = :blue, linewidth=2, xlabel=(L\"x\"), ylabel=(L\"f(x)\")) \n# Cumulative density function\np2 = plot(a-1:0.01:b+1, x-&gt;cdf(dist,x), linewidth=2, xlabel=(L\"x\"), ylabel=(L\"F(x)\"))  \n# Inverse cumulative density function\np3 = plot(0:0.01:1, x-&gt;quantile(dist,x), xlims=(0,1), ylims=(0,2), color = :green, linewidth=2, xlabel=(L\"u\"), ylabel=(L\"F^{-1}(u)\"))\nplot(p1,p2,p3, layout=(1,3),legend = false,size = (1200,300), margin = 0.6Plots.cm)\n\ntype de dist = TriangularDist{Float64}\nparams(dist) = (0.0, 2.0, 1.0)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHistogram\nGenerate a sample of 100 datas from the triangular distribution and plot on the same graph the histogram of the simple and the PDF function\n\n# Sample of 100 datas\nt = rand(dist,100)\nhistogram(t) \nhistogram(t,normalize=true) # normalize=true pour ajouter la fonction de densitÃ©\nplot!(a-0.5:0.1:b+0.5, x-&gt;pdf.(dist,x), linewidth=2, xlabel=(L\"x\"), ylabel=(L\"f(x)\"))   \n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion\nWhat is the problem ?\n\nUse the normalize=true parameter in the histogram function for solving the problem\nExecute for a sample of N = 10000 datas\n\n\n\n\nExample of discret distribution : the binomial distribution\n\nn, p, N = 10, 0.2, 10^3\nbDist = Binomial(n,p)\nxgrid = 0:n\nplot(xgrid,pdf.(bDist,xgrid), color=:orange, seriestype = :scatter)\nplot!(xgrid,pdf.(bDist,xgrid), line = :stem, linewidth=2, color=:orange)"
  },
  {
    "objectID": "M2/resources/TP1-distributions.html#central-limit-theorem",
    "href": "M2/resources/TP1-distributions.html#central-limit-theorem",
    "title": "Introduction to julia for statistic",
    "section": "Central limit theorem",
    "text": "Central limit theorem\nWe are going to illustrate the central limit theorem :\nSuppose X_1,X_2,\\ldots is a sequence of Independent and identically distributed random variables with E(X_i)=\\mu and Var(X_i)=\\sigma^2 &lt; +\\infty. Then, as n approaches infinity, the random variables \\sqrt{n}(\\bar{X}_n - \\mu) converge in distribution to a normal distribution \\mathcal{N}(0,\\sigma^2)\n\nExercise\n\nChoose a distribution law dist, compute its mean \\mu and its variance \\sigma^2 and N the number of sanple\nFor n in (1,2,5,20)\n\nGenerate N=10000 samples of lenght n from the dist distribution\nCompute the means of the N samples and the N values \\sqrt{n}(\\bar{X}_n - \\mu)\nPlot the histogram of these N values and the normal distribution \\mathcal{N}(0,\\sigma^2)\n\n\n\nX = rand(dist,(2,3))\nprintln(X)\n(mean(X,dims=1))\n\n[1.6238502970841644 1.6152917617470268 0.6276948740727439; 1.9019416578611044 0.9174508739539737 1.258732748878705]\n\n\n1Ã—3 Matrix{Float64}:\n 1.7629  1.26637  0.943214\n\n\n\ndist = Uniform(0,12)\nÎ¼ = mean(dist)\nÏƒ = std(dist)\nnormal_dist = Normal(0,Ïƒ)\nprintln(L\"\\mu = \", Î¼)\nprintln(L\"\\sigma = \", Ïƒ)\nN = 10000\nn_mean = (1,2,5,20)\n\np = []\nfor n in n_mean \n    X = rand(dist,(n,N))\n    Xbar_n = vec(sqrt(n)*(mean(X,dims=1) .- Î¼)) # to have a vector and not a matrix of size (1,3)\n    \n    p1 = histogram(Xbar_n,normalize=true) # normalize=true pour ajouter la fonction de densitÃ©\n    plot!(p1, -3*Ïƒ:0.1:3*Ïƒ, x-&gt;pdf.(normal_dist,x), linewidth=2, xlabel=(L\"x\"), ylabel=(L\"f(x)\"))   \n    push!(p,p1)\nend\nprintln(p)\nplot(p[1],p[2],p[3],p[4],legend = false)\n\n$\\mu = $6.0\n$\\sigma = $3.4641016151377544\nAny[Plot{Plots.GRBackend() n=2}, Plot{Plots.GRBackend() n=2}, Plot{Plots.GRBackend() n=2}, Plot{Plots.GRBackend() n=2}]"
  },
  {
    "objectID": "M2/exercices-distribution_of_random_variables.html",
    "href": "M2/exercices-distribution_of_random_variables.html",
    "title": "Distributions of random variables",
    "section": "",
    "text": "For the exercices of this page, you need to add the packages Distributions.jl, LaTeXStrings.jl, Plots.jl and Test.jl. To install them please open Juliaâ€™s interactive session (known as REPL) and press ] key in the REPL to use the package mode, then add the packages:\njulia&gt; ]\npkg&gt; add Distributions\npkg&gt; add LaTeXStrings\npkg&gt; add Plots\npkg&gt; add Test\nWhen the installation is complete, import them:\n\nusing Distributions\nusing LaTeXStrings # just for labels in some plots\nusing Plots\nusing Test\n\nThe package Test.jl is used to test if the outputs of functions to complete are correct. The packages Plots.jl is for data visualization. Almost everything in Plots is done by specifying plot attributes. Do not hesitate to have a look to this tutorial. Finally, the package Distributions.jl provides a large collection of probabilistic distributions and related functions.",
    "crumbs": [
      "Master 2",
      "Tutorials",
      "Distribution of random variables"
    ]
  },
  {
    "objectID": "M2/exercices-distribution_of_random_variables.html#preliminaries",
    "href": "M2/exercices-distribution_of_random_variables.html#preliminaries",
    "title": "Distributions of random variables",
    "section": "",
    "text": "For the exercices of this page, you need to add the packages Distributions.jl, LaTeXStrings.jl, Plots.jl and Test.jl. To install them please open Juliaâ€™s interactive session (known as REPL) and press ] key in the REPL to use the package mode, then add the packages:\njulia&gt; ]\npkg&gt; add Distributions\npkg&gt; add LaTeXStrings\npkg&gt; add Plots\npkg&gt; add Test\nWhen the installation is complete, import them:\n\nusing Distributions\nusing LaTeXStrings # just for labels in some plots\nusing Plots\nusing Test\n\nThe package Test.jl is used to test if the outputs of functions to complete are correct. The packages Plots.jl is for data visualization. Almost everything in Plots is done by specifying plot attributes. Do not hesitate to have a look to this tutorial. Finally, the package Distributions.jl provides a large collection of probabilistic distributions and related functions.",
    "crumbs": [
      "Master 2",
      "Tutorials",
      "Distribution of random variables"
    ]
  },
  {
    "objectID": "M2/exercices-distribution_of_random_variables.html#empirical-distribution-function",
    "href": "M2/exercices-distribution_of_random_variables.html#empirical-distribution-function",
    "title": "Distributions of random variables",
    "section": "Empirical distribution function",
    "text": "Empirical distribution function\n\nExercise 1\n\nBuild the empirical cumulative distribution function, also called eCDF.\n\n\n\n\n\n\n\nNote\n\n\n\nUse broadcasting to complete the following code.\n\na = [1,2,3.5]\na .&lt; 2\n\n3-element BitVector:\n 1\n 0\n 0\n\n\n\n\n\n\"\"\"\n   Compute de number of element in the vactor t less than a value x\n   input\n   t : Vector of Real\n   x : Real\n   Output\n   Integer\n\"\"\"\nfunction empirique(t::Vector{&lt;:Real}, x::Real)::Int\n    # to complete\n    return sum(t .&lt; x)  # .&lt; vectorial operation\nend\n\n\nprintln(\"empirique([1.,2,3],1.5) = \", empirique([1.,2,3],1.5))\n\nTest.@test empirique([1.,2,3],1.5) == 1\n\nempirique([1.,2,3],1.5) = 1\n\n\n\nTest Passed\n\n\n\n\n# If the type of the vector elements is not a real then there is an error\nprintln(\"empirique([1.+2im,2,3],1.5) = \", empirique([1.,2+2im,3],1.5))\n\n\nMethodError: no method matching empirique(::Vector{ComplexF64}, ::Float64)\nThe function `empirique` exists, but no method is defined for this combination of argument types.\n\nClosest candidates are:\n  empirique(::Vector{&lt;:Real}, ::Real)\n   @ Main In[352]:9\n\n\nStacktrace:\n [1] top-level scope\n   @ In[353]:2\n\n\n\n\nGenerate a sample of N=1000 datas from a uniform distribution on [0,2] and plot the eCDF of this sample.\n\n\nN = 1000 # number of datas\nu = 2*rand(N)   # uniform law on [0,2]\nx_grid = -1:0.1:3\n\n# Plot of the empirical cumulative distribution function\nF(x) = empirique(u,x)/N\np_uniform_cdf = plot(x_grid,F,xlabel=\"x\", ylabel=\"F(x)\", legend=false)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAdd on the plot the eCDF with the Distribution.jl package.",
    "crumbs": [
      "Master 2",
      "Tutorials",
      "Distribution of random variables"
    ]
  },
  {
    "objectID": "M2/exercices-distribution_of_random_variables.html#distributions.jl-package",
    "href": "M2/exercices-distribution_of_random_variables.html#distributions.jl-package",
    "title": "Distributions of random variables",
    "section": "Distributions.jl Package",
    "text": "Distributions.jl Package\n\nIntroduction\nThere is lots of libraries (packages in julia): https://julialang.org/packages/. For the documentation of the Distributions Package see https://juliastats.org/Distributions.jl/stable/.\n\na = 0; b = 2;\ndist = Uniform(a,b)  # dist is an object : the uniform distribution on [a,b]\nprintln(\"type de dist = \",typeof(dist))\n# you can acces to the mean or median of the distribution\nprintln(\"mean(dist) = \", mean(dist))\nprintln(\"median(dist) = \", median(dist))\n# and the the PDF, CDF and inverse CDF function of the distribution\nprintln(\"pdf(1.2) = \", pdf(dist,1.2))\nprintln(\"pdf(3) = \", pdf(dist,3))\nprintln(\"cdf(1.2) = \", cdf(dist,1.2))\nprintln(\"cdf(3) = \", cdf(dist,3))\nprintln(\"inverse of cdf(0.75) = \", quantile(dist,0.75))\n\ntype de dist = Uniform{Float64}\nmean(dist) = 1.0\nmedian(dist) = 1.0\npdf(1.2) = 0.5\npdf(3) = 0.0\ncdf(1.2) = 0.6\ncdf(3) = 1.0\ninverse of cdf(0.75) = 1.5\n\n\n\n\nExercise 2\nPlot on the same first graph the CFD of the uniform distribution on [0,2]\n\ncdf_uniform(x) = cdf(dist,x)\nplot!(p_uniform_cdf,x_grid,cdf_uniform,xlabel=\"x\", ylabel=\"F(x)\", legend=false)",
    "crumbs": [
      "Master 2",
      "Tutorials",
      "Distribution of random variables"
    ]
  },
  {
    "objectID": "M2/exercices-distribution_of_random_variables.html#triangular-distribution",
    "href": "M2/exercices-distribution_of_random_variables.html#triangular-distribution",
    "title": "Distributions of random variables",
    "section": "Triangular Distribution",
    "text": "Triangular Distribution\nWe consider the distribution with the following density distribution\nf(x) = \\begin{cases}\nx\\quad\\textrm{pour}\\quad x\\in[0,1]\\\\\n2-x\\quad\\textrm{pour}\\quad x\\in[1,2]\\\\\n0\\quad\\textrm{sinon}\n\\end{cases}\nPlot the density, cumulative dendity and inverse cumulative function.\n\na = 0; b = 2;\ndist = TriangularDist(a,b,1)  # min = a; max = b; mode = 1\nprintln(\"type de dist = \",typeof(dist))\nprintln(\"params(dist) = \", params(dist))\n\n# Density function\np1 = plot(x_grid, x-&gt;pdf(dist,x), color = :blue, linewidth=2, xlabel=(L\"x\"), ylabel=(L\"f(x)\")) \n# Cumulative density function\np2 = plot(a-1:0.01:b+1, x-&gt;cdf(dist,x), linewidth=2, xlabel=(L\"x\"), ylabel=(L\"F(x)\"))  \n# Inverse cumulative density function\np3 = plot(0:0.01:1, x-&gt;quantile(dist,x), xlims=(0,1), ylims=(0,2), color = :green, linewidth=2, xlabel=(L\"u\"), ylabel=(L\"F^{-1}(u)\"))\nplot(p1,p2,p3, layout=(1,3),legend = false,size = (1200,300), margin = 0.6Plots.cm)\n\ntype de dist = TriangularDist{Float64}\nparams(dist) = (0.0, 2.0, 1.0)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHistogram\nGenerate a sample of 100 datas from the triangular distribution and plot on the same graph the histogram of the simple and the PDF function\n\n# Sample of 100 datas\nt = rand(dist,100)\nhistogram(t) \nhistogram(t,normalize=true) # normalize=true pour ajouter la fonction de densitÃ©\nplot!(a-0.5:0.1:b+0.5, x-&gt;pdf.(dist,x), linewidth=2, xlabel=(L\"x\"), ylabel=(L\"f(x)\"))   \n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion\nWhat is the problem ?\n\nUse the normalize=true parameter in the histogram function for solving the problem\nExecute for a sample of N = 10000 datas",
    "crumbs": [
      "Master 2",
      "Tutorials",
      "Distribution of random variables"
    ]
  },
  {
    "objectID": "M2/exercices-distribution_of_random_variables.html#example-of-discret-distribution",
    "href": "M2/exercices-distribution_of_random_variables.html#example-of-discret-distribution",
    "title": "Distributions of random variables",
    "section": "Example of discret distribution",
    "text": "Example of discret distribution\nWe present here the binomial distribution which is a discrete probability distribution.\n\nn, p, N = 10, 0.2, 10^3\nbDist = Binomial(n,p)\nxgrid = 0:n\nplot(xgrid,pdf.(bDist,xgrid), color=:orange, seriestype = :scatter)\nplot!(xgrid,pdf.(bDist,xgrid), line = :stem, linewidth=2, color=:orange)",
    "crumbs": [
      "Master 2",
      "Tutorials",
      "Distribution of random variables"
    ]
  },
  {
    "objectID": "M2/exercices-distribution_of_random_variables.html#central-limit-theorem",
    "href": "M2/exercices-distribution_of_random_variables.html#central-limit-theorem",
    "title": "Distributions of random variables",
    "section": "Central limit theorem",
    "text": "Central limit theorem\nWe are going to illustrate the central limit theorem :\nSuppose X_1,X_2,\\ldots is a sequence of Independent and identically distributed random variables with E(X_i)=\\mu and Var(X_i)=\\sigma^2 &lt; +\\infty. Then, as n approaches infinity, the random variables \\sqrt{n}(\\bar{X}_n - \\mu) converge in distribution to a normal distribution \\mathcal{N}(0,\\sigma^2)\n\nExercise\n\nChoose a distribution law dist, compute its mean \\mu and its variance \\sigma^2 and N the number of sanple\nFor n in (1,2,5,20)\n\nGenerate N=10000 samples of lenght n from the dist distribution\nCompute the means of the N samples and the N values \\sqrt{n}(\\bar{X}_n - \\mu)\nPlot the histogram of these N values and the normal distribution \\mathcal{N}(0,\\sigma^2)\n\n\n\nX = rand(dist,(2,3))\nprintln(X)\n(mean(X,dims=1))\n\n[0.3900501110792506 1.6017523790079928 0.8608969107894937; 0.8100903551087728 0.820605938432214 0.7620181237169289]\n\n\n1Ã—3 Matrix{Float64}:\n 0.60007  1.21118  0.811458\n\n\n\ndist = Uniform(0,12)\nÎ¼ = mean(dist)\nÏƒ = std(dist)\nnormal_dist = Normal(0,Ïƒ)\nprintln(L\"\\mu = \", Î¼)\nprintln(L\"\\sigma = \", Ïƒ)\nN = 10000\nn_mean = (1,2,5,20)\n\np = []\nfor n in n_mean \n    X = rand(dist,(n,N))\n    Xbar_n = vec(sqrt(n)*(mean(X,dims=1) .- Î¼)) # to have a vector and not a matrix of size (1,3)\n    \n    p1 = histogram(Xbar_n,normalize=true) # normalize=true pour ajouter la fonction de densitÃ©\n    plot!(p1, -3*Ïƒ:0.1:3*Ïƒ, x-&gt;pdf.(normal_dist,x), linewidth=2, xlabel=(L\"x\"), ylabel=(L\"f(x)\"))   \n    push!(p,p1)\nend\nprintln(p)\nplot(p[1],p[2],p[3],p[4],legend = false)\n\n$\\mu = $6.0\n$\\sigma = $3.4641016151377544\nAny[Plot{Plots.GRBackend() n=2}, Plot{Plots.GRBackend() n=2}, Plot{Plots.GRBackend() n=2}, Plot{Plots.GRBackend() n=2}]",
    "crumbs": [
      "Master 2",
      "Tutorials",
      "Distribution of random variables"
    ]
  }
]