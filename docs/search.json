[
  {
    "objectID": "src/machine_learning.html",
    "href": "src/machine_learning.html",
    "title": "Machine Learning",
    "section": "",
    "text": "(Ref. Huda Nasser, Julia Academy - Data Science)\nIn this chapter, we will explore the fundamentals of machine learning by working with the MNIST dataset — a classic benchmark in computer vision. The MNIST dataset consists of 70,000 handwritten digits (0 through 9), split into 60,000 training images and 10,000 testing images. Each image is a grayscale 28×28 pixel image, making it ideal for experimenting with classification models.\nThe Julia language offers powerful packages, including Flux.jl (for building neural networks), MLDatasets.jl (to access standard datasets) and OneHotArrays (for target batching). Throughout, the exercise we will use a set of tools (Images.jl, ImageInTerminal.jl, Plots.jl) in order to make visual cheks along the process.\nThe exercise in this chapter will guide you through the following steps:",
    "crumbs": [
      "Applications",
      "Machine Learning"
    ]
  },
  {
    "objectID": "src/machine_learning.html#mnist-dataset",
    "href": "src/machine_learning.html#mnist-dataset",
    "title": "Machine Learning",
    "section": "MNIST dataset",
    "text": "MNIST dataset\nThe MNIST dataset can be retrieved from the MLDatasets.jl package. Start by loading the training dataset.\nusing MLDatasets\nd_train = MNIST(split=:train)\nWhat does this dataset actually look like? You can check this by typing the following commands.\nusing Images\nusing ImageInTerminal\ncolorview(Gray,d_train.features[:,:,1])\nIt turns out unclear at moments which digit is handwritten on the image. To clarify this, have a look at the label associated to the image.\nd_train.targets[1]",
    "crumbs": [
      "Applications",
      "Machine Learning"
    ]
  },
  {
    "objectID": "src/machine_learning.html#neural-network",
    "href": "src/machine_learning.html#neural-network",
    "title": "Machine Learning",
    "section": "Neural network",
    "text": "Neural network\nA neural network is a type of machine learning model inspired by the structure and function of the human brain. It is composed of layers of interconnected nodes called neurons, which work together to process data, recognize patterns, and make predictions.\nAt its core, a neural network learns to approximate complex functions by adjusting the weights and biases of these connections based on the data it sees.\nA standard neural network for the MNIST dataset to start of with has the following structure:\nInput (784) ⟶ Dense (32) ⟶ ReLU ⟶ Dense (10) ⟶ Softmax ⟶ Output (Digit 0–9)\nThe 28-by-28 gray-scale images are flattened into a 784 element vector. No activation function is applied at this stage — the input is just passed to the next layer. The input data is passed to a 32-neuron hidden layer which computes a weighted sum of the inputs, adds a bias, and passes the result through an activation function, here ReLU (Rectified Linear Unit) to introduce non-linearity. The output layer has 10 neurons to be consistent with the 10 possible targets (0 through 9). This being a classification task of the handwritten digit, we use a Softmax activation function to convert the outputs into probabilities that sum to 1.\n\nPreprocess the dataset\nThe neural network we will be using in this exercise requires a 1D-vector of length 784 input. Start by flattening the matrices representing the images of our dataset using Flux.jl.\nusing Flux\nv_train = Flux.flatten(d_train.features)\nnothing #| hide\nYou should now use OneHotArrays.jl to transform the target array to vectors of 10 elements, with 1 at the index of the target digit.\nusing OneHotArrays\nY = onehotbatch(d_train.targets,0:9)\n\n\nSet-up the neural network\nThe lines of code bellow are simply a translation of the neural network schematic in Julia.\nm = Chain(\n          Dense(28*28,32,relu),\n          Dense(32,10),\n          softmax\n         )\nnothing #| hide\nWhat happens if we apply this neural network to one of the images?\nm(v_train[:,1])\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nThe network is not able to determine which digit is associated to this image. The weights and biases of the connections between the neurons have not get been adjusted since the neurol network we created as not yet been trained.",
    "crumbs": [
      "Applications",
      "Machine Learning"
    ]
  },
  {
    "objectID": "src/machine_learning.html#training",
    "href": "src/machine_learning.html#training",
    "title": "Machine Learning",
    "section": "Training",
    "text": "Training\nYou can start by having a look at the training function within Flux.jl in the following way.\n#| output: false \n? Flux.train!\n\n\n\n\n\n\nWarning\n\n\n\nTake care when changing package version to have a look at the major changes. For instance, from version 0.14 of Flux.jl on the syntax for Flux.train! changed. Indeed, it went from Flux.train!(loss, params(model), data, opt) to Flux.train!(loss, model, data, opt_state)  # using the new \"setup\" from Optimisers.jl.\n\n\nWhen a neural network makes predictions (like classifying an image as a “3” instead of a “7”), we need a way to measure the difference between the predicted output and the actual (true) target.\nThe loss function provides this measure. It returns a numerical value that represents the “error” — the higher the value, the worse the prediction. Since we have a classification problem in this exercise, a typical loss choice is the cross-entropy loss.\nloss(m,x, y) = Flux.Losses.crossentropy(m(x),y)\nnothing #| hide\nTo properly train the neural network we wish to minimize the loss function. To do so, we will be using a variant of gradient descent called ADAM.\noptimizer = Flux.setup(Adam(), m)\nnothing #| hide\nWhen training a neural network, we often need to go over the training data multiple times. Each full pass over the training data is called an epoch.\nusing IterTools: ncycle\ndataset = ncycle([(v_train, Y)], 200)\nnothing #| hide\nThe dataset storage constructed in the cell above tells us to train for 200 epochs. This means that the network will see the training data 200 times.\nLet’s train the neural network now!\nFlux.train!(loss, m, dataset, optimizer)\nSo, does it work better than previously on our first image?\ntst = m(v_train[:,1])\ncls = argmax(tst)-1\ntgt = d_train.targets[1]\nprintln(\"Image classified as \", cls, \" with target \", tgt, \".\")\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nWe can not conclude with only one item out of the whole set. In the next section, we will analyse the performance of the neural network on unseen data. Which will allow us to conclude.\n\n\n\nLet us now have a look under the hood of Flux.train!. What is happening in the training loop? - Take a subset of input data with associated targets: a batch; - Determine whether the model m predicts well the targets: use the loss function; - Find out which direction each model parameter should move to: compute the gradient of the loss with respect to each parameter; - Adjust the parameters using the gradients and an optimizer.\n\n\n\n\n\n\nWrite manually the training loop based on above stated steps using Flux.jl utilities like gradient, Flux.trainable and Flux.Optimise.update!.\n\n\n\n\n\n#| eval: false\nopt = Flux.setup(Adam(), m)\nloss(x, y) = Flux.Losses.crossentropy(x, y)\n\n# Training loop\nfor epoch in 1:200\n    grads = Flux.gradient(m) do model\n      result = model(v_train)\n      loss(result, Y)\n    end\n    Flux.update!(opt, m, grads[1])\n    println(\"Epoch $epoch | Loss: \", loss(m(v_train), Y))\nend\nWhat happens when you replace the Adam() optimizer by a standard Descent()? Or the loss by a Mean Square Error (MSE)? Can you find the available loss functions in the Flux.jl package documentation?",
    "crumbs": [
      "Applications",
      "Machine Learning"
    ]
  },
  {
    "objectID": "src/machine_learning.html#testing",
    "href": "src/machine_learning.html#testing",
    "title": "Machine Learning",
    "section": "Testing",
    "text": "Testing\nWe can now evaluate our trained neural network on unseen data, the so-called test dataset.\nd_test = MNIST(split=:test)\nfor i in 1:10\n   b = d_test.features[:,:,i]\n   v_b = reshape(b,784)\n   a = m(v_b)\n   r = argmax(a)-1\n   println(\"Image classified as \", r, \" with target \", d_test.targets[i], \".\")\nend\nnothing #| hide\nThe results seem pretty good at first glance.\n\n\n\n\n\n\nGenerate a violin plot of the predicted probability associated to the target digit for the images in the test dataset. Use the Plots.jl documentation to do so.\n\n\n\n\n\nAs you may have noticed, the Plots.jl documentation is build upon examples. Many recent documentations begin with examples before moving on to the general definition.\nusing StatsPlots\n\n# Array with probabilities associated to target digits for each image\nval = [m(reshape(d_test.features[:,:,i],784))[d_test.targets[i]+1] for i in 1:length(d_test.targets)]\n\ngroup = fill(\"MNIST-Test\", length(val))\n\nviolin(group, val, legend=false, title=\"Violin Plot\", ylabel=\"Target digit probability\")\nWhat do you think about the models performance based on the violin plot generated by the lines of code above?",
    "crumbs": [
      "Applications",
      "Machine Learning"
    ]
  },
  {
    "objectID": "src/index.html",
    "href": "src/index.html",
    "title": "Julia Master 1 course",
    "section": "",
    "text": "This course is adressed to the students of the Master 1 “Econométrie, Statistiques” of Toulouse School of Economics. It is part of the topic Software for Data science. The Julia course is composed of 5 slots of 3 hours. In this course, we introduce the Julia ecosystem, we present the Julia programming language and some relevant packages.\n\n\n\n\n\nIntroduction\n\n\nWhy Julia?\nGetting started\nDeveloper set up\nForetaste of Julia Code\n\n\n\n\n\n\nJulia language\n\n\nCore Syntax and Operations\nStructure your code\nTypes\nType stability for performance\nAuto-evaluation\n\n\n\n\n\n\nApplications\n\n\nRoot-Finding Methods\nMachine Learning\n\n\n\n\n\nNo matching items\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "src/why_julia.html",
    "href": "src/why_julia.html",
    "title": "Why Julia?",
    "section": "",
    "text": "Welcome to the world of Julia! This page will introduce you to the language, explaining why it’s gaining popularity, and highlighting some key features that make Julia a unique tool for scientific computing and general-purpose programming.",
    "crumbs": [
      "Introduction",
      "Why Julia?"
    ]
  },
  {
    "objectID": "src/why_julia.html#what-is-julia",
    "href": "src/why_julia.html#what-is-julia",
    "title": "Why Julia?",
    "section": "What is Julia?",
    "text": "What is Julia?\nJulia is a high-level, high-performance programming language primarily designed for technical computing. It combines the best features of other programming languages, including Python’s ease of use, C’s speed, and MATLAB’s support for numerical computation. Julia is open-source and has become a go-to language for scientific research, data analysis, and machine learning applications.",
    "crumbs": [
      "Introduction",
      "Why Julia?"
    ]
  },
  {
    "objectID": "src/why_julia.html#benefits-of-julia",
    "href": "src/why_julia.html#benefits-of-julia",
    "title": "Why Julia?",
    "section": "Benefits of Julia",
    "text": "Benefits of Julia\nJulia combines the speed of low-level languages like C++ and Fortran with the productivity of high-level languages like Python, MATLAB, and R. Here are some of its key benefits:\n\nEase of use: Julia offers a simple, intuitive syntax similar to Python and MATLAB, which makes it easy to learn and use, even for those with little programming experience.\nInteroperability: Julia integrates well with languages like Python, R, C++, and Java.\nHigh Performance: Julia is designed for performance from the ground up. It often performs on par with statically typed languages like C or Fortran, thanks to Just-In-Time (JIT) compilation using LLVM. Support for multi-threading and GPU compute is offered.\nHigh Productivity: Expressive and dynamic, Julia is up to 100x faster than traditional high-level languages.\nMultiple dispatch: Julia uses multiple dispatch as its core paradigm, which allows for highly flexible and efficient function definitions.\nDesigned for scientific computing: Julia excels in areas such as linear algebra, numerical analysis, and optimization, making it a great choice for data-heavy fields like economics, physics, and engineering.\nComposability: Packages are designed to work seamlessly together and with custom code.\nRich Ecosystem: More than 10,000 registered packages and a large community of contributors.\nUnified Language: Supports both prototyping and deployment, solving the two-language problem.",
    "crumbs": [
      "Introduction",
      "Why Julia?"
    ]
  },
  {
    "objectID": "src/why_julia.html#the-two-language-problem",
    "href": "src/why_julia.html#the-two-language-problem",
    "title": "Why Julia?",
    "section": "The Two-Language Problem",
    "text": "The Two-Language Problem\nTraditionally, programming required both a high-level, slower language for prototyping and a low-level, faster language for production, causing inefficiencies. Julia unifies these two needs into one language, allowing:\n\n\n\n\n\n\n\n\nAspect\nHigh-Level Language (e.g., Python)\nLow-Level Language (e.g., C++)\n\n\n\n\nPros\nEasy to write and read\nFast in production\n\n\nCons\nSlow in production\nComplex, lengthy code\n\n\nJulia’s Solution\nCombines ease of high-level with speed of low-level, eliminating the need for separate languages for research and production.",
    "crumbs": [
      "Introduction",
      "Why Julia?"
    ]
  },
  {
    "objectID": "src/why_julia.html#comparisons",
    "href": "src/why_julia.html#comparisons",
    "title": "Why Julia?",
    "section": "Comparisons",
    "text": "Comparisons\nIf you want to know for instance the date of the first public release, the price and the names of the creators of numerical-analysis softwares, please visite the Wikipedia page.\nJulia is made for scientific computing as shown by the table below which compares some languages in terms of differential equation solvers. For more details visit this page.\n\n  \n\nYou can find here cheatsheets. One interesting is the comparison with Python and R.\n\n  \n\nOne goal of Julia is to be efficient and high-level. This is illustrated by the following figure given by the Mandelbrot benchmark project.",
    "crumbs": [
      "Introduction",
      "Why Julia?"
    ]
  },
  {
    "objectID": "src/why_julia.html#julia-ecosystem",
    "href": "src/why_julia.html#julia-ecosystem",
    "title": "Why Julia?",
    "section": "Julia Ecosystem",
    "text": "Julia Ecosystem\nThe Julia programming language has a rich ecosystem of tools, platforms, and communities that can help you develop, deploy, and scale your applications. This section will introduce some key components of the Julia ecosystem, including JuliaHub, JuliaSim, JuliaCon, and other important resources. The Julia ecosystem is growing rapidly, offering a wide range of tools for scientific computing, data science, and application development. Platforms like JuliaHub, simulation tools like JuliaSim, and community events like JuliaCon are all central to the ecosystem and provide invaluable resources to Julia users.\n\nJuliaHub\nJuliaHub is an online platform developed by Julia Computing that provides cloud-based access to Julia environments. It offers managed Julia instances, making it easier to share and deploy Julia-based projects without the need to worry about local setup. JuliaHub also supports collaboration on Julia projects and integrates with popular tools such as Jupyter notebooks.\nFeatures of JuliaHub include:\n\nCloud-based Julia environments: Run Julia code on the cloud without any installation.\nPackage management: Seamless integration with Julia’s package manager.\nCollaboration: Share Julia code and data with colleagues and collaborators.\nJupyter notebooks: Use Jupyter notebooks hosted on JuliaHub for interactive computing.\n\n\n\nJuliaSim\nJuliaSim is a collection of tools and libraries for modeling and simulation, built using Julia. It is designed for systems simulation in fields such as engineering, physics, and finance. JuliaSim offers several packages and tools to help you build and simulate complex models, as well as visualize and analyze the results.\nFeatures of JuliaSim include:\n\nDifferential equation solving: Tools like DifferentialEquations.jl are used to solve complex systems of differential equations.\nSimulations in science and engineering: Use JuliaSim to simulate and analyze physical, chemical, and biological systems.\nFast performance: The high-performance capabilities of Julia make JuliaSim ideal for computationally intensive simulations.\n\n\n\nJuliaCon\nJuliaCon is the annual conference for the Julia community, where developers, researchers, and users come together to share the latest developments, discuss best practices, and showcase their Julia projects. JuliaCon features keynote speakers, tutorials, workshops, and talks on a wide range of topics related to Julia programming.\nKey features of JuliaCon:\n\nWorkshops and tutorials: Learn Julia directly from experts through hands-on workshops.\nNetworking: Meet fellow Julia users, contributors, and researchers to collaborate on projects and research.\nTalks and presentations: Hear about cutting-edge developments in Julia from experts in various fields.\n\nAnd a JuliaCon was even held here in Toulouse!",
    "crumbs": [
      "Introduction",
      "Why Julia?"
    ]
  },
  {
    "objectID": "src/foretaste_of_julia_code.html",
    "href": "src/foretaste_of_julia_code.html",
    "title": "Foretaste of Julia Code",
    "section": "",
    "text": "Julia is a high-level, high-performance programming language primarily designed for numerical and scientific computing. Its syntax is familiar to users of other technical computing environments, while its flexibility and performance make it an excellent choice for a wide range of applications. In this section, we will look at a few simple examples to illustrate some core features of Julia and demonstrate its intuitive and powerful design.",
    "crumbs": [
      "Introduction",
      "Foretaste of Julia Code"
    ]
  },
  {
    "objectID": "src/foretaste_of_julia_code.html#variables",
    "href": "src/foretaste_of_julia_code.html#variables",
    "title": "Foretaste of Julia Code",
    "section": "Variables",
    "text": "Variables\n\nSimple Assignment\nIn Julia, you can assign values to variables directly:\n\nx = 1   # Assign an integer to x\n2x      # The result of 2 * x\n\n2\n\n\n\n\nMathematical Operations\nYou can also perform mathematical operations directly on variables:\n\nx = sqrt(2)    # Assign the square root of 2 to x\nx              # Output the value of x\n\n1.4142135623730951\n\n\n\n\nUsing Unicode\nJulia allows you to use Unicode characters in your code, which makes it more expressive:\n\n# Unicode is great\nx = √(2)        # Square root symbol for 2\nx               # The value of x is the square root of 2\n\n1.4142135623730951\n\n\n\n\nCustom Variable Names\nJulia even allows using emojis for variable names:\n\n😄 = sqrt(2)    # Assign the square root of 2 to the emoji variable\n2😄              # Result of 2 times 😄\n\n2.8284271247461903\n\n\n\n\n\n\n\n\nNote\n\n\n\nVisit the list of Unicode Input for more examples.",
    "crumbs": [
      "Introduction",
      "Foretaste of Julia Code"
    ]
  },
  {
    "objectID": "src/foretaste_of_julia_code.html#functions",
    "href": "src/foretaste_of_julia_code.html#functions",
    "title": "Foretaste of Julia Code",
    "section": "Functions",
    "text": "Functions\n\nSimple Function Definition\nIn Julia, you can define a function using the function keyword:\n\n# this is a function\nfunction f(x)\n  return 2x + 1   # Return a value that is double x plus 1\nend\n\nf (generic function with 1 method)\n\n\nTo evaluate a function, simply call it with an argument:\n\nf(2)  # Output: 5\n\n5\n\n\n\n\nFunction Definition in Assignment Form\nJulia also supports defintion of functions in assignement form, which are often used for short operations:\n\n# This is also a function\ng(x) = 2x + 1   # A shorthand for defining a function\ng(2)            # Output: 5\n\n5\n\n\n\n\nAnonymous Functions\nJulia also supports anonymous functions (functions without a name):\n\n# Another example with anonymous function\nh = x -&gt; 2x^2    # Function definition using the arrow syntax\nh(1)             # Output: 2, since 2 * 1^2 = 2\n\n2\n\n\n\n\nFunction Priority and Operator Precedence\nIn some cases, you need to be cautious about operator precedence:\n\n# Be careful of operator priorities\nh(1 + 1)  # The correct evaluation is 2 * (1+1)^2 = 8\n\n8",
    "crumbs": [
      "Introduction",
      "Foretaste of Julia Code"
    ]
  },
  {
    "objectID": "src/foretaste_of_julia_code.html#side-effects",
    "href": "src/foretaste_of_julia_code.html#side-effects",
    "title": "Foretaste of Julia Code",
    "section": "Side Effects",
    "text": "Side Effects\nIn Julia, functions can have side effects, meaning they modify variables or objects outside the scope of the function. Here’s an example:\n\nMutating Vectors\nLet’s consider the following vector:\n\nx = [1, 3, 12]\n\n3-element Vector{Int64}:\n  1\n  3\n 12\n\n\nYou can access an element of the vector like this:\n\nx[2]  # Output: 3, the second element of the array\n\n3\n\n\nTo update an element, simply reassign it:\n\nx[2] = 5  # Changes the second element to 5\nx         # Now x = [1, 5, 12]\n\n3-element Vector{Int64}:\n  1\n  5\n 12\n\n\n\n\nSide Effects in Functions\nIf you mutate data inside a function, it will have side effects. For example, consider this function:\n\nfunction f(x, y)\n    x[1] = 42        # Mutates x\n    y = 7 + sum(x)   # New binding for y, no mutation\n    return y\nend\n\na = [4, 5, 6]\nb = 3\n\nprintln(\"f($a, $b) = \", f(a, b))  # f modifies 'a' but not 'b'\nprintln(\"a = \", a, \" # a[1] is changed to 42 by f\")\nprintln(\"b = \", b, \" # b remains unchanged\")\n\nf([4, 5, 6], 3) = 60\na = [42, 5, 6] # a[1] is changed to 42 by f\nb = 3 # b remains unchanged\n\n\n\n\nThe Bang Convention\nWhen a function has side effects, it’s a good practice to use the ! symbol at the end of the function’s name. This is called the bang convention, and it signals that the function mutates its arguments:\n\nfunction put_at_second_place!(x, value)\n  x[2] = value\n  return nothing  # No explicit return, it's just a side effect\nend\n\nx = [1, 3, 12]\nprintln(\"x[2] before: \", x[2])\n\nput_at_second_place!(x, 5)  # Mutates x\nprintln(\"x[2] after: \", x[2])\n\nx[2] before: 3\nx[2] after: 5\n\n\n\n\nCaution with Slices\nWhen you pass a slice of an array to a function in Julia, the slice is actually a copy, so modifying it does not alter the original array:\n\nx = [1, 2, 3, 4]\nprintln(\"x[2] before slice modification: \", x[2])\n\nput_at_second_place!(x[1:3], 15)  # Safe to modify the slice\n\nprintln(\"x[2] after slice modification: \", x[2])  # Original array remains unchanged\n\nx[2] before slice modification: 2\nx[2] after slice modification: 2\n\n\n\n\n\n\n\n\nTip\n\n\n\nWhen working with slices, remember that they are copies in Julia. Modifying a slice will not impact the original array, which helps prevent unintentional changes to your data.",
    "crumbs": [
      "Introduction",
      "Foretaste of Julia Code"
    ]
  },
  {
    "objectID": "src/foretaste_of_julia_code.html#methods",
    "href": "src/foretaste_of_julia_code.html#methods",
    "title": "Foretaste of Julia Code",
    "section": "Methods",
    "text": "Methods\nJulia supports multiple methods for the same function name, which allows for more flexible and dynamic behavior. Here’s an example:\n\nMethod Overloading\nYou can define several methods for the same function with different types:\n\nΣ(x::Float64, y::Float64) = 2x + y   # Method for Float64 inputs\n\nΣ (generic function with 1 method)\n\n\nCalling the function:\n\nΣ(2.0, 3.0)  # Output: 7.0\n\n7.0\n\n\nIf you call Σ with arguments that don’t match the types, Julia will throw an error:\n\nΣ(2, 3.0)  # Error: no method matching Σ(::Int64, ::Float64)\n\n\nMethodError: no method matching Σ(::Int64, ::Float64)\nThe function `Σ` exists, but no method is defined for this combination of argument types.\n\nClosest candidates are:\n  Σ(::Float64, ::Float64)\n   @ Main In[18]:1\n\n\nStacktrace:\n [1] top-level scope\n   @ In[20]:1\n\n\n\n\n\nMultiple Methods for Different Types\nYou can define more methods that work with different types:\n\nφ(x::Number, y::Number) = 2x - y           # General method for numbers\nφ(x::Int, y::Int)     = 2x * y             # Method for integers\nφ(x::Float64, y::Float64) = 2x + y         # Method for Float64\n\nφ (generic function with 3 methods)\n\n\n\n\nMethod Dispatch Example\nJulia will select the appropriate method based on the argument types:\n\nprintln(\"φ(2,   3.0) = \", φ(2, 3.0))       # Uses general method\nprintln(\"φ(2,   3)   = \", φ(2, 3))         # Uses the integer method\nprintln(\"φ(2.0, 3.0) = \", φ(2.0, 3.0))     # Uses the Float64 method\n\nφ(2,   3.0) = 1.0\nφ(2,   3)   = 12\nφ(2.0, 3.0) = 7.0",
    "crumbs": [
      "Introduction",
      "Foretaste of Julia Code"
    ]
  },
  {
    "objectID": "src/foretaste_of_julia_code.html#iterators",
    "href": "src/foretaste_of_julia_code.html#iterators",
    "title": "Foretaste of Julia Code",
    "section": "Iterators",
    "text": "Iterators\nIn Julia, iterators allow you to loop through collections in a memory-efficient way. Here’s an example of using 1:5 as an iterator:\n\nfor i in 1:5\n    println(i)\nend\n\n1\n2\n3\n4\n5\n\n\nThis prints the numbers from 1 to 5. You can also iterate through ranges and collections:\n\nfor i in [10, 20, 30]\n    println(i)\nend\n\n10\n20\n30\n\n\n\nWorking with Lazy Collections\nJulia’s Iterators package allows for lazy collections, where values are computed on demand. Here’s an example:\n\nusing Base.Iterators: cycle\nround = 1\nfor i in cycle([1, 2, 3])\n    println(i)\n    if i == 3\n      if round == 2\n        break\n      else\n        round += 1\n      end\n    end\nend\n\n1\n2\n3\n1\n2\n3\n\n\nThis loops over the values 1, 2, and 3, repeating as a cycle.",
    "crumbs": [
      "Introduction",
      "Foretaste of Julia Code"
    ]
  },
  {
    "objectID": "src/foretaste_of_julia_code.html#type-stability",
    "href": "src/foretaste_of_julia_code.html#type-stability",
    "title": "Foretaste of Julia Code",
    "section": "Type Stability",
    "text": "Type Stability\nJulia has type stability for fast compilation and execution. When writing functions, it’s important to ensure that the type of the return value can be determined without ambiguity.\nExample of type instability:\n\nfunction f(x)\n    if x &gt; 0\n        return 1\n    else\n        return 0.0\n    end\nend\n\nprintln(\"The value  2 of type \", typeof( 2), \" produces an output of type \", typeof(f( 2)))\nprintln(\"The value -2 of type \", typeof(-2), \" produces an output of type \", typeof(f(-2)))\n\nThe value  2 of type Int64 produces an output of type Int64\nThe value -2 of type Int64 produces an output of type Float64\n\n\nJulia is dynamically typed, but ensuring type stability within functions helps the compiler optimize code for better performance.\n\n\n\n\n\n\nTip\n\n\n\nFor better performance, always try to ensure type stability in your functions. This can be achieved by making the return type predictable, from the types of input variables and not their values.",
    "crumbs": [
      "Introduction",
      "Foretaste of Julia Code"
    ]
  },
  {
    "objectID": "src/performance.html",
    "href": "src/performance.html",
    "title": "Type stability for performance",
    "section": "",
    "text": "This page provides in introduction to performance enhancement in Julia. First, we’ll take a look at the fundamentals of computer hardware, understanding how processors and memory impact the speed of your code. Once we grasp these hardware concepts, we’ll explore how type-stability in Julia can significantly enhance performance by enabling the compiler to generate more efficient machine code.",
    "crumbs": [
      "Julia language",
      "Type stability for performance"
    ]
  },
  {
    "objectID": "src/performance.html#simplified-hardware",
    "href": "src/performance.html#simplified-hardware",
    "title": "Type stability for performance",
    "section": "Simplified hardware",
    "text": "Simplified hardware\n(Ref. Jakob Nissen, Hardware for scientists)\nBefore we dive into the software side of performance, let us gain a basic understanding of computer hardware. The following schematic provides a simplified representation of a computer.\n[CPU] \\Leftrightarrow [RAM] \\Leftrightarrow [DISK]\nIn this figure, where the arrows represent bidirectional data flows, the three important components are:\n\nThe central processing unit (CPU) where all the computations occur;\nRandom access memory (RAM) which is a temporary memory. Data stored here is lost in case of power failure;\nThe disk which is the persistent storage of the computer.\n\nThe operations executed by the CPU are coordinated by its internal clock. A clock cycle refers to the time required to execute a basic operation. To be executed a program has to be broken down into CPU instructions, a set of operations. This translation is done by the compiler. Any optimisation performed at compile time allows to generate more efficient CPU instructions, which speeds up the program runtime.\n\n\n\n\n\n\nRemember\n\n\n\nTo run, any program has to be compiled to CPU instructions.\n\n\nThe execution of a program requires data stored in the RAM. Note that the number of clock cycles required to transfer data from the RAM to the CPU is on the order of magnitude of 500 clock cycles.\n\n\n\n\n\n\nRemember\n\n\n\nData transfers from RAM to CPU are slow.\n\n\nIn order to limit data transfers between the CPU and RAM, there are intermediate storage spaces with, however, limited capacity. Closest to the CPU compute cores are the registers which store very limited data compared to the various levels of cache further away. The simplified computer schematic can be updated.\n[CPU] \\Leftrightarrow [Registers] \\Leftrightarrow [Caches] \\Leftrightarrow [RAM] \\Leftrightarrow [DISK]\n\n\n\n\n\n\nThe documentation of Julia mentions “Multidimensional arrays in Julia are stored in column-major order”. We wish to sum the elements of a matrix. How to write a cache-efficient program to do this computation?\n\n\n\n\n\nIn column-major order, the elements of each column are stored contiguously in memory. When the CPU accesses data, it pulls in cache lines (typically 64 bytes) from RAM into cache. So access patterns matter a lot.\n\nCache-Friendly Access\n\nsum = 0.\nfor j in 1:n\n    for i in 1:m\n        sum = sum + A[i,j]\n    end\nend\n\n\n\nCache-Unfriendly Access\n\nsum = 0.\nfor i in 1:m\n    for j in 1:n\n        sum = sum + A[i,j]\n    end\nend\n\nEach inner loop iteration skips over columns, which are non-contiguous in memory. This induces so called cache misses.",
    "crumbs": [
      "Julia language",
      "Type stability for performance"
    ]
  },
  {
    "objectID": "src/performance.html#type-stability",
    "href": "src/performance.html#type-stability",
    "title": "Type stability for performance",
    "section": "Type-stability",
    "text": "Type-stability\n(Ref. Chris Rackauckas, Parallel Computing and Scientific Machine Learning (SciML): Methods and Applications)\nCommon knowledge has it that Julia is fast because it is Just-in-Time (JIT) compiled. The actual reason is the type inference algorithm executed before the compiler combined with type specialization in functions.\nRecall the hardware point of view. Let a CPU instruction read a value from a register. How to interpret the memory of that value?\nThis is straight forward if the instruction has the type information. Take a 64 bit integer and a 64 bit floating point number. They require the same memory space. However, the associated memory chunck is interpreted differently. The binary representation of that integer is [sign bit][value in two's complement on 63 bits] and [sign bit][11 exponent bits][52 mantissa bits] for the floating point number. This is what happens when writing code in the C or Fortran languages, which require explicit typing.\n\n\n\n\n\n\nNumber representation\n\n\n\n\n\nLet b \\geq 2 be a base used for numerical encoding. Any positive number can be expressed in this base as a sum of the form\n\n\\sum_{k=0}^{q} c_k b^k.\n\nComputers typically use binary encoding, where the base b is 2. The coefficients c_k, known as bits (and often grouped in sets of 8 called bytes), represent the digits in this base.\nIntegers\nWhen encoding an integer in binary using 64 bits, the first bit indicates the sign:\n\n0 represents a non-negative (positive or zero) number\n\n1 represents a negative number\n\nThe remaining 63 bits encode the absolute value of the integer using the binary representation of its coefficients c_k.\nFloating Point Numbers\nFloating-point number encoding was standardized in 1985 by the IEEE 754 specification. In this format, a number x is represented as:\n\nx = (-1)^s \\times M \\times 2^e\n\nwhere: - s is the sign bit (0 for positive, 1 for negative), - M is the mantissa (also called the significand), - e is the exponent.\nExample: Encoding x = 6.5\nFirst, we convert 6.5 into binary: - 6 = 4 + 2 = 2^2 + 2^1, so in binary: 110 - 0.5 = 2^{-1}, so in binary: 0.1\nThus, 6.5 in binary is 110.1.\nTo express this in normalized binary form, we rewrite it as:\n\n6.5 = 1.101 \\times 2^2\n\nHere, the exponent e = 2, and the mantissa M = 1.101.\nIEEE 754 uses a bias to store only non-negative exponent values. For double-precision (64-bit) floating-point numbers: - The exponent is stored using 11 bits, - The bias is 1023.\nSo the encoded exponent is:\n\ne_{\\text{encoded}} = e + \\text{bias} = 2 + 1023 = 1025\n\nThis value (1025) is written in binary and stored in the 11-bit exponent field.\nThe mantissa stores only the fractional part after the leading 1 (which is implicit), so we store 101 (from 1.101) and pad it with zeros to fill the 52-bit mantissa field.\n\n\n\nIn a dynamic typed language such as Python, the interpreter must operate type checks at runtime for every operation. Then the associated set of instructions for this type should be loaded. Leaving aside typing in Python makes it accessible for beginners. However, this introduces a significant execution time overhead.\n\n\n\n\n\n\nRemember\n\n\n\nType inference reduces runtime.\n\n\n\nHinting the type\nIn the Julia programming language, type information is not mandatory. Let us examine, from the software perspective, how providing hints to the type inference algorithm allows us to maximize fast executing. First, let’s try to understand what the type inference algorithm is trying to do.\n\na = 2\nb = 3\na+b\n\n5\n\n\n\n\n\n\n\n\nHow does the type inference algorithm proceed on this code snipped?\n\n\n\n\n\nThe value associated to a is the constant integer 2. The value associated to b is the constant integer 3. By the definition of the + operation on two integers, the result is an integer.\n\n\n\nThe type of a and b was found here by human knowledge. The type inference algorithm would have associated Any to both a and b. Indeed, the global scope of the REPL is too dynamic to be optimized. Further in thid section we will, thus, only consider type inference in functions.\n\nfunction f(a,b)\n    return a+b\nend\n\nf (generic function with 1 method)\n\n\nFunction f adds input variables a and b, for which no type hints are provided. Using @code_llvm, let us have a look at the associated CPU instructions for input variables of different types. The instructions generated by the compiler bellow are not in the Assembly language but in the intermediate representation (IR). It could be seen as a hardware agnostic Assembly language.\nFirst, we run f to sum two integers, 1+2.\n\n@code_llvm f(1,2)\n\n; Function Signature: f(Int64, Int64)\n;  @ In[4]:1 within `f`\ndefine i64 @julia_f_8979(i64 signext %\"a::Int64\", i64 signext %\"b::Int64\") #0 {\ntop:\n;  @ In[4]:2 within `f`\n; ┌ @ int.jl:87 within `+`\n   %0 = add i64 %\"b::Int64\", %\"a::Int64\"\n; └\n  ret i64 %0\n}\n\n\nThen, we run f to sum two floating point numbers, 1.5+2.5.\n\n@code_llvm f(1.5,2.5)\n\n; Function Signature: f(Float64, Float64)\n;  @ In[4]:1 within `f`\ndefine double @julia_f_9061(double %\"a::Float64\", double %\"b::Float64\") #0 {\ntop:\n;  @ In[4]:2 within `f`\n; ┌ @ float.jl:491 within `+`\n   %0 = fadd double %\"a::Float64\", %\"b::Float64\"\n; └\n  ret double %0\n}\n\n\n\n\n\n\n\n\nHow does the type of the input variables influence the type of the returned value?\n\n\n\n\n\nThe function f(Int64, Int64) produces an i64 in register %0. i64 refers to an integer value stored on 64 bits.\nSimilarly, f(Float64, Float64) produces a double. The term double is equivalent to Float64 which refers to a floating point number stored on 64 bits.\n\n\n\nLet us have a look at what happens when we mix types in the function call. We run f to add an integer 1 and a floating point number 2.5.\n\n@code_llvm f(1,2.5)\n\n; Function Signature: f(Int64, Float64)\n;  @ In[4]:1 within `f`\ndefine double @julia_f_9065(i64 signext %\"a::Int64\", double %\"b::Float64\") #0 {\ntop:\n;  @ In[4]:2 within `f`\n; ┌ @ promotion.jl:429 within `+`\n; │┌ @ promotion.jl:400 within `promote`\n; ││┌ @ promotion.jl:375 within `_promote`\n; │││┌ @ number.jl:7 within `convert`\n; ││││┌ @ float.jl:239 within `Float64`\n       %0 = sitofp i64 %\"a::Int64\" to double\n; │└└└└\n; │ @ promotion.jl:429 within `+` @ float.jl:491\n   %1 = fadd double %0, %\"b::Float64\"\n; └\n  ret double %1\n}\n\n\nWe can see the term promote in the output. Thus, the compiler found a type that works as a common ground for the computation.\n\n\nType unstability\nIn the previous examples, identifying the type of the returned value was a relatively straightforward process. Let us examine the function h, which breaks type stability. We are interested in understanding the reasons behind this problem and techniques to prevent it in our own code, with the aim of achieving optimal performance.\n\nfunction h(x,y)\n  z = x + y\n  if z &lt; 2\n    return z\n  else\n    return Float64(z)\n  end\nend\n\nh (generic function with 1 method)\n\n\nUsing @code_warntype provides type labels for all the variables of a function. We are particularly interested in the type returned by h.\n\n@code_warntype h(2,5)\n\nMethodInstance for h(::Int64, ::Int64)\n  from h(x, y) @ Main In[8]:1\nArguments\n  #self#::Core.Const(Main.h)\n  x::Int64\n  y::Int64\nLocals\n  z::Int64\nBody::Union{Float64, Int64}\n1 ─      (z = x + y)\n│   %2 = z::Int64\n│   %3 = (%2 &lt; 2)::Bool\n└──      goto #3 if not %3\n2 ─ %5 = z::Int64\n└──      return %5\n3 ─ %7 = z::Int64\n│   %8 = Main.Float64(%7)::Float64\n└──      return %8\n\n\n\n\n\n\n\n\n\nWhy does h break type stability?\n\n\n\n\n\nThe type of the output of h is said to be Union{Float64, Int64}. Whether it is Int64 or Float64 does not depend on the type of the input variables. The output type is determined by the value of the x + y sum. This information can not be predicted at compile time since it depends on the values for which h is called. Thus, the compiler can only restrict the output to Union{Float64, Int64}.\nNote the color code used in the output of @code_warntype. The output for which the type could not be inferred is written in yellow.\n\n\n\nAn other maner to determine type-stability of a function is to use @inferred.\n\nusing Test\n@inferred h(2,5)\n\n\nreturn type Float64 does not match inferred return type Union{Float64, Int64}\n\nStacktrace:\n [1] error(s::String)\n   @ Base ./error.jl:35\n [2] top-level scope\n   @ In[10]:2\n\n\n\nThe error raised shows this function to be a simple test (yes or no) about inference.\n\n\n\n\n\n\nTry @warn_type and @inferred out on previously defined function f. What do you get?\n\n\n\n\n\n\n@code_warntype f(2,5)\n\nMethodInstance for f(::Int64, ::Int64)\n  from f(a, b) @ Main In[4]:1\nArguments\n  #self#::Core.Const(Main.f)\n  a::Int64\n  b::Int64\nBody::Int64\n1 ─ %1 = (a + b)::Int64\n└──      return %1\n\n\n\nThe type of the sum of those two integers was correctly inferred: Body::Int64. Let us confirm with @inferred.\n\n@inferred f(2,5)\n\n7\n\n\nThe result of the sum is shown (and no error is thrown). This means that the type inference algorithm was successful.\n\n\n\nFrom this analysis we conclude the following rule.\n\n\n\n\n\n\nRemember\n\n\n\nThe type of the output of a function should be inferrable from the type of the inputs.",
    "crumbs": [
      "Julia language",
      "Type stability for performance"
    ]
  },
  {
    "objectID": "src/getting_started.html",
    "href": "src/getting_started.html",
    "title": "Getting Started with Julia",
    "section": "",
    "text": "This page is designed to help you with the installation process. You’ll learn how to install Julia on different operating systems and how to verify the installation. It also covers using the Julia REPL for interactive coding. Additionally, this page provides resources for learning and getting help with Julia based on the official documentation.",
    "crumbs": [
      "Introduction",
      "Getting started"
    ]
  },
  {
    "objectID": "src/getting_started.html#installing-julia",
    "href": "src/getting_started.html#installing-julia",
    "title": "Getting Started with Julia",
    "section": "Installing Julia",
    "text": "Installing Julia\n\nDownload Julia\nTo get started with Julia, you first need to install the language on your computer. The official Julia website provides the installation files for various operating systems, including Windows, macOS, and Linux. Follow these steps:\n\nVisit the official Julia Downloads page.\nChoose the appropriate version of Julia for your operating system.\nDownload the installer (the latest stable version is recommended for most users).\n\n\n\nInstallation Instructions\nBefore you can start using Julia, you need to install it on your system. Below are the steps for installing Julia on different operating systems: Mac, Linux, and Windows.\n\nMac / LinuxWindows\n\n\nTo install the latest stable version of Julia on Mac or Linux, follow these simple steps:\n\nOpen your terminal.\nRun the following command to download and install Julia:\n\ncurl -fsSL https://install.julialang.org | sh\nThis command downloads the Julia installation script and runs it automatically. It will install Julia and place it in your /usr/local/bin directory by default.\n\n\nTo install Julia on Windows, follow these steps:\n\nOpen the Microsoft Store page for Julia.\nClick “Get” to download and install the latest version of Julia from the Microsoft Store.\n\nAlternatively, you can install Julia using the Windows Package Manager (winget). Open the command prompt and run the following command:\nwinget install julia -s msstore\nAfter installation, you can launch Julia by searching for it in the Start menu or by running julia in the command prompt.\n\n\n\n\n\nVerify Installation\nAfter installation, you can verify that Julia is correctly installed by opening a terminal or command prompt and typing the following command:\njulia\nThis will launch the Julia REPL (Read-Eval-Print Loop), where you can start running Julia commands interactively. You should see something similar to the following:\n\n\n               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type \"?\" for help, \"]?\" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.11.6 (2025-07-09)\n _/ |\\__'_|_|_|\\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\n\njulia&gt;\n\n\nIf you see this prompt, it means Julia is installed and working correctly!",
    "crumbs": [
      "Introduction",
      "Getting started"
    ]
  },
  {
    "objectID": "src/getting_started.html#using-the-julia-repl",
    "href": "src/getting_started.html#using-the-julia-repl",
    "title": "Getting Started with Julia",
    "section": "Using the Julia REPL",
    "text": "Using the Julia REPL\nThe Julia REPL (Read-Eval-Print Loop) is an interactive command-line environment for executing Julia code. It allows you to run Julia code line-by-line, evaluate expressions, and see the results immediately.\nYou have already used it when checking the installation of Julia by typing julia in a terminal or command prompt. Let us start typing Julia expressions.\n\nBasic Commands\nIn the REPL, you can type expressions and commands. For example:\n\nTo perform a simple arithmetic operation, type:\n\n3 + 4\nThe result will appear right below the command, like so:\n7\n\nTo assign a value to a variable, use the = sign:\n\nx = 10\nNow, x holds the value 10. You can use it in further expressions:\nx * 2\nThe result will be:\n20\n\n\nUsing REPL Features\nThe Julia REPL has several features that make it more convenient to use:\n\nHistory: You can use the up and down arrow keys to scroll through your command history and reuse previous commands.\nTab Completion: Type part of a function or variable name and press Tab to automatically complete it or show suggestions.\nHelp: Type ? followed by a function or type name to get documentation directly in the REPL. For example:\n\n?sum\nThis will show information about the sum function.\n\nExiting the REPL: To exit the REPL, simply type:\n\nexit()\nOr press Ctrl-D (on most systems).\n\n\nREPL Modes\nThe Julia REPL has different prompt modes that can be very useful to install / remove packages (libraries), run shell commands, search for help, etc. The different modes are:\n\nThe Julia mode\nHelp mode\nPackage mode\nShell mode\n\nVisit the command-line REPL page for more details.\n\nHelp modePackage modeShell mode\n\n\nBy pressing ? you can obtain information and metadata about Julia objects (functions, types, etc.) or unicode symbols. The query fetches the docstring of the object, which explains how to use it.\nhelp?&gt; println\nIf you don’t know the exact name you are looking for, type a word surrounded by quotes to see in which docstrings it pops up. To come back to Julia mode, hit backspace.\n\n\nBy pressing ] you access Pkg.jl, Julia’s integrated package manager. Please visit the documentation for details. Pkg.jl allows you to:\n\n]activate different local, shared or temporary environments;\n]instantiate them by downloading the necessary packages;\n]add, ]update (or ]up) and ]remove (or ]rm) packages;\nget the ]status (or ]st) of your current environment.\n\nAs an illustration, we download the package Plots.jl inside our current environment:\npkg&gt; add Plots\nNote that you can do the same in Julia mode:\njulia&gt; using Pkg\njulia&gt; Pkg.rm(\"Plots\")\nThe package mode itself also has a help mode, accessed with ?. To come back to Julia mode, hit backspace.\n\n\nBy pressing ; you enter a terminal, where you can execute any command you want. Here’s an example for Unix systems:\nshell&gt; pwd\nTo come back to Julia mode, hit backspace.",
    "crumbs": [
      "Introduction",
      "Getting started"
    ]
  },
  {
    "objectID": "src/getting_started.html#julia-documentation",
    "href": "src/getting_started.html#julia-documentation",
    "title": "Getting Started with Julia",
    "section": "Julia Documentation",
    "text": "Julia Documentation\nOne of the key strengths of Julia is its comprehensive and easy-to-navigate documentation. Julia’s official documentation provides detailed explanations of the language features, standard libraries, and tools available for developers.\n\nOfficial Documentation\nThe official Julia documentation is a complete reference guide for the language. You can find it here:\n\nJulia Documentation Website\n\nThis documentation covers everything from basic syntax to advanced topics like parallel computing and package management.\nExample. Search how to compute the norm of a vector.\n\nThe norm function comes from the standard librairy LinearAlgebra.\n\nHowever, we are not directly at the right place, so I recommend to use the Search docs field.\n\nAnd now, we have the documentation.\n\n\n\n\n\n\n\nNote\n\n\n\nYou can also access the Julia documentation directly from the Julia REPL using the ? (help) command.\n\n\n\n\nAccessing Help in the REPL\nThe REPL provides a built-in help system that can assist you in looking up functions, types, and more. Here’s how you can use it:\n\nLook up a function or keyword: Type ? followed by the function name or keyword you want help with.\n?println\nThis will display the documentation for the println function.\nSearch for a keyword: You can also type just ? followed by a search term to find relevant functions or types in the documentation.\n?array\nThis will display documentation related to arrays in Julia.\n\n\n\nAdditional Resources\n\nJulia Language GitHub: Julia GitHub Repository — Contains the source code and development discussion.\nJulia Discourse: Julia Discourse Forum — A community forum where you can ask questions, share ideas, and discuss Julia-related topics.\nJuliaLang Slack: Join Slack Community — An official Slack workspace for the Julia community.\nJulia Community: Julia Community — A hub for Julia community resources, including events, blogs, and videos.",
    "crumbs": [
      "Introduction",
      "Getting started"
    ]
  },
  {
    "objectID": "src/syntax.html",
    "href": "src/syntax.html",
    "title": "Core Syntax and Operations",
    "section": "",
    "text": "Julia is fundamentally an imperative programming language, where the flow of execution is defined by sequences of commands or statements that change the program’s state. Core features include:\nWhile imperative programming emphasizes how a task is accomplished (e.g., through loops, conditionals, and assignments), declarative programming focuses on what the result should be, leaving the “how” to the language or framework. Julia is versatile and can incorporate elements of declarative programming, such as high-level operations on collections and functional programming paradigms, but its foundation is firmly rooted in imperative concepts.",
    "crumbs": [
      "Julia language",
      "Core Syntax and Operations"
    ]
  },
  {
    "objectID": "src/syntax.html#basics",
    "href": "src/syntax.html#basics",
    "title": "Core Syntax and Operations",
    "section": "Basics",
    "text": "Basics\n\nAssignment\nIn Julia, variables are assigned using the = operator:\n\nx = 5\ny = \"Hello, Julia!\"\n\nJulia is dynamically typed, which means variables do not require explicit type declarations. Types are inferred based on the assigned value.\nFrom math lectures, we recall 5 \\in \\mathbb{N}. We expect the outcome of the typeof function to tell us that x holds an integer.\n\ntypeof(x)\n\nInt64\n\n\nIndeed, Int64 is a label which refers to an integer storage format.\nSimilarly, the quotation marks around the sequence of characters show that y holds text, known as a string in programming languages—a way to represent words, sentences, or any combination of characters.\n\ntypeof(y)\n\nString\n\n\nThe return value thus validates that the kind of data contained in y is a string. We would use the term character (Char in short) if y would hold a single basic unit of information (a letter, number, symbol, or control code), like in y = \"a\". Note that it is possible to indicate to Julia the kind of data we want a variable to hold, this is called annotating. For y to hold only sequences of characters, we would write y::String = \"Hello, Julia!\".\nVariables act as labels pointing to values and can be reassigned without restrictions on type. This dynamic behavior is a hallmark of imperative languages.\n\n\nUnicode Characters\nJulia supports Unicode characters, enhancing code readability, especially for mathematical and scientific computations:\n\nα = 10\nβ = α + 5\nprintln(\"β = $β\")\n\nβ = 15\n\n\nUnicode symbols can be entered using \\name followed by Tab (e.g., \\alpha → α). A complete list of Unicode characters is available in the Julia Unicode documentation.\n\n\nComments\nComments are written with the # symbol. Julia also supports multiline comments with #= and =#:\n\n# This is a single-line comment\n\n#= \nThis is a \nmultiline comment \n=#\n\n\n\nPrinting Output\nFor debugging or displaying results, Julia provides the println function:\n\nprintln(\"Hello, Julia!\")  # Prints: Hello, Julia!\nprintln(\"The value of α is \", α)\n\nHello, Julia!\nThe value of α is 10\n\n\nAdditionally, the @show macro prints both variable names and values:\n\nx = 42\n@show x   # Prints: x = 42\n\nx = 42\n\n\nYou can also use @show with multiple variables or expressions:\n\na = 10\nb = 20\n@show a + b  # Prints: a + b = 30\n@show a, b   # Prints: a = 10, b = 20\n\na + b = 30\n(a, b) = (10, 20)\n\n\n\n\nComparison Operations\nJulia includes standard comparison operators for equality and order:\n\n\n\n\n\n\n\n\n\nOperator\nPurpose\nExample\nResult\n\n\n\n\n==\nEquality check\n5 == 5\ntrue\n\n\n!= or ≠\nInequality check\n5 != 3\ntrue\n\n\n&lt;, &lt;=\nLess than, or equal\n5 &lt; 10\ntrue\n\n\n===\nObject (type and value) identity check\n5 === 5.0\nfalse\n\n\n\nExamples:\n\n5 == 5     # true\n5 != 3     # true\n5 ≠ 3      # true (using Unicode)\n5 &lt; 10     # true\n10 &gt;= 10   # true\n\"Julia\" === \"Julia\"  # true (identical strings)\n5 === 5.0  # false (different types: Int vs. Float)\n\njulia&gt; 5 == 5 = true\njulia&gt; 5 != 3 = true\njulia&gt; 5 ≠ 3 = true\njulia&gt; 5 &lt; 10 = true\njulia&gt; 10 &gt;= 10 = true\njulia&gt; \"Julia\" === \"Julia\" = true\njulia&gt; 5 === 5.0 = false\n\n\nJulia’s comparison operators return Bool values (true or false). Using these operators effectively is essential for control flow and logical expressions.\nIn Julia, the === operator checks object identity, meaning it determines if two references point to the exact same memory location or the same instance. This is a stricter comparison than ==, which only checks if two values are equivalent in terms of their contents, not if they are the same instance.\nHere’s a breakdown of === in Julia:\n\nSingletons: === is often used for checking singleton objects like nothing, true, false, and other immutable types that Julia reuses rather than copying. For instance, nothing === nothing will return true, and similarly, true === true will return true.\nImmutable Types: For immutable types like Int, Float64, etc., === and == usually give the same result since identical values are often the same instance.\nPerformance: === is generally faster than == because it doesn’t need to do a value comparison, just a memory location check. This is particularly useful when checking if a value is a specific singleton (e.g., x === nothing).\n\n\na = 1\nb = 1\na === b  # true, since 1 is an immutable integer, they are identical instances\n\nx = [1, 2]\ny = x\nx === y  # true, because x and y refer to the same object in memory\n\nx == [1, 2]   # true, because the contents are the same\nx === [1, 2]  # false, because they are different instances in memory\n\njulia&gt; a = 1\njulia&gt; b = 1\njulia&gt; a === b = true\njulia&gt; x = [1, 2]\njulia&gt; y = [1, 2]\njulia&gt; x === y = true\njulia&gt; x == [1, 2] = true\njulia&gt; x === [1, 2] = false\n\n\nIn summary, === is especially useful for checking identity rather than equality, often applied to singletons or cases where knowing the exact instance matters, as it allows for efficient and clear comparisons.",
    "crumbs": [
      "Julia language",
      "Core Syntax and Operations"
    ]
  },
  {
    "objectID": "src/syntax.html#arithmetics",
    "href": "src/syntax.html#arithmetics",
    "title": "Core Syntax and Operations",
    "section": "Arithmetics",
    "text": "Arithmetics\nJulia supports a variety of arithmetic operations that can be performed on numeric types. Below are some of the most commonly used operations:\n\nBasic Arithmetic Operations\nYou can perform basic arithmetic operations using standard operators:\n\nAddition: +\nSubtraction: -\nMultiplication: *\nDivision: // (returns a rational number, the set \\mathbb{Q}), / (returns a floating-point result, the set \\mathbb{R} in finite precision)\n\n\na = 10\nb = 3\n\nsum = a + b\ndifference = a - b\nproduct = a * b\nquotient = a / b\nrational = a // b\n\njulia&gt; a = 10\njulia&gt; b = 3\njulia&gt; sum = 13\njulia&gt; difference = 7\njulia&gt; product = 30\njulia&gt; quotient = 3.3333333333333335\njulia&gt; rational = 10//3\n\n\nA number in \\mathbb{Q} is written as a fraction of numbers from \\mathbb{N}, designated with the label Int, short for integer. Numbers in \\mathbb{R} can have infinite digits after the coma. These are truncated to be stored on a computer and designated by the label Float, short for floating-point number.\n\n\nModulo Operation\nThe modulo operator % returns the remainder of a division operation. It is useful for determining if a number is even or odd, or for wrapping around values.\n\nmodulus_result = a % b  # remainder of 10 divided by 3\n\n1\n\n\n\n\nExponentiation\nYou can perform exponentiation using the ^ operator.\n\na^2          # 10 squared\n\n100\n\n\n\n\nSummary of Arithmetic Operations\n\n\n\nOperation\nSymbol\nExample\nResult\n\n\n\n\nAddition\n+\n5 + 3\n8\n\n\nSubtraction\n-\n5 - 3\n2\n\n\nMultiplication\n*\n5 * 3\n15\n\n\nDivision\n/\n5 / 2\n2.5\n\n\nModulo\n%\n5 % 2\n1\n\n\nExponentiation\n^\n2 ^ 3\n8\n\n\n\nThese arithmetic operations can be combined and nested to perform complex calculations as needed.",
    "crumbs": [
      "Julia language",
      "Core Syntax and Operations"
    ]
  },
  {
    "objectID": "src/syntax.html#logical-operators",
    "href": "src/syntax.html#logical-operators",
    "title": "Core Syntax and Operations",
    "section": "Logical Operators",
    "text": "Logical Operators\nJulia includes standard logical operators, that combine or negate conditions:\n\n\n\nOperator\nPurpose\nExample\nResult\n\n\n\n\n&&\nLogical AND\ntrue && false\nfalse\n\n\n||\nLogical OR\ntrue || false\ntrue\n\n\n!\nLogical NOT\n!true\nfalse\n\n\n\n\na = true\nb = false\n\na && b\na || b\n!a\n\njulia&gt; a = true\njulia&gt; b = false\njulia&gt; a && b = false\njulia&gt; a || b = true\njulia&gt; !a = false\n\n\nData resulting from a computation with a logical operator can have only two possible values: true or false. This kind of data is refered to as a boolean, Bool in short.",
    "crumbs": [
      "Julia language",
      "Core Syntax and Operations"
    ]
  },
  {
    "objectID": "src/syntax.html#control-flows",
    "href": "src/syntax.html#control-flows",
    "title": "Core Syntax and Operations",
    "section": "Control Flows",
    "text": "Control Flows\nControl flow in Julia is managed through conditional statements and loops. Logical operators allow for conditions to be combined or negated.\n\nConditional Statements\nJulia supports if, elseif, and else for conditional checks:\n\nx = 10\n\nif x &gt; 5\n    println(\"x is greater than 5\")\nelseif x == 5\n    println(\"x is equal to 5\")\nelse\n    println(\"x is less than 5\")\nend\n\nx is greater than 5\n\n\nIn Julia, blocks for if, elseif, and else are closed with end. Indentation is not required by syntax but is recommended for readability.\n\n\n\n\n\n\nTip\n\n\n\nYou can follow the Blue Style conventions for Julia code. If you want to format your code you can use the package JuliaFormatter.jl.\n\n\n\n\nUsing Arithmetic in Control Flow\nYou can combine arithmetic operations with control flow statements. For example, you can use the modulo operation to check if a number is even or odd:\n\na = 10\nif a % 2 == 0\n    println(\"$a is even\")\nelse\n    println(\"$a is odd\")\nend\n\n10 is even\n\n\n\n\nTernary Operator\nFor simple conditional assignments, Julia has a ternary operator ? ::\n\ny = (x &gt; 5) ? \"Greater\" : \"Not greater\"\nprintln(y)  # Outputs \"Greater\" if x &gt; 5, otherwise \"Not greater\"\n\nGreater\n\n\n\n\nLoops\nJulia provides for and while loops for iterative tasks.\nFor Loop: The for loop iterates over a range or collection:\n\nfor i in 1:5\n    println(i)\nend\n\n1\n2\n3\n4\n5\n\n\nThis loop prints numbers from 1 to 5. The range 1:5 uses Julia’s : operator to create a sequence.\n\n\n\n\n\n\nNote\n\n\n\nThe for construct can loop on any iterable object. Visit the documentation for details.\n\n\nWhile Loop: The while loop executes as long as a condition is true:\n\ncount = 1\n\nwhile count &lt;= 5\n    println(count)\n    count += 1\nend\n\n1\n2\n3\n4\n5\n\n\nThis loop will print numbers from 1 to 5 by incrementing count each time.\n\n\nBreaking and Continuing\nJulia also has break and continue for loop control.\n\nbreak exits the loop completely.\ncontinue skips the current iteration and moves to the next one.\n\n\nfor i in 1:5\n    if i == 3\n        continue  # Skips the number 3\n    end\n    println(i)\nend\n\n1\n2\n4\n5\n\n\n\nfor i in 1:5\n    if i == 4\n        break  # Exits the loop when i is 4\n    end\n    println(i)\nend\n\n1\n2\n3\n\n\nThese control flows and logical operators allow for flexibility in executing conditional logic and repeated operations in Julia.",
    "crumbs": [
      "Julia language",
      "Core Syntax and Operations"
    ]
  },
  {
    "objectID": "src/syntax.html#linear-algebra",
    "href": "src/syntax.html#linear-algebra",
    "title": "Core Syntax and Operations",
    "section": "Linear Algebra",
    "text": "Linear Algebra\nThe mathematical operations we executed in Julia have remained basic until now. Key data representationsfor advanced numerical computations, like linear algebra, are matrices and vectors. A term that covers these representation in programming languages is Array.\n\nVector (1D Array)\n\nThe elements of a vector are encompassed by brackets and separated by comas in Julia.\n\n# Column vector (default in Julia)\nv = [1, 2, 3]\n\n3-element Vector{Int64}:\n 1\n 2\n 3\n\n\nTo access an element of the vector, the name of the vector variable (v) is followed by brackets which hold the element index (1 for the first one).\n\n# Accessing elements\nprintln(v[1])   # Output: 1\n\n1\n\n\nLet us now see how to do the sum of two vectors.\n\n# Vector operations\nw = [4, 5, 6]\nprintln(v + w) # Vector addition: [5, 7, 9]\n\n[5, 7, 9]\n\n\n\nMatrix (2D Array)\n\nA matrix is defined similarly as a vector. The elements of the matrix are given matrix line by matrix line seperated by ;.\n\n# 2x2 Matrix\nA = [1 2; 3 4]\n\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\n\nTo access matrix elements the row index (1 here) and the column index (2 here) should be provided.\n\n# Accessing elements (row, column)\nprintln(A[1, 2])   # Output: 2\n\n2\n\n\nFind bellow standard matrix operations: transposing a matrix and multiplying matrices.\n\n# Matrix transpose\nprintln(transpose(A))  # [1 3; 2 4]\n\n# Matrix multiplication\nB = [5 6; 7 8]\nprintln(A * B)     # Matrix multiplication\n\n[1 3; 2 4]\n[19 22; 43 50]\n\n\n\nExercise\nA linear system is a system of the form Ax=b composed of a matrix A and two vectors x and b. In such a computation A and b are known and we wish to determine x. To do so, we need multiply b on the left by the inverse of A. Informally, we could say that we devide b by A.\n\n\n\n\n\n\nFind the operator from the standard library Base to solve this linear system.\n\n\n\n\n\n\nA = [2 3; 1 -1]\nb = [8; 2]\n\nx = A \\ b\nprintln(\"Solution : x = [\", x[1], \", \", x[2], \"]\")\n\nSolution : x = [2.8, 0.8]\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nRecall to add LinearAlgebra in the environment of your work directory.",
    "crumbs": [
      "Julia language",
      "Core Syntax and Operations"
    ]
  },
  {
    "objectID": "src/syntax.html#data",
    "href": "src/syntax.html#data",
    "title": "Core Syntax and Operations",
    "section": "Data",
    "text": "Data\nData management is a critical component of modern computing, as most computational tasks today rely on input datasets to drive analysis, inform decisions, and generate meaningful results. Julia offers a rich ecosystem of packages for handling, transforming, and analyzing data efficiently.\n\nDictionaries (Dict)\nA Dict in Julia allows to store structured data by mapping keys to values. Let us illustrate this with the example of a dictionary storing the characteristics of a persion.\n\n# Create a dictionary\nperson = Dict(\"name\" =&gt; \"Alice\", \"age\" =&gt; 28, \"city\" =&gt; \"Toulouse\")\n\nDict{String, Any} with 3 entries:\n  \"name\" =&gt; \"Alice\"\n  \"city\" =&gt; \"Toulouse\"\n  \"age\"  =&gt; 28\n\n\nWe can change the value associated to the key \"name\" as follows.\n\n# Update a value\nperson[\"name\"]=\"Bob\"\n\n\"Bob\"\n\n\nMore information on this person can as well be added.\n\n# Add a new key-value pair\nperson[\"email\"] = \"bob@example.com\"\n\n\"bob@example.com\"\n\n\n\n\nStandard formats\nJulia offers support through packages for standard file formats in data science. For instance, JSON.jl is associated to JSON (JavaScript Object Notation) and CSV.jl to CSV (Comma-Separated Values). To handle tabular data, you can store data into DataFrames which are similar to pandas in Python or data.frame in R.",
    "crumbs": [
      "Julia language",
      "Core Syntax and Operations"
    ]
  },
  {
    "objectID": "src/syntax.html#exercise-1",
    "href": "src/syntax.html#exercise-1",
    "title": "Core Syntax and Operations",
    "section": "Exercise",
    "text": "Exercise\n\nLeast Squares Regression Line\nWe propose a first exercise about simple linear regression. The data are excerpted from this example and saved into data.csv. We propose an ordinary least squares formulation which is a type of linear least squares method for choosing the unknown parameters in a linear regression model by the principle of least squares: minimizing the sum of the squares of the differences between the observed dependent variable (values of the variable being observed) in the input dataset and the output of the (linear) function of the independent variable.\n\nGiven a set of m data points y_{1}, y_{2}, \\dots, y_{m}, consisting of experimentally measured values taken at m values x_{1}, x_{2}, \\dots, x_{m} of an independent variable (x_i may be scalar or vector quantities), and given a model function y=f(x,\\beta), with \\beta =(\\beta_{1},\\beta_{2},\\dots ,\\beta_{n}), it is desired to find the parameters \\beta_j such that the model function “best” fits the data. In linear least squares, linearity is meant to be with respect to parameters \\beta_j, so \n  f(x, \\beta) = \\sum_{j=1}^n \\beta_j\\, \\varphi_j(x).\n In general, the functions \\varphi_j may be nonlinear. However, we consider linear regression, that is \n  f(x, \\beta) = \\beta_1 + \\beta_2 x.\n Ideally, the model function fits the data exactly, so \n  y_i = f(x_i, \\beta)\n for all i=1, 2, \\dots, m. This is usually not possible in practice, as there are more data points than there are parameters to be determined. The approach chosen then is to find the minimal possible value of the sum of squares of the residuals \n  r_i(\\beta) = y_i - f(x_i, \\beta), \\quad i=1, 2, \\dots, m\n so to minimize the function \n  S(\\beta) = \\sum_{i=1}^m r_i^2(\\beta).\n In the linear least squares case, the residuals are of the form \n  r(\\beta) = y - X\\, \\beta\n with y = (y_i)_{1\\le i\\le m} \\in \\mathbb{R}^m and X = (X_{ij})_{1\\le i\\le m, 1\\le j\\le n} \\in \\mathrm{M}_{mn}(\\mathbb{R}), where X_{ij} = \\varphi_j(x_i). Since we consider linear regression, the i-th row of the matrix X is given by \n  X_{i[:]} = [1 \\quad x_i].\n The objective function may be written \n  S(\\beta) = {\\Vert y - X\\, \\beta \\Vert}^2\n where the norm is the usual 2-norm. The solution to the linear least squares problem \n  \\underset{\\beta \\in \\mathbb{R}^n}{\\mathrm{minimize}}\\, {\\Vert y - X\\, \\beta \\Vert}^2\n is computed by solving the normal equation \n  X^\\top X\\, \\beta = X^\\top y,\n where X^\\top denotes the transpose of X.\n\n\nQuestions\nTo answer the questions you need to import the following packages.\n\nusing DataFrames\nusing CSV\nusing Plots\n\nYou also need to download the csv file. Click on the following image.\n  \n\nUsing the packages DataFrames.jl and CSV.jl, load the dataset from data/introduction/data.csv and save the result into a variable named dataset.\n\n\n\nShow the answer\npath = \"data/introduction/data.csv\" # update depending on the location of your file\ndataset = DataFrame(CSV.File(path))\n\n\n5×2 DataFrame\n\n\n\nRow\nTime\nMass\n\n\n\nInt64\nInt64\n\n\n\n\n1\n5\n40\n\n\n2\n7\n120\n\n\n3\n12\n180\n\n\n4\n16\n210\n\n\n5\n20\n240\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nDo not hesitate to visit the documentation of CSV.jl and DataFrames.jl.\n\n\n\nUsing the package Plot.jl, plot the data.\n\n\n\n\n\n\n\nHint\n\n\n\n\n\nUse names(dataset) to get the list of data names. If Time is a name you can access to the associated data by dataset.Time.\n\n\n\n\n\nShow the answer\nplt = plot(\n  dataset.Time, \n  dataset.Mass,\n  seriestype=:scatter, \n  legend=false, \n  xlabel=\"Time\", \n  ylabel=\"Mass\"\n)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCreate the matrix X, the vector \\beta and solve the normal equation with the operator Base.\\.\n\n\n\n\n\n\n\nHint\n\n\n\n\n\nUse ones(m) to generate a vector of 1 of length m.\n\n\n\n\n\nShow the answer\nm = length(dataset.Time)\nX = [ones(m) dataset.Time]\ny = dataset.Mass\nβ = X\\y\n\n\n2-element Vector{Float64}:\n 11.506493506493449\n 12.207792207792208\n\n\n\nPlot the linear model on the same plot as the data. Use the plot! function. See the basic concepts for plotting.\n\n\n\nShow the answer\nx = [5, 20]\ny = β[1] .+ β[2]*x\nplot!(plt, x, y)",
    "crumbs": [
      "Julia language",
      "Core Syntax and Operations"
    ]
  },
  {
    "objectID": "src/developer_setup.html",
    "href": "src/developer_setup.html",
    "title": "Developer set up",
    "section": "",
    "text": "As a beginner Julia developers, you have learned interactive coding within the REPL. The content of this page will help you level-up by explaining how to use scripts and Integrated Development Environments (IDEs). Scripts allow you to write and save code in files, making it easier to test, reuse, and share your work. This is essential for building real-world projects, where your code will often be longer and more complex. IDEs provide helpful tools like auto-completion, debugging, syntax highlighting, and version control integration, which improve productivity and help catch errors early (avoiding tedious debugging hours…). Using scripts and IDEs sets you up with good habits and gives you the structure needed to grow as a developer.",
    "crumbs": [
      "Introduction",
      "Developer set up"
    ]
  },
  {
    "objectID": "src/developer_setup.html#running-julia-scripts",
    "href": "src/developer_setup.html#running-julia-scripts",
    "title": "Developer set up",
    "section": "Running Julia Scripts",
    "text": "Running Julia Scripts\nWhile the Julia REPL is great for interactive experimentation, you’ll often want to write and run larger programs. This is where running Julia scripts comes in.\n\nCreating a Julia Script\nA Julia script is a plain text file that contains Julia code. You can create a Julia script using any text editor, such as VS Code, Sublime Text, or even a simple text editor.\nSave the file with the .jl extension, for example myscript.jl.\n\n\nRunning a Julia Script\nTo run a Julia script, open your terminal or command prompt, navigate to the directory where the script is located, and then use the following command:\njulia myscript.jl\nThis will execute the code in myscript.jl and output any results in the terminal. If your script includes print statements, those outputs will be displayed. See the command-line interface page for more details.\n\n\nExample: Running a Script\nHere’s an example of a simple Julia script:\n# myscript.jl\nprintln(\"Hello, World!\")\nx = 10\ny = 20\nprintln(\"The sum of x and y is \", x + y)\nTo run this script, save it as myscript.jl and use the command:\njulia myscript.jl\nThe output will look like this:\nHello, World!\nThe sum of x and y is 30\n\n\nRunning Scripts with Arguments\nYou can also pass command-line arguments to a Julia script. For example, let’s modify the script to accept arguments:\n# args_example.jl\nprintln(\"Arguments passed to the script: \", ARGS)\nNow, when running the script, you can pass arguments like this:\njulia args_example.jl arg1 arg2 arg3\nThe output will be:\nArguments passed to the script: [\"arg1\", \"arg2\", \"arg3\"]\nYou can access the arguments as elements of the ARGS array within your script.\n\n\nRunning Julia Scripts from the REPL\nYou can also run Julia scripts directly from the REPL by using the include() function. To run the myscript.jl script, for example:\ninclude(\"myscript.jl\")\nThis command will execute the code in the script, and you’ll see the output in the REPL.\n\n\nRunning Julia Scripts in IDEs\nIf you’re using an IDE like VS Code with the Julia extension, you can run the script directly from within the editor by pressing the “Run” button or using the appropriate keyboard shortcut. This is convenient for testing and iterating on your code without having to switch back and forth between the editor and the terminal. See the Running Code page from Julia in VS Code documentation for more details.\n\n\n\n\n\n\n\nTip\n\n\n\nWe strongly encourage you configure VS Code for Julia. This set up will be handy for the exercises in the rest of this lecture. Read why in the next section.",
    "crumbs": [
      "Introduction",
      "Developer set up"
    ]
  },
  {
    "objectID": "src/developer_setup.html#editors-and-ides",
    "href": "src/developer_setup.html#editors-and-ides",
    "title": "Developer set up",
    "section": "Editors and Ides",
    "text": "Editors and Ides\nWhile any text editor can be used to write Julia code, Integrated Development Environments (IDEs) significantly enhance the programming experience. Notable options for Julia include Visual Studio Code (VS Code), Jupyter, Pluto.jl, Vim, and Emacs. Each of these editors offers unique features like interactive environments, real-time code feedback, and specialized plugins for a smoother development process. For instance, VS Code with the Julia extension is the most feature-rich IDE for Julia, while Jupyter provides an interactive notebook environment. Pluto.jl focuses on reactive notebooks, and Vim and Emacs offer efficient, customizable text editing solutions.\nThe best IDE for Julia is Visual Studio Code, or VS Code, developed by Microsoft. Indeed, the Julia VS Code extension is the most feature-rich of all Julia IDE plugins. You can download it from the VS Code Marketplace and read its documentation.\n\n\n\n\n\n\nTip\n\n\n\nTo use Julia in Visual Studio Code, please follow these steps, where you can find how to install Julia, VS Code and the necessary extensions.\nTo gain time, you can learn the keyboard shortcuts for:\n\nWindows,\nmacOS,\nLinux.\n\n\n\n\nVS CodeJupyterPluto.jlVimEmacs\n\n\n  \nJulia for Visual Studio Code is a powerful, free IDE for the Julia language. Visual Studio Code is a powerful and customizable editor. With a completely live environment, Julia for VS Code aims to take the frustration and guesswork out of programming and put the fun back in. We build on Julia’s unique combination of ease-of-use and performance. Beginners and experts can build better software more quickly, and get to a result faster. Julia is an officially supported language on the VS Code documentation.\n\n\n  \nYou can write Jupyter notebooks and use the Jupyter interactive environment. To do so you need to install the IJulia.jl package. IJulia is a Julia-language backend combined with the Jupyter interactive environment (also used by IPython). This combination allows you to interact with the Julia language using Jupyter/IPython’s powerful graphical notebook, which combines code, formatted text, math, and multimedia in a single document. IJulia is a Jupyter language kernel and works with a variety of notebook user interfaces. In addition to the classic Jupyter Notebook, IJulia also works with JupyterLab, a Jupyter-based integrated development environment for notebooks and code. The nteract notebook desktop supports IJulia with detailed instructions for its installation with nteract. Please visit this webpage to get a tutorial on how to use Julia in Jupyter notebook.\n\n\n   Simple reactive notebooks\n\n\n   Vim plugin\n\n\n   Emacs plugin",
    "crumbs": [
      "Introduction",
      "Developer set up"
    ]
  },
  {
    "objectID": "src/developer_setup.html#working-with-julia-packages",
    "href": "src/developer_setup.html#working-with-julia-packages",
    "title": "Developer set up",
    "section": "Working with Julia Packages",
    "text": "Working with Julia Packages\nJulia has a rich ecosystem of packages that extend the language’s capabilities for various domains, such as machine learning, data science, optimization, and more. The Julia Packages webpage is the official source for Julia packages. This section will cover how to manage and use packages in Julia.\n\nStandard Libraries in Julia\nJulia comes with a set of standard libraries, which are built-in packages available with the installation. These libraries cover a wide range of functionality, from mathematical operations to file handling and system utilities. You do not need to install them separately; they are ready to be used as soon as you start Julia.\nOne commonly used standard library is LinearAlgebra, which provides tools for linear algebra, such as matrix factorizations and vector operations.\n\nExample: Computing the Norm of a Vector\nThe LinearAlgebra library can be used to compute the norm of a vector. Here’s how you can do that:\n\nusing LinearAlgebra\n\n# Define a vector\nv = [3, 4]\n\n# Compute the Euclidean norm (magnitude) of the vector\nnorm_v = norm(v)\n\nprintln(\"The norm of the vector is: \", norm_v)\n\nThe norm of the vector is: 5.0\n\n\nIn this example, the norm() function calculates the Euclidean norm (or 2-norm) of the vector v, which in this case is\n\n\\sqrt{3^2 + 4^2} = 5.\n\nThese standard libraries help you to get started quickly with common tasks, without the need to install additional packages.\n\n\n\nInstalling Packages\nTo install a package, you can use the Pkg module, which is part of Julia’s standard library. Here’s how to install a package:\n\nEnter the package manager mode by typing ] in the REPL.\nThen, use the add command to install a package.\n\nExample:\n] add DataFrames\nThis will install the DataFrames package, which is widely used for data manipulation in Julia. To get the list of installed packages, type:\n] status\n\n\n\n\n\n\nNote\n\n\n\nYou can also install the package directly from the Julia mode:\nusing Pkg\nPkg.add(\"DataFrames\")\n\n\n\n\nUsing Installed Packages\nOnce a package is installed, you can use it by importing it into your code using the using keyword. This makes the functions and types of the package available for use.\nExample:\n\nusing DataFrames\n\ndf = DataFrame(A = 1:4, B = [\"a\", \"b\", \"c\", \"d\"])\n\n4×2 DataFrame\n\n\n\nRow\nA\nB\n\n\n\nInt64\nString\n\n\n\n\n1\n1\na\n\n\n2\n2\nb\n\n\n3\n3\nc\n\n\n4\n4\nd\n\n\n\n\n\n\nThis creates a simple DataFrame object with two columns A and B.\n\n\nUpdating Packages\nTo update the packages installed in your environment to their latest versions, use the update command in the package manager.\nExample:\n] update\nYou can also update a specific package by running:\n] update PackageName\n\n\n\n\n\n\nNote\n\n\n\nYou can also update packages directly from the Julia mode:\nusing Pkg\nPkg.update()\n# or\nPkg.update(\"PackageName\")\n\n\n\n\nRemoving Packages\nIf you no longer need a package, you can remove it using the rm command.\nExample:\n] rm DataFrames\nThis will uninstall the DataFrames package from your environment.\n\n\n\n\n\n\nNote\n\n\n\nYou can also remove packages directly from the Julia mode:\nusing Pkg\nPkg.rm(\"DataFrames\")\n\n\n\n\nPackage Environments\nIn Julia, you can manage different environments, each with its own set of installed packages. This allows you to work on multiple projects with different dependencies without conflicts. You can create a new environment by navigating to a directory and typing:\n] activate .\nThis will activate the environment in the current directory. You can also specify a different directory or environment path by providing it after activate. If you want to come back to the global environment, type:\n] activate\nNote that the packages installed in the global environment are visible from any other environment. See the Working with Environments page for more details.\n\n\n\n\n\n\nNote\n\n\n\nYou can also activate environments directly from the Julia mode. For instance, for the current directory:\nusing Pkg\nPkg.activate(\".\")\n\n\n\n\nConclusion\nWorking with packages is essential to leveraging Julia’s powerful ecosystem. Understanding how to install, update, and remove packages, as well as using environments to manage project-specific dependencies, will help you make the most out of Julia’s vast libraries.",
    "crumbs": [
      "Introduction",
      "Developer set up"
    ]
  },
  {
    "objectID": "src/developer_setup.html#exercise",
    "href": "src/developer_setup.html#exercise",
    "title": "Developer set up",
    "section": "Exercise",
    "text": "Exercise\nLet us put these concepts into practice to prepare your work environment for the exercises in this lecture.\n\nNavigate to your working directory dedicated to this lecture through a terminal or command prompt.\nStart Julia inside the directory using julia.\nEnter the package manager mode by typing ] in the REPL.\nActivate the environment associated to this directory by typing activate .\nAdd Plots, DataFrames and CSV packages to the environment using add.\nCheck installation of packages using the status command.\nIn your work directory, a Project.toml and Manifest.toml file are created and packages are installed locally.\n\n\n\n\n\n\n\nWarning\n\n\n\nRecall to activate this environment at the start of each work session for this lecture.",
    "crumbs": [
      "Introduction",
      "Developer set up"
    ]
  },
  {
    "objectID": "src/eval.html",
    "href": "src/eval.html",
    "title": "Auto-evaluation",
    "section": "",
    "text": "We have included in this page a series of quizzes to help reinforce your learning. These quizzes are designed not only to test your understanding but also to provide you with an opportunity for self-reflection. After each quiz, take a moment to review your answers, reflect on what you’ve learned, and identify areas where you may need further clarification. Do not hesitate to reach out to your lecturer if any questions come up.\n\nType Hierarchies\n\n\n\n\n\n\nQuiz\n\n\n\n\n\n\n\nQuestion 1. What is the purpose of an abstract type in Julia?\n\n\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        It provides a blueprint for organizing related types but cannot be instantiated.\n    \n    \n\n\n    \n    \n    \n    \n        It can be instantiated and used directly.\n    \n    \n\n\n    \n    \n    \n    \n        It defines a concrete implementation for other types.\n    \n    \n\n\n    \n    \n    \n    \n        It is used for type annotations in functions.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 2. Which of the following types is a concrete type?\n\n\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        Real\n    \n    \n\n\n    \n    \n    \n    \n        Int64\n    \n    \n\n\n    \n    \n    \n    \n        AbstractFloat\n    \n    \n\n\n    \n    \n    \n    \n        Number\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 3. What does the isconcretetype function return for AbstractFloat?\n\n\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        Error: Undefined type\n    \n    \n\n\n    \n    \n    \n    \n        true\n    \n    \n\n\n    \n    \n    \n    \n        null\n    \n    \n\n\n    \n    \n    \n    \n        false\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 4. What will the following code return?\n\n\n\n\ntypeof(42)\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        Real\n    \n    \n\n\n    \n    \n    \n    \n        Integer\n    \n    \n\n\n    \n    \n    \n    \n        Number\n    \n    \n\n\n    \n    \n    \n    \n        Int64\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 5. What is the purpose of the isa operator in Julia?\n\n\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        To check if a type is concrete.\n    \n    \n\n\n    \n    \n    \n    \n        To check if a variable's value matches a specific type.\n    \n    \n\n\n    \n    \n    \n    \n        To check if a variable is an instance of a specific type or any of its subtypes.\n    \n    \n\n\n    \n    \n    \n    \n        To check if a variable is a subtype of Any.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 6. What will be the result of the following code?\n\n\n\n\nInt64 &lt;: Real\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        true\n    \n    \n\n\n    \n    \n    \n    \n        false\n    \n    \n\n\n    \n    \n    \n    \n        true for Float64 but not for Int64\n    \n    \n\n\n    \n    \n    \n    \n        Error: Type mismatch\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 7. What will the following code return?\n\n\n\n\nisconcretetype(Int64)\nisconcretetype(AbstractFloat)\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        true for Int64 and false for AbstractFloat\n    \n    \n\n\n    \n    \n    \n    \n        true for AbstractFloat and false for Int64\n    \n    \n\n\n    \n    \n    \n    \n        false for both types\n    \n    \n\n\n    \n    \n    \n    \n        false for both types if using a different syntax\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 8. What does the &lt;: operator check in Julia?\n\n\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        If a type is abstract.\n    \n    \n\n\n    \n    \n    \n    \n        If one type is a subtype of another.\n    \n    \n\n\n    \n    \n    \n    \n        If a type can be instantiated.\n    \n    \n\n\n    \n    \n    \n    \n        If two types are exactly the same.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 9. What is the result of the following code?\n\n\n\n\nsubtypes(Real)\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        Returns a list of all types that are subtypes of Real.\n    \n    \n\n\n    \n    \n    \n    \n        Shows Real as a parent type with no subtypes.\n    \n    \n\n\n    \n    \n    \n    \n        Returns Any as the only subtype of Real.\n    \n    \n\n\n    \n    \n    \n    \n        Returns an error because Real is abstract.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 10. What does the supertype function return for Float64?\n\n\n\n\nsupertype(Float64)\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        Real\n    \n    \n\n\n    \n    \n    \n    \n        Int\n    \n    \n\n\n    \n    \n    \n    \n        AbstractFloat\n    \n    \n\n\n    \n    \n    \n    \n        Number\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\n\n\n\nType Conversion and Promotion\n\n\n\n\n\n\nQuiz\n\n\n\n\n\n\n\nQuestion 1. What does the convert function do in Julia?\n\n\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        It converts numbers to strings.\n    \n    \n\n\n    \n    \n    \n    \n        It automatically promotes values to a common type.\n    \n    \n\n\n    \n    \n    \n    \n        It changes a value to a boolean type.\n    \n    \n\n\n    \n    \n    \n    \n        It converts a value from one type to another, if possible.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 2. What is the output of the following code?\n\n\n\n\nprintln(round(Int, 3.14))   # Rounds 3.14 to the nearest integer, output: 3\nprintln(floor(Int, 3.14))   # Floors 3.14 to the nearest integer, output: 3\nprintln(convert(Float64, 5))  # Converts Int to Float64, output: 5.0\nprintln(string(123))         # Converts Int to String, output: \"123\"\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        3, 3, 5.0, 123\n    \n    \n\n\n    \n    \n    \n    \n        5.0, 3, 5, '123'\n    \n    \n\n\n    \n    \n    \n    \n        3, 3, 5.0, '123'\n    \n    \n\n\n    \n    \n    \n    \n        3, 3.14, 5, '123'\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 3. What happens when an integer is assigned to a Float64 variable in Julia?\n\n\n\n\ny::Float64 = 10  # The integer 10 is automatically converted to 10.0 (Float64)\nprintln(y)       # Output: 10.0\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        The variable y will be set to the integer value of 10.\n    \n    \n\n\n    \n    \n    \n    \n        The conversion needs to be done explicitly using convert.\n    \n    \n\n\n    \n    \n    \n    \n        Julia automatically converts the integer to a Float64.\n    \n    \n\n\n    \n    \n    \n    \n        Julia throws a type error because of the type mismatch.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 4. What does the promote function do in Julia?\n\n\n\n\na, b = promote(3, 4.5)  # Promotes both values to Float64\nprintln(a)              # Output: 3.0\nprintln(b)              # Output: 4.5\nprintln(typeof(a))      # Output: Float64\nprintln(typeof(b))      # Output: Float64\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        It converts both values to integers.\n    \n    \n\n\n    \n    \n    \n    \n        It converts values to strings for display.\n    \n    \n\n\n    \n    \n    \n    \n        It promotes two values to a common type for an operation.\n    \n    \n\n\n    \n    \n    \n    \n        It checks if two values have the same type.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 5. What will happen if we try to add an Int and a String in Julia?\n\n\n\n\nprintln(3 + \"Hello\")  # Attempting to add Int and String\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        It will promote the number to a string.\n    \n    \n\n\n    \n    \n    \n    \n        Julia will automatically convert both to a common type.\n    \n    \n\n\n    \n    \n    \n    \n        It will throw a type error.\n    \n    \n\n\n    \n    \n    \n    \n        It will concatenate the string and the number.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\n\n\n\nSpecial Types\n\n\n\n\n\n\nQuiz\n\n\n\n\n\n\n\nQuestion 1. What does the Nothing type represent in Julia?\n\n\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        It represents the absence of a meaningful value.\n    \n    \n\n\n    \n    \n    \n    \n        It is a special type for numeric values.\n    \n    \n\n\n    \n    \n    \n    \n        It is a placeholder for missing data.\n    \n    \n\n\n    \n    \n    \n    \n        It is used for undefined variables.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 2. What is the result of calling the following function in Julia?\n\n\n\n\n# Example of a function that returns `Nothing`\nfunction print_message(msg::String)\n    println(msg)\n    return nothing  # Explicitly returns `nothing`\nend\n\nresult = print_message(\"Hello!\")\nprintln(result === nothing)  # Output: true\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        The function throws an error because nothing cannot be returned.\n    \n    \n\n\n    \n    \n    \n    \n        The function returns a string 'nothing'.\n    \n    \n\n\n    \n    \n    \n    \n        nothing is returned and the output is true.\n    \n    \n\n\n    \n    \n    \n    \n        nothing is returned but the output is false.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 3. What is the advantage of using Any as a type in Julia?\n\n\n\n\n# Example of using `Any` as a type\nfunction describe(value::Any)\n    println(\"Value: \", value)\n    println(\"Type: \", typeof(value))\nend\n\ndescribe(42)         # Works with Int\ndescribe(\"Hello\")    # Works with String\ndescribe(3.14)       # Works with Float64\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        It makes type inference more precise.\n    \n    \n\n\n    \n    \n    \n    \n        It allows variables to hold any type, making the code flexible.\n    \n    \n\n\n    \n    \n    \n    \n        It increases performance by restricting the type of variable.\n    \n    \n\n\n    \n    \n    \n    \n        It prevents runtime errors related to data types.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 4. What does the following code do in Julia?\n\n\n\n\ndata = [1, 2, missing, 4, 5]\nfor item in data\n    if item === missing\n        println(\"Missing data detected.\")\n    else\n        println(\"Value: \", item)\n    end\nend\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        It throws an error when encountering missing data.\n    \n    \n\n\n    \n    \n    \n    \n        It checks for missing values and prints a message for each.\n    \n    \n\n\n    \n    \n    \n    \n        It sums all the values and skips missing ones.\n    \n    \n\n\n    \n    \n    \n    \n        It replaces missing data with a default value.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 5. What is the purpose of the skipmissing function in Julia?\n\n\n\n\nusing Statistics\n\n# Example array with missing values\ndata = [1, 2, missing, 4, 5, missing, 7]\n\n# Summing values while skipping missing entries\nsum_no_missing = sum(skipmissing(data))\nprintln(\"Sum without missing values: \", sum_no_missing)  # Output: 19\n\n# Calculating the mean while skipping missing values\nmean_no_missing = mean(skipmissing(data))\nprintln(\"Mean without missing values: \", mean_no_missing)  # Output: 3.8\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        It raises an error if missing values are encountered.\n    \n    \n\n\n    \n    \n    \n    \n        It replaces missing values with 0.\n    \n    \n\n\n    \n    \n    \n    \n        It prints out the number of missing values.\n    \n    \n\n\n    \n    \n    \n    \n        It creates an iterator that skips missing values during computations.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 6. What is the main use of the Missing type in Julia?\n\n\n\n\n# Example of using `missing` in an array\ndata = [1, 2, missing, 4, 5]\n\n# Check for missing values in the array\nfor item in data\n    if item === missing\n        println(\"Missing data detected.\")\n    else\n        println(\"Value: \", item)\n    end\nend\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        To represent missing or unknown data in a collection.\n    \n    \n\n\n    \n    \n    \n    \n        To hold any type of data including missing entries.\n    \n    \n\n\n    \n    \n    \n    \n        To prevent errors when dealing with Nothing.\n    \n    \n\n\n    \n    \n    \n    \n        To represent variables with no value assigned.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\n\n\n\nUnion Types\n\n\n\n\n\n\nQuiz\n\n\n\n\n\n\n\nQuestion 1. What is a Union type in Julia?\n\n\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        A type that can only accept floating-point numbers.\n    \n    \n\n\n    \n    \n    \n    \n        A type that allows a variable to accept multiple types.\n    \n    \n\n\n    \n    \n    \n    \n        A built-in function for type conversion.\n    \n    \n\n\n    \n    \n    \n    \n        A type that restricts a variable to only one type.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 2. What is the output of the following code?\n\n\n\n\nfunction process_number(x::Union{Int, Float64})\n    println(\"The input is: \", x)\nend\n\nprocess_number(5)       # Works with an Int\nprocess_number(3.14)    # Works with a Float64\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        The input is: 5, The input is: 3.0\n    \n    \n\n\n    \n    \n    \n    \n        The input is: 5, The input is: 3.14\n    \n    \n\n\n    \n    \n    \n    \n        The input is: 5, The input is: 3\n    \n    \n\n\n    \n    \n    \n    \n        The input is: 3.14, The input is: 5\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 3. Which of the following scenarios would benefit from using a Union type?\n\n\n\n\n# Example using Union to handle multiple types in a function\nfunction add_one(x::Union{Int, Float64})\n    return x + 1\nend\n\nprintln(add_one(3))     # Output: 4 (Int)\nprintln(add_one(2.5))   # Output: 3.5 (Float64)\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        When a function needs to accept both integers and floating-point numbers.\n    \n    \n\n\n    \n    \n    \n    \n        When there is a strict requirement to accept a specific type.\n    \n    \n\n\n    \n    \n    \n    \n        When a function accepts only integers.\n    \n    \n\n\n    \n    \n    \n    \n        When a function is only designed to accept floating-point numbers.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 4. What happens when a value of a type not listed in the Union is passed to a function?\n\n\n\n\nfunction process_number(x::Union{Int, Float64})\n    println(\"The input is: \", x)\nend\n\nprocess_number(\"Hello\")  # Trying to pass a String\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        It will automatically convert the string to an integer.\n    \n    \n\n\n    \n    \n    \n    \n        It will work without issue because String is compatible with Union.\n    \n    \n\n\n    \n    \n    \n    \n        It will throw a MethodError because String is not part of the Union.\n    \n    \n\n\n    \n    \n    \n    \n        It will throw a TypeError due to the type mismatch.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 5. How does the add_one function handle both Int and Float64 types?\n\n\n\n\nfunction add_one(x::Union{Int, Float64})\n    return x + 1\nend\n\nprintln(add_one(3))     # Output: 4 (Int)\nprintln(add_one(2.5))   # Output: 3.5 (Float64)\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        It throws an error for Int but works for Float64.\n    \n    \n\n\n    \n    \n    \n    \n        It works for both types without needing separate methods.\n    \n    \n\n\n    \n    \n    \n    \n        It requires type checking before execution.\n    \n    \n\n\n    \n    \n    \n    \n        It only works for Float64 types.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\n\n\n\nType Annotations and Declarations\n\n\n\n\n\n\nQuiz\n\n\n\n\n\n\n\nQuestion 1. What is the primary purpose of type annotations in Julia?\n\n\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        To prevent errors from occurring in the code.\n    \n    \n\n\n    \n    \n    \n    \n        To provide clarity in the code and enable optimizations by the compiler.\n    \n    \n\n\n    \n    \n    \n    \n        To make code run faster by skipping type checks.\n    \n    \n\n\n    \n    \n    \n    \n        To specify the exact memory address of a variable.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 2. Which of the following correctly applies a type annotation to a variable?\n\n\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        a::Int = 10\n    \n    \n\n\n    \n    \n    \n    \n        a:Int = 10\n    \n    \n\n\n    \n    \n    \n    \n        a = 10::Int\n    \n    \n\n\n    \n    \n    \n    \n        Int::a = 10\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 3. What will happen if the following code is executed?\n\n\n\n\nfunction add(a::Int, b::Int)\n    return a + b\nend\n\nadd(3, \"4\")\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        It will ignore the type annotation and return 7.\n    \n    \n\n\n    \n    \n    \n    \n        It will throw a type error because \"4\" is a String, not an Int.\n    \n    \n\n\n    \n    \n    \n    \n        It will convert \"4\" to an Int and return 7.\n    \n    \n\n\n    \n    \n    \n    \n        It will throw a syntax error.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 4. In Julia, what will the following code output?\n\n\n\n\nfunction multiply(a::Int, b::Int)::Int\n    return a * b\nend\nmultiply(3, 4)\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        12.0\n    \n    \n\n\n    \n    \n    \n    \n        Error: Incorrect type\n    \n    \n\n\n    \n    \n    \n    \n        12\n    \n    \n\n\n    \n    \n    \n    \n        Nothing\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\n\n\n\nParametric Types\n\n\n\n\n\n\nQuiz\n\n\n\n\n\n\n\nQuestion 1. What is a parametric type in Julia?\n\n\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        A type that can only work with abstract types.\n    \n    \n\n\n    \n    \n    \n    \n        A type that is defined for a specific data type.\n    \n    \n\n\n    \n    \n    \n    \n        A type that doesn't require any parameters.\n    \n    \n\n\n    \n    \n    \n    \n        A type that can work with multiple data types, specified by parameters.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 2. What is the role of T and S in the Pair struct example?\n\n\n\n\nstruct Pair{T, S}\n    first::T\n    second::S\nend\n\npair1 = Pair(1, \"apple\")  # Pair of Int and String\npair2 = Pair(3.14, true)  # Pair of Float64 and Bool\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        T and S are unused in this case, they are placeholders.\n    \n    \n\n\n    \n    \n    \n    \n        T defines the data type of both elements in the pair.\n    \n    \n\n\n    \n    \n    \n    \n        T is used for the first element, and S is used for the second element.\n    \n    \n\n\n    \n    \n    \n    \n        T and S define the data types of the first and second elements of the pair.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 3. What happens when you instantiate Pair(1, 'apple') in the provided code?\n\n\n\n\npair1 = Pair(1, \"apple\")  # Pair of Int and String\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        It will throw an error because Int and String can't be combined.\n    \n    \n\n\n    \n    \n    \n    \n        It will cause a runtime error because the types don't match.\n    \n    \n\n\n    \n    \n    \n    \n        It will create a pair with Int64 and String.\n    \n    \n\n\n    \n    \n    \n    \n        It will create a pair with an Int and a String.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 4. What is the benefit of using parametric types like AbstractContainer{T}?\n\n\n\n\nabstract type AbstractContainer{T} end\n\nstruct VectorContainer{T} &lt;: AbstractContainer{T}\n    data::Vector{T}\nend\n\nstruct SetContainer{T} &lt;: AbstractContainer{T}\n    data::Set{T}\nend\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        It makes the code more complex and harder to maintain.\n    \n    \n\n\n    \n    \n    \n    \n        It allows you to specify concrete types directly in the struct.\n    \n    \n\n\n    \n    \n    \n    \n        It makes the code less flexible and more specific.\n    \n    \n\n\n    \n    \n    \n    \n        It allows you to create types that can handle any type of data, with type safety.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 5. What does the print_container_info function do?\n\n\n\n\nfunction print_container_info(container::AbstractContainer{T}) where T\n    println(\"Container holds values of type: \", T)\nend\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        It prints the values inside the container.\n    \n    \n\n\n    \n    \n    \n    \n        It prints the number of elements in the container.\n    \n    \n\n\n    \n    \n    \n    \n        It returns the type of the container.\n    \n    \n\n\n    \n    \n    \n    \n        It prints the type of the container.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 6. What is the purpose of AbstractContainer{T} in the code example?\n\n\n\n\nabstract type AbstractContainer{T} end\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        It defines an abstract type that can be used to create containers for any data type T.\n    \n    \n\n\n    \n    \n    \n    \n        It restricts containers to hold only numeric types.\n    \n    \n\n\n    \n    \n    \n    \n        It defines a concrete container type.\n    \n    \n\n\n    \n    \n    \n    \n        It defines a container for a specific type of data.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 7. What would be the output of print_container_info(vec) if vec is VectorContainer([1, 2, 3])?\n\n\n\n\nvec = VectorContainer([1, 2, 3])\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        It will print the type Vector{Int}.\n    \n    \n\n\n    \n    \n    \n    \n        It will throw an error because VectorContainer is not defined.\n    \n    \n\n\n    \n    \n    \n    \n        It will print the type AbstractContainer{Int}.\n    \n    \n\n\n    \n    \n    \n    \n        It will print the values inside the container.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 8. How does using parametric types help with code reusability?\n\n\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        It reduces the need to define separate functions for different data types.\n    \n    \n\n\n    \n    \n    \n    \n        It requires more boilerplate code.\n    \n    \n\n\n    \n    \n    \n    \n        It makes the code less reusable.\n    \n    \n\n\n    \n    \n    \n    \n        It forces you to create new types for every use case.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\n\n\n\nErrors and Exception Handling\n\n\n\n\n\n\nQuiz\n\n\n\n\n\n\n\nQuestion 1. Which error type is raised when an index is out of bounds in an array?\n\n\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        DivisionByZeroError\n    \n    \n\n\n    \n    \n    \n    \n        IOError\n    \n    \n\n\n    \n    \n    \n    \n        BoundsError\n    \n    \n\n\n    \n    \n    \n    \n        ArgumentError\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 2. What does the following code do in Julia?\n\n\n\n\nfunction divide(a, b)\n    if b == 0\n        throw(DivideError())\n    end\n    return a / b\nend\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        It throws a BoundsError if a or b are not numbers.\n    \n    \n\n\n    \n    \n    \n    \n        It raises a DivideError when b equals 0.\n    \n    \n\n\n    \n    \n    \n    \n        It raises an ArgumentError when a or b is invalid.\n    \n    \n\n\n    \n    \n    \n    \n        It performs division and returns the result.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 3. What happens when the following try/catch block is executed?\n\n\n\n\ntry\n    println(divide(10, 0))  # Will raise an error\ncatch e\n    println(\"Error: \", e)  # Handles the error\nend\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        The program prints the result of the division.\n    \n    \n\n\n    \n    \n    \n    \n        The error is caught and a custom error message is printed.\n    \n    \n\n\n    \n    \n    \n    \n        The program silently ignores the error.\n    \n    \n\n\n    \n    \n    \n    \n        The program throws an error and stops execution.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 4. What is the purpose of the finally block in Julia’s exception handling?\n\n\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        To ensure that cleanup code runs regardless of whether an error occurs.\n    \n    \n\n\n    \n    \n    \n    \n        To rethrow any errors that are caught.\n    \n    \n\n\n    \n    \n    \n    \n        To catch all errors and handle them.\n    \n    \n\n\n    \n    \n    \n    \n        To perform the main logic of the program.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 5. What is the output of the following code?\n\n\n\n\nfunction safe_file_read(filename::String)\n    file = nothing\n    try\n        file = open(filename, \"r\")\n        data = read(file, String)\n        return data\n    catch e\n        println(\"An error occurred: \", e)\n    finally\n        if file !== nothing\n            close(file)\n            println(\"File closed.\")\n        end\n    end\nend\n\n# Test with a valid file\nprintln(safe_file_read(\"example.txt\"))\n\n# Test with an invalid file\nprintln(safe_file_read(\"nonexistent.txt\"))\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        The program prints data from the file and closes it.\n    \n    \n\n\n    \n    \n    \n    \n        The program prints the error but skips file closing.\n    \n    \n\n\n    \n    \n    \n    \n        The program raises an error and does not close the file.\n    \n    \n\n\n    \n    \n    \n    \n        The program tries to read a file, catches errors, and always closes the file.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 6. Which of the following is an appropriate use case for the finally block?\n\n\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        To prevent specific types of errors from being raised.\n    \n    \n\n\n    \n    \n    \n    \n        To catch all exceptions without handling them.\n    \n    \n\n\n    \n    \n    \n    \n        To handle errors and return a value from the finally block.\n    \n    \n\n\n    \n    \n    \n    \n        Ensuring a file is closed after reading, regardless of errors.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Julia language",
      "Auto-evaluation"
    ]
  },
  {
    "objectID": "src/types.html",
    "href": "src/types.html",
    "title": "Types",
    "section": "",
    "text": "In Julia, understanding the fundamental types and data structures is essential for efficient coding and problem-solving. This page provides an introduction to some of the basic types in Julia, including integers, floating-point numbers, strings, and composite types like arrays and tuples. We’ll also explore more advanced data structures and their practical uses.\nYou’ll learn about:\nWhether you’re a beginner or looking to deepen your understanding of Julia’s type system, this page will help you get familiar with the core building blocks for handling data efficiently in Julia.\nIn this section, we will delve into some of the more advanced features of Julia’s type system and error handling. We will explore the hierarchical structure of types, how to define and work with parametric types, as well as how to handle type conversions and promotions. Additionally, we will look at how to manage errors in Julia, including common error types and exception handling mechanisms.\nBy the end of this page, you’ll have a deeper understanding of Julia’s flexible and powerful type system, which is essential for writing efficient, type-safe code. We will also cover how to manage and handle errors gracefully to ensure that your programs run smoothly.\nTopics Covered:",
    "crumbs": [
      "Julia language",
      "Types"
    ]
  },
  {
    "objectID": "src/types.html#introduction-to-types-in-julia",
    "href": "src/types.html#introduction-to-types-in-julia",
    "title": "Types",
    "section": "Introduction to Types in Julia",
    "text": "Introduction to Types in Julia\nJulia is a dynamically typed language, meaning that variable types are determined at runtime. However, Julia also supports strong typing, which means that types are important and can be explicitly specified when needed. Understanding types in Julia is essential for writing efficient code, as the language uses Just-In-Time (JIT) compilation to optimize based on variable types.\n\nDynamic Typing\nIn Julia, variables do not require explicit type declarations. The type of a variable is inferred based on the value assigned to it.\n\nx = 10          # x is inferred to be of type Int64\ny = 3.14        # y is inferred to be of type Float64\nz = \"Hello\"     # z is inferred to be of type String\n\ntypeof(x), typeof(y), typeof(z)\n\njulia&gt; x = 10\njulia&gt; y = 3.14\njulia&gt; z = \"Hello\"\njulia&gt; (typeof(x), typeof(y), typeof(z)) = (Int64, Float64, String)\n\n\nEven though Julia automatically infers types, you can still explicitly specify them when necessary, particularly for performance optimization or for ensuring that a variable matches a particular type.\n\n\nStrong Typing\nWhile Julia uses dynamic typing, it is strongly typed. This means that Julia will enforce type constraints on operations, and will raise errors when an operation is attempted with incompatible types.\nYou can add an integer and a float,\n\nn = 5           # Integer\nx = 2.0         # Float\nn + x           # we can add an Int64 and a Float64\n\njulia&gt; n = 5\njulia&gt; x = 2.0\njulia&gt; n + x = 7.0\n\n\nbut you cannot add an integer and a string:\n\ns = \"Hello\"     # String\nn + s           # Error: does not make sense to add an Int64 and a String\n\njulia&gt; s = \"Hello\"\njulia&gt; n + s\n\n\n\nMethodError: no method matching +(::Int64, ::String)\nThe function `+` exists, but no method is defined for this combination of argument types.\n\nClosest candidates are:\n  +(::Any, ::Any, ::Any, ::Any...)\n   @ Base operators.jl:596\n  +(::Real, ::Complex{Bool})\n   @ Base complex.jl:322\n  +(::Real, ::Complex)\n   @ Base complex.jl:334\n  ...\n\n\nStacktrace:\n [1] macro expansion\n   @ show.jl:1232 [inlined]\n [2] macro expansion\n   @ ~/Courses/julia/course-tse-julia/assets/julia/myshow.jl:82 [inlined]\n [3] top-level scope\n   @ In[5]:3\n\n\n\nWe see from the error message that we can add an Integer and a Char: +(::Integer, ::AbstractChar) is a valid operation. This is because a Char can be treated as an integer in Julia.\n\nc = 'a'      # Char\nc + 128448   # This will work because Char can be treated as an integer\n\njulia&gt; c = 'a'\njulia&gt; c + 128448 = '😡'\n\n\nJulia allows flexibility compared to statically typed languages like C or Java, but still ensures that operations make sense for the types involved.\n\n\nType System and Performance\nThe type system in Julia plays a key role in performance. By inferring or specifying types, Julia’s JIT compiler can optimize code for specific data types, leading to faster execution. For example, when types are known at compile time, Julia can generate machine code tailored for the specific types involved.\nJulia’s type system also supports abstract types, allowing for more flexible and generic code, as well as parametric types that let you define functions or types that work with any data type.\n\n\nSummary\n\nJulia is dynamically typed but enforces strong typing.\nTypes are inferred from the values assigned to variables.\nJulia optimizes performance based on types, making type information crucial.",
    "crumbs": [
      "Julia language",
      "Types"
    ]
  },
  {
    "objectID": "src/types.html#type-hierarchies",
    "href": "src/types.html#type-hierarchies",
    "title": "Types",
    "section": "Type Hierarchies",
    "text": "Type Hierarchies\nIn Julia, types are organized into a hierarchy with Any as the root. At the top, Any is the most general type, and all other types are subtypes of Any. The type hierarchy enables Julia to provide flexibility while supporting efficient dispatch based on types.\n\nusing GraphRecipes, Plots\ndefault(size=(800, 800))\nplot(AbstractFloat, fontsize=10, nodeshape=:rect, nodesize=0.08)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAbstract and Concrete Types\nTypes in Julia can be abstract or concrete:\n\nAbstract types serve as nodes in the hierarchy but cannot be instantiated. They provide a framework for organizing related types.\nConcrete types can be instantiated and are the actual types used for values.\n\nFor example, Julia’s Real and AbstractFloat types are abstract, while Int64 and Float64 are concrete subtypes.\n\ni::Int64 = 42   # Int64 is a concrete type\ntypeof(i)       # Output: Int64 (concrete type)\nr::Real = 3.14  # Real is an abstract type\ntypeof(r)       # Output: Float64 (concrete type)\n\njulia&gt; i::Int64 = 42\njulia&gt; typeof(i) = Int64\njulia&gt; r::Real = 3.14\njulia&gt; typeof(r) = Float64\n\n\n\n\nChecking if a Type is Concrete\nIn Julia, you can use the isconcretetype function to check if a type is concrete (meaning it can be instantiated) or abstract (which serves as a blueprint for other types but cannot be instantiated directly).\n\nisconcretetype(Int64)\nisconcretetype(AbstractFloat)\n\njulia&gt; isconcretetype(Int64) = true\njulia&gt; isconcretetype(AbstractFloat) = false\n\n\nThe isconcretetype function returns true for concrete types (like Int64 or Float64) and false for abstract types (like AbstractFloat or Real).\n\n\nGet the Type of a Variable\nYou can use the typeof() function to get the type of a variable:\n\na = 42\ntypeof(a)\n\njulia&gt; a = 42\njulia&gt; typeof(a) = Int64\n\n\nThe typeof() function returns the concrete type of the variable.\n\n\nExample\nLet’s instantiate a variable with a specific concrete type, check its type using typeof(), and verify if it’s concrete using isconcretetype:\n\na = 3.14\ntypeof(a)\nisconcretetype(typeof(a))\n\njulia&gt; a = 3.14\njulia&gt; typeof(a) = Float64\njulia&gt; isconcretetype(typeof(a)) = true\n\n\n\n\nThe isa Operator\nThe isa operator is used to check if a value is an instance of a specific type:\n\na = 42\na isa Int64\na isa Number\na isa Float64\n\njulia&gt; a = 42\njulia&gt; a isa Int64 = true\njulia&gt; a isa Number = true\njulia&gt; a isa Float64 = false\n\n\nThe isa operator is often used for type checking within functions or when validating data.\n\n\nThe &lt;: Operator\nThe &lt;: operator checks if a type is a subtype of another type in the hierarchy. It can be used for checking if one type is a more general or more specific type than another:\n\nInt64 &lt;: Real\nFloat64 &lt;: Real\nReal &lt;: Number\nNumber &lt;: Real\n\njulia&gt; Int64 &lt;: Real = true\njulia&gt; Float64 &lt;: Real = true\njulia&gt; Real &lt;: Number = true\njulia&gt; Number &lt;: Real = false\n\n\n\n\nCreating Custom Abstract Types\nJulia allows you to create your own abstract types. For example, you can define a custom abstract type Shape, and create concrete subtypes like Triangle and Rectangle.\n\n# Define abstract type\nabstract type Shape end\n\n# Define concrete subtypes\nstruct Triangle &lt;: Shape\n    base::Float64\n    height::Float64\nend\n\nstruct Rectangle &lt;: Shape\n    width::Float64\n    height::Float64\nend\n\n# Create instances\ntriangle = Triangle(2.0, 3.0)\nrectangle = Rectangle(3.0, 4.0)\n\n# Check if they are subtypes of Shape\ntriangle isa Shape\nrectangle isa Shape\n\njulia&gt; triangle isa Shape = true\njulia&gt; rectangle isa Shape = true\n\n\n\n\nGetting Subtypes and Parent Types\nIn Julia, you can use the subtypes() function to find all direct subtypes of a given type. Additionally, the supertypes() function can be used to get the entire chain of parent (super) types for a given type.\n\nGetting Subtypes\nTo find all direct subtypes of a specific type, you can use the subtypes() function. Here’s an example:\n\nsubtypes(AbstractFloat)\n\n5-element Vector{Any}:\n BigFloat\n Core.BFloat16\n Float16\n Float32\n Float64\n\n\nThis will return all direct subtypes of AbstractFloat. To visualize the type hierarchy, you can use the plot function from the GraphRecipes package or for a textual representation, you can do the following:\n\nusing AbstractTrees\nAbstractTrees.children(d::DataType) = subtypes(d)\nprint_tree(Real)\n\nReal\n├─ AbstractFloat\n│  ├─ BigFloat\n│  ├─ BFloat16\n│  ├─ Float16\n│  ├─ Float32\n│  └─ Float64\n├─ AbstractIrrational\n│  ├─ Irrational\n│  └─ IrrationalConstant\n│     ├─ Fourinvπ\n│     ├─ Fourπ\n│     ├─ Halfπ\n│     ├─ Inv2π\n│     ├─ Inv4π\n│     ├─ Invsqrt2\n│     ├─ Invsqrt2π\n│     ├─ Invsqrtπ\n│     ├─ Invπ\n│     ├─ Log2π\n│     ├─ Log4π\n│     ├─ Loghalf\n│     ├─ Logten\n│     ├─ Logtwo\n│     ├─ Logπ\n│     ├─ Quartπ\n│     ├─ Sqrt2\n│     ├─ Sqrt2π\n│     ├─ Sqrt3\n│     ├─ Sqrt4π\n│     ├─ Sqrthalfπ\n│     ├─ Sqrtπ\n│     ├─ Twoinvπ\n│     └─ Twoπ\n├─ FixedPoint\n├─ Integer\n│  ├─ Bool\n│  ├─ OffsetInteger\n│  ├─ OffsetInteger\n│  ├─ Signed\n│  │  ├─ BigInt\n│  │  ├─ Int128\n│  │  ├─ Int16\n│  │  ├─ Int32\n│  │  ├─ Int64\n│  │  └─ Int8\n│  └─ Unsigned\n│     ├─ UInt128\n│     ├─ UInt16\n│     ├─ UInt32\n│     ├─ UInt64\n│     └─ UInt8\n├─ Rational\n├─ SimpleRatio\n├─ PValue\n└─ TestStat\n\n\n\n\nGetting the Parent Type\nTo find the immediate supertype (parent type) of a specific type, you can use the supertype() function. Here’s an example:\n\nsupertype(Int64)\n\nSigned\n\n\nThis will return the immediate parent type of Int64.\n\n\nGetting the List of All Parent Types\nTo get the entire chain of parent types, you can use the supertypes() function, which directly returns all the parent types of a given type. Here’s an example that shows how to do this for Float64:\n\nsupertypes(Float64)\n\n(Float64, AbstractFloat, Real, Number, Any)\n\n\nThis code will return the list of all parent types of Float64, starting from Float64 itself and going up the type hierarchy to Any. This can be useful for understanding the relationships between different types in Julia. To print the list of parent types in a more readable format, you can use the join function:\n\njoin(supertypes(Float64), \" -&gt; \")\n\n\"Float64 -&gt; AbstractFloat -&gt; Real -&gt; Number -&gt; Any\"\n\n\n\n\n\nType Hierarchies and Performance\nThe type hierarchy plays a crucial role in enabling multiple dispatch in Julia, allowing for efficient method selection based on the types of function arguments. By organizing types into a well-defined hierarchy, Julia can quickly select the most specific method for a given operation, optimizing performance, especially in scientific and numerical computing.\n\n\nQuiz\n\n\n\n\n\n\nQuiz: Type Hierarchies in Julia\n\n\n\n\n\n\n\nQuestion 1. What is the purpose of an abstract type in Julia?\n\n\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        It can be instantiated and used directly.\n    \n    \n\n\n    \n    \n    \n    \n        It defines a concrete implementation for other types.\n    \n    \n\n\n    \n    \n    \n    \n        It provides a blueprint for organizing related types but cannot be instantiated.\n    \n    \n\n\n    \n    \n    \n    \n        It is used for type annotations in functions.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 2. Which of the following types is a concrete type?\n\n\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        Real\n    \n    \n\n\n    \n    \n    \n    \n        Number\n    \n    \n\n\n    \n    \n    \n    \n        Int64\n    \n    \n\n\n    \n    \n    \n    \n        AbstractFloat\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 3. What does the isconcretetype function return for AbstractFloat?\n\n\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        Error: Undefined type\n    \n    \n\n\n    \n    \n    \n    \n        true\n    \n    \n\n\n    \n    \n    \n    \n        false\n    \n    \n\n\n    \n    \n    \n    \n        null\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 4. What will the following code return?\n\n\n\n\ntypeof(42)\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        Int64\n    \n    \n\n\n    \n    \n    \n    \n        Integer\n    \n    \n\n\n    \n    \n    \n    \n        Real\n    \n    \n\n\n    \n    \n    \n    \n        Number\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 5. What is the purpose of the isa operator in Julia?\n\n\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        To check if a variable's value matches a specific type.\n    \n    \n\n\n    \n    \n    \n    \n        To check if a variable is a subtype of Any.\n    \n    \n\n\n    \n    \n    \n    \n        To check if a type is concrete.\n    \n    \n\n\n    \n    \n    \n    \n        To check if a variable is an instance of a specific type or any of its subtypes.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 6. What will be the result of the following code?\n\n\n\n\nInt64 &lt;: Real\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        Error: Type mismatch\n    \n    \n\n\n    \n    \n    \n    \n        true for Float64 but not for Int64\n    \n    \n\n\n    \n    \n    \n    \n        true\n    \n    \n\n\n    \n    \n    \n    \n        false\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 7. What will the following code return?\n\n\n\n\nisconcretetype(Int64)\nisconcretetype(AbstractFloat)\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        true for Int64 and false for AbstractFloat\n    \n    \n\n\n    \n    \n    \n    \n        true for AbstractFloat and false for Int64\n    \n    \n\n\n    \n    \n    \n    \n        false for both types if using a different syntax\n    \n    \n\n\n    \n    \n    \n    \n        false for both types\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 8. What does the &lt;: operator check in Julia?\n\n\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        If one type is a subtype of another.\n    \n    \n\n\n    \n    \n    \n    \n        If two types are exactly the same.\n    \n    \n\n\n    \n    \n    \n    \n        If a type is abstract.\n    \n    \n\n\n    \n    \n    \n    \n        If a type can be instantiated.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 9. What is the result of the following code?\n\n\n\n\nsubtypes(Real)\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        Returns an error because Real is abstract.\n    \n    \n\n\n    \n    \n    \n    \n        Returns Any as the only subtype of Real.\n    \n    \n\n\n    \n    \n    \n    \n        Returns a list of all types that are subtypes of Real.\n    \n    \n\n\n    \n    \n    \n    \n        Shows Real as a parent type with no subtypes.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 10. What does the supertype function return for Float64?\n\n\n\n\nsupertype(Float64)\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        Int\n    \n    \n\n\n    \n    \n    \n    \n        Real\n    \n    \n\n\n    \n    \n    \n    \n        AbstractFloat\n    \n    \n\n\n    \n    \n    \n    \n        Number",
    "crumbs": [
      "Julia language",
      "Types"
    ]
  },
  {
    "objectID": "src/types.html#type-conversion-and-promotion",
    "href": "src/types.html#type-conversion-and-promotion",
    "title": "Types",
    "section": "Type Conversion and Promotion",
    "text": "Type Conversion and Promotion\nIn Julia, type conversion and promotion are mechanisms that allow for flexibility when working with different types, enabling smooth interactions and arithmetic between varying data types. Conversion changes the type of a value, while promotion ensures two values have a common type for an operation.\n\nType Conversion\nType conversion in Julia is typically achieved with the convert function, which tries to change a value from one type to another. For conversions between Float64 and Int, methods like round and floor are commonly used to handle fractional parts safely. To convert numbers to strings, use the string() function instead.\n\nround(Int, 3.84)   \nfloor(Int, 3.14)\nconvert(Float64, 5)\nstring(123)\n\njulia&gt; round(Int, 3.84) = 4\njulia&gt; floor(Int, 3.14) = 3\njulia&gt; convert(Float64, 5) = 5.0\njulia&gt; string(123) = \"123\"\n\n\nIn these examples:\n\nround rounds a Float64 to the nearest Int.\nfloor converts a Float64 to the nearest lower Int.\nConverting an Int to Float64 represents the integer as a floating-point number.\nstring() converts an integer to its string representation.\n\n\n\nAutomatic Conversion\nIn many cases, Julia will automatically convert types when it is unambiguous. For instance, you can directly assign an integer to a floating-point variable, and Julia will automatically convert it.\n\nt::Float64 = 10  # The integer 10 is converted to 10.0 (Float64)\n\njulia&gt; t::Float64 = 10.0\n\n\n\n\nType Promotion\nType promotion is used when combining two values of different types in an operation. Julia promotes values to a common type using the promote function, which returns values in their promoted type. This is useful when performing arithmetic on values of different types.\n\na, b = promote(3, 4.5)  # Promotes both values to Float64\ntypeof(a)\ntypeof(b)\n\njulia&gt; (a, b) = (3.0, 4.5)\njulia&gt; typeof(a) = Float64\njulia&gt; typeof(b) = Float64\n\n\nIn this example, promote converts both 3 (an Int) and 4.5 (a Float64) to Float64 so they can be added, subtracted, or multiplied without any type conflicts.\n\n\n\n\n\n\nWarning\n\n\n\nBe aware that promotion has nothing to do with the type hierarchy. For instance, although every Int value can also be represented as a Float64 value, Int is not a subtype of Float64.\n\n\n\n\nSummary\n\nconvert(Type, value): Converts value to the specified Type, if possible.\npromote(x, y): Returns both x and y promoted to a common type.\nType promotion rules allow Julia to handle operations between different types smoothly, making the language both powerful and flexible for numerical and data processing tasks.\n\n\n\nQuiz\n\n\n\n\n\n\nQuiz: Type Conversion and Promotion in Julia\n\n\n\n\n\n\n\nQuestion 1. What does the convert function do in Julia?\n\n\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        It converts numbers to strings.\n    \n    \n\n\n    \n    \n    \n    \n        It changes a value to a boolean type.\n    \n    \n\n\n    \n    \n    \n    \n        It automatically promotes values to a common type.\n    \n    \n\n\n    \n    \n    \n    \n        It converts a value from one type to another, if possible.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 2. What is the output of the following code?\n\n\n\n\nprintln(round(Int, 3.14))   # Rounds 3.14 to the nearest integer, output: 3\nprintln(floor(Int, 3.14))   # Floors 3.14 to the nearest integer, output: 3\nprintln(convert(Float64, 5))  # Converts Int to Float64, output: 5.0\nprintln(string(123))         # Converts Int to String, output: \"123\"\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        5.0, 3, 5, '123'\n    \n    \n\n\n    \n    \n    \n    \n        3, 3, 5.0, '123'\n    \n    \n\n\n    \n    \n    \n    \n        3, 3, 5.0, 123\n    \n    \n\n\n    \n    \n    \n    \n        3, 3.14, 5, '123'\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 3. What happens when an integer is assigned to a Float64 variable in Julia?\n\n\n\n\ny::Float64 = 10  # The integer 10 is automatically converted to 10.0 (Float64)\nprintln(y)       # Output: 10.0\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        Julia automatically converts the integer to a Float64.\n    \n    \n\n\n    \n    \n    \n    \n        Julia throws a type error because of the type mismatch.\n    \n    \n\n\n    \n    \n    \n    \n        The variable y will be set to the integer value of 10.\n    \n    \n\n\n    \n    \n    \n    \n        The conversion needs to be done explicitly using convert.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 4. What does the promote function do in Julia?\n\n\n\n\na, b = promote(3, 4.5)  # Promotes both values to Float64\nprintln(a)              # Output: 3.0\nprintln(b)              # Output: 4.5\nprintln(typeof(a))      # Output: Float64\nprintln(typeof(b))      # Output: Float64\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        It converts both values to integers.\n    \n    \n\n\n    \n    \n    \n    \n        It converts values to strings for display.\n    \n    \n\n\n    \n    \n    \n    \n        It checks if two values have the same type.\n    \n    \n\n\n    \n    \n    \n    \n        It promotes two values to a common type for an operation.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 5. What will happen if we try to add an Int and a String in Julia?\n\n\n\n\nprintln(3 + \"Hello\")  # Attempting to add Int and String\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        It will concatenate the string and the number.\n    \n    \n\n\n    \n    \n    \n    \n        It will throw a type error.\n    \n    \n\n\n    \n    \n    \n    \n        Julia will automatically convert both to a common type.\n    \n    \n\n\n    \n    \n    \n    \n        It will promote the number to a string.",
    "crumbs": [
      "Julia language",
      "Types"
    ]
  },
  {
    "objectID": "src/types.html#composite-types",
    "href": "src/types.html#composite-types",
    "title": "Types",
    "section": "Composite Types",
    "text": "Composite Types\n\nIntroduction to struct\nIn Julia, you can define your own custom data types using the struct keyword. Composite types are user-defined types that group together different pieces of data into one object. A struct is a great way to create a type that can represent a complex entity with multiple fields.\n\nCreating a custom struct:\n\n\n# Define a simple struct for a point in 2D space\nstruct Point\n    x::Float64\n    y::Float64\nend\n\nHere, we created a Point struct with two fields: x and y, both of which are of type Float64.\n\nCreating an instance of a struct:\n\n\np = Point(3.0, 4.0)  # Creates a Point with x = 3.0 and y = 4.0\n\nPoint(3.0, 4.0)\n\n\n\nAccessing fields of a struct:\n\n\np.x  # Access the 'x' field of the Point instance\np.y  # Access the 'y' field of the Point instance\n\n4.0\n\n\nYou can access the fields of a struct directly using dot notation, as shown above.\n\nGet the names of the fields:\n\n\nfieldnames(Point)  # Returns the names of the fields in the Point struct\n\n(:x, :y)\n\n\n\n\nMutability of struct\nIn Julia, structs are immutable by default, meaning once you create an instance of a struct, its fields cannot be changed. However, you can create mutable structs by using the mutable struct keyword, which allows modification of field values after creation.\n\nCreating a mutable struct:\n\n\nmutable struct MutablePoint\n    x::Float64\n    y::Float64\nend\n\nNow you can modify the fields of MutablePoint instances after they are created.\n\nmp = MutablePoint(1.0, 2.0)\nmp.x = 3.0  # Modify the 'x' field\n\n\n\nExample: struct for a Circle\nWe can create a more complex type, such as a Circle, which has a center represented by a Point and a radius:\n\nstruct Circle\n    center::Point\n    radius::Float64\nend\n\n\nCreating an instance of Circle:\n\n\nc = Circle(Point(0.0, 0.0), 5.0)  # Create a circle with center (0, 0) and radius 5\n\nCircle(Point(0.0, 0.0), 5.0)\n\n\n\nAccessing fields of a nested struct:\n\n\nc.center.x  # Access the x field of the center of the circle\nc.center.y  # Access the y field of the center of the circle\nc.radius    # Access the radius of the circle\n\n\n\nConstructor methods\nLet us look at an example. A Duck is an object that can be described as follows:\n\nstate: a name (name::String) and number of feathers (nb::Int32);\nlocation: a position on a 2-D grid (pt::Point).\n\nIn order to create a Duck, it is necessary to define the object (as seen previously with Point).\n\nstruct Duck\n    name::String\n    nb::Int64\n    pt::Point\nend\n\nIn order to create a Duck with the name “Donald”, we simply use the default constructor generated by the Julia language.\n\ndonald = Duck(\"Donald\", 10000, Point(0.,0.))\n\nDuck(\"Donald\", 10000, Point(0.0, 0.0))\n\n\nAs any function in Julia, a constructor function can be associated with several constructor methods. The object Duck has been defined. Still, it is possible to add so called outer constructor methods. For example, we can provide a method that takes two Float64 instead of an instance of the Point object.\n\nDuck(name::String, nb::Int64, x::Float64, y::Float64) = Duck(name, nb, Point(x,y));\n\nWe can now create another Duck without using the Point object.\n\nscrooge = Duck(\"Scrooge\", 5000, 0., 1.)\n\nDuck(\"Scrooge\", 5000, Point(0.0, 1.0))\n\n\nOh! But Scrooge is a cheapskate. Let us look into inner constructor methods in order to avoid any Duck from being called “Scrooge”. An inner constructor can only be defined within the definition of the object. Let us rewrite the Duck object in order to replace the default constructor method by our own constructor method.\n\nstruct Duck\n    name::String\n    nb::Int64\n    pt::Point\n\n    function Duck(name::String, nb::Int64, pt::Point)\n        if name == \"Scrooge\"\n            error(\"A Duck can not be a cheapskate!!\")\n        end\n        new(name, nb, pt)\n    end\nend\n\nLet us try to create a Duck called “Scrooge” now.\n\nscrooge = Duck(\"Scrooge\", 5000, 0., 1.)\n\n\nA Duck can not be a cheapskate!!\n\nStacktrace:\n [1] error(s::String)\n   @ Base ./error.jl:35\n [2] Duck\n   @ ./In[68]:8 [inlined]\n [3] Duck(name::String, nb::Int64, x::Float64, y::Float64)\n   @ Main ./In[66]:1\n [4] top-level scope\n   @ In[69]:1\n\n\n\nGreat an error was thrown!\n\n\nFunction-like Object (Callable struct)\nIn Julia, you can make a struct “callable” by defining the call method for it. This allows instances of the struct to be used like functions. This feature is useful for encapsulating parameters or states in a type while still allowing it to behave like a function.\nHere’s an example that demonstrates a callable struct for a linear transformation:\n\n# Define a callable struct for a linear transformation\nstruct LinearTransform\n    a::Float64  # Slope\n    b::Float64  # Intercept\nend\n\n# Define the call method for LinearTransform\nfunction (lt::LinearTransform)(x::Real)\n    lt.a * x + lt.b  # Apply the linear transformation\nend\n\n\nExplanation:\n\nThe LinearTransform struct stores the parameters of the linear function ( y = ax + b ).\nBy defining the call method for the struct, you enable instances of LinearTransform to behave like a function.\n\nUsage:\n\n\n# Create an instance of LinearTransform\nlt = LinearTransform(2.0, 3.0)  # y = 2x + 3\n\n# Call the instance like a function\ntypeof(lt)  # Output: LinearTransform\ny1 = lt(5)   # Calculates 2 * 5 + 3 = 13\ny2 = lt(-1)  # Calculates 2 * -1 + 3 = 1\n\njulia&gt; typeof(lt) = LinearTransform\njulia&gt; y1 = 13.0\njulia&gt; y2 = 1.0\n\n\n\n\nExtending the Concept: Composable Linear Transforms\nYou can take this idea further by allowing composition of transformations. For example:\n\n# Define a method to compose two LinearTransform objects\nfunction (lt1::LinearTransform)(lt2::LinearTransform)\n    LinearTransform(lt1.a * lt2.a, lt1.a * lt2.b + lt1.b)\nend\n\n# Example usage\nlt1 = LinearTransform(2.0, 3.0)  # y = 2x + 3\nlt2 = LinearTransform(0.5, 1.0)  # y = 0.5x + 1\n\n# Compose the two transformations\nlt_composed = lt1(lt2)  # Equivalent to y = 2 * (0.5x + 1) + 3\n\n# Call the composed transformation\ny = lt_composed(4)  # Calculates 2 * (0.5 * 4 + 1) + 3 = 9\n\njulia&gt; y = 9.0\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe previous composition is equivalent in pure Julia to:\n\ny = (lt1 ∘ lt2)(4)\n\n9.0\n\n\n\n\n\n\nConclusion\n\nIn Julia, struct allows you to create complex custom types that can hold different types of data. Custom constructors provide flexibility for struct initialization, allowing validation and preprocessing of input data. This is especially useful for enforcing constraints and ensuring type consistency. By default, structs are immutable, but you can use mutable struct if you need to change the data after creation.\nUsing a callable struct allows you to represent parameterized functions or transformations in a concise and reusable way. The concept can be extended further to support operations like composition or chaining, making it a powerful tool for functional-style programming in Julia.\n\n\n\nParametric Composite Types\nA parametric struct can take one or more type parameters:\n\nstruct Pair{T, S}\n    first::T\n    second::S\nend\n\npair1 = Pair(1, \"apple\")  # Pair of Int and String\npair2 = Pair(3.14, true)  # Pair of Float64 and Bool\n\njulia&gt; pair1 = Pair{Int64, String}(1, \"apple\")\njulia&gt; pair2 = Pair{Float64, Bool}(3.14, true)\n\n\nIn this case, Pair can be instantiated with any two types T and S, making it more versatile.\n\n\nParametric Abstract Types\nParametric abstract types allow you to define abstract types that are parameterized by other types.\n\nSyntax:\nabstract type AbstractContainer{T} end\nHere, AbstractContainer is an abstract type that takes a type parameter T. Any concrete type that is a subtype of AbstractContainer can specify the concrete type for T.\n\n\nExample:\n\nabstract type AbstractContainer{T} end\n\nstruct VectorContainer{T} &lt;: AbstractContainer{T}\n    data::Vector{T}\nend\n\nstruct SetContainer{T} &lt;: AbstractContainer{T}\n    data::Set{T}\nend\n\nstruct FloatVectorContainer &lt;: AbstractContainer{Float64}\n    data::Vector{Float64}\nend\n\nfunction print_container_info(container::AbstractContainer{T}) where T\n    println(\"Container holds values of type: \", T)\nend\n\n# Usage:\nvec = VectorContainer([1, 2, 3])\nset = SetContainer(Set([1, 2, 3]))\nflo = FloatVectorContainer([1.0, 2.0, 3.0])\n\nprint_container_info(vec)\nprint_container_info(set)\nprint_container_info(flo)\n\nContainer holds values of type: Int64\nContainer holds values of type: Int64\nContainer holds values of type: Float64\n\n\n\n\nExplanation:\n\nAbstractContainer{T} is a parametric abstract type, where T represents the type of elements contained within the container.\nVectorContainer and SetContainer are concrete subtypes of AbstractContainer, each using a different data structure (Vector and Set) to store elements of type T.\nFloatVectorContainer is a concrete subtype of AbstractContainer that specifies Float64 as the type for T.\nThe function print_container_info accepts any container that is a subtype of AbstractContainer and prints the type of elements inside the container.\n\n\n\n\nConstrained Parametric Types\nConstrained parametric types allow you to restrict acceptable type parameters using &lt;:, ensuring greater control and type safety.\n\nstruct RealPair{T &lt;: Real}\n    first::T\n    second::T\nend\n\n# Valid:\npair = RealPair(1.0, 2.5)\n\n# Constraining a function:****\nfunction sum_elements(container::AbstractContainer{T}) where T &lt;: Real\n    return sum(container.data)\nend\n\nvec = VectorContainer([1.0, 2.0, 3.0])\nprintln(sum_elements(vec))  # Outputs: 6.0\n\n6.0\n\n\nIn this example, RealPair is a struct that only accepts type parameters that are subtypes of Real. Similarly, the sum_elements function only works with containers that hold elements of type T that are subtypes of Real. The following code will throw an error because String is not a subtype of Real:\n\n# Invalid (throws an error):\ninvalid_pair = RealPair(\"a\", \"b\")\n\n\nMethodError: no method matching RealPair(::String, ::String)\nThe type `RealPair` exists, but no method is defined for this combination of argument types when trying to construct it.\n\nClosest candidates are:\n  RealPair(::T, ::T) where T&lt;:Real\n   @ Main In[76]:2\n\n\nStacktrace:\n [1] top-level scope\n   @ In[77]:2\n\n\n\nConstraints enhance type safety, clarify requirements, and support robust generic programming.\n\n\nQuiz\n\n\n\n\n\n\nQuiz: Parametric Types in Julia\n\n\n\n\n\n\n\nQuestion 1. What is a parametric type in Julia?\n\n\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        A type that can work with multiple data types, specified by parameters.\n    \n    \n\n\n    \n    \n    \n    \n        A type that is defined for a specific data type.\n    \n    \n\n\n    \n    \n    \n    \n        A type that can only work with abstract types.\n    \n    \n\n\n    \n    \n    \n    \n        A type that doesn't require any parameters.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 2. What is the role of T and S in the Pair struct example?\n\n\n\n\nstruct Pair{T, S}\n    first::T\n    second::S\nend\n\npair1 = Pair(1, \"apple\")  # Pair of Int and String\npair2 = Pair(3.14, true)  # Pair of Float64 and Bool\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        T and S are unused in this case, they are placeholders.\n    \n    \n\n\n    \n    \n    \n    \n        T defines the data type of both elements in the pair.\n    \n    \n\n\n    \n    \n    \n    \n        T and S define the data types of the first and second elements of the pair.\n    \n    \n\n\n    \n    \n    \n    \n        T is used for the first element, and S is used for the second element.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 3. What happens when you instantiate Pair(1, 'apple') in the provided code?\n\n\n\n\npair1 = Pair(1, \"apple\")  # Pair of Int and String\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        It will create a pair with Int64 and String.\n    \n    \n\n\n    \n    \n    \n    \n        It will create a pair with an Int and a String.\n    \n    \n\n\n    \n    \n    \n    \n        It will cause a runtime error because the types don't match.\n    \n    \n\n\n    \n    \n    \n    \n        It will throw an error because Int and String can't be combined.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 4. What is the benefit of using parametric types like AbstractContainer{T}?\n\n\n\n\nabstract type AbstractContainer{T} end\n\nstruct VectorContainer{T} &lt;: AbstractContainer{T}\n    data::Vector{T}\nend\n\nstruct SetContainer{T} &lt;: AbstractContainer{T}\n    data::Set{T}\nend\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        It makes the code less flexible and more specific.\n    \n    \n\n\n    \n    \n    \n    \n        It makes the code more complex and harder to maintain.\n    \n    \n\n\n    \n    \n    \n    \n        It allows you to create types that can handle any type of data, with type safety.\n    \n    \n\n\n    \n    \n    \n    \n        It allows you to specify concrete types directly in the struct.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 5. What does the print_container_info function do?\n\n\n\n\nfunction print_container_info(container::AbstractContainer{T}) where T\n    println(\"Container holds values of type: \", T)\nend\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        It prints the values inside the container.\n    \n    \n\n\n    \n    \n    \n    \n        It prints the number of elements in the container.\n    \n    \n\n\n    \n    \n    \n    \n        It returns the type of the container.\n    \n    \n\n\n    \n    \n    \n    \n        It prints the type of the container.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 6. What is the purpose of AbstractContainer{T} in the code example?\n\n\n\n\nabstract type AbstractContainer{T} end\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        It defines a concrete container type.\n    \n    \n\n\n    \n    \n    \n    \n        It defines a container for a specific type of data.\n    \n    \n\n\n    \n    \n    \n    \n        It defines an abstract type that can be used to create containers for any data type T.\n    \n    \n\n\n    \n    \n    \n    \n        It restricts containers to hold only numeric types.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 7. What would be the output of print_container_info(vec) if vec is VectorContainer([1, 2, 3])?\n\n\n\n\nvec = VectorContainer([1, 2, 3])\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        It will print the values inside the container.\n    \n    \n\n\n    \n    \n    \n    \n        It will print the type AbstractContainer{Int}.\n    \n    \n\n\n    \n    \n    \n    \n        It will throw an error because VectorContainer is not defined.\n    \n    \n\n\n    \n    \n    \n    \n        It will print the type Vector{Int}.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 8. How does using parametric types help with code reusability?\n\n\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        It forces you to create new types for every use case.\n    \n    \n\n\n    \n    \n    \n    \n        It makes the code less reusable.\n    \n    \n\n\n    \n    \n    \n    \n        It reduces the need to define separate functions for different data types.\n    \n    \n\n\n    \n    \n    \n    \n        It requires more boilerplate code.",
    "crumbs": [
      "Julia language",
      "Types"
    ]
  },
  {
    "objectID": "src/types.html#exercises",
    "href": "src/types.html#exercises",
    "title": "Types",
    "section": "Exercises",
    "text": "Exercises\n\nExercise 1: Creating a Shape System\nCreate a system to represent different geometric shapes (like a Square, Circle, and Point) using the following requirements:\n\nDefine a Point struct with x and y coordinates of type Float64.\nDefine a Square struct with the field width of type Float64. Use the Point struct to represent the bottom-left corner of the square.\nDefine a Circle struct with a Point for the center and a radius of type Float64.\nWrite a function area(shape) that computes the area of the given shape:\n\nThe area of a square is width * width.\nThe area of a circle is π * radius^2.\n\n\n\n\n\n\n\n\nHint for Exercise 1:\n\n\n\n\n\n\nUse struct to define Point, Square, and Circle.\nUse dot notation to access the fields of the structs.\nUse conditional logic (e.g., typeof()) to handle different shapes in the area function.\nFor the circle, use π = 3.141592653589793.\n\n\n\n\n\n\n\n\n\n\nCorrection of Exercise 1:\n\n\n\n\n\n\n# Define the Point struct\nstruct Point\n    x::Float64\n    y::Float64\nend\n\n# Define the Square struct\nstruct Square\n    bottom_left::Point\n    width::Float64\nend\n\n# Define the Circle struct\nstruct Circle\n    center::Point\n    radius::Float64\nend\n\n# Function to calculate the area\nfunction area(shape)\n    if typeof(shape) == Square\n        return shape.width * shape.width\n    elseif typeof(shape) == Circle\n        return π * shape.radius^2\n    else\n        throw(ArgumentError(\"Unsupported shape\"))\n    end\nend\n\n# Example usage\np1 = Point(0.0, 0.0)\nr1 = Square(p1, 3.0)\nc1 = Circle(p1, 5.0)\n\nprintln(\"Area of square: \", area(r1))  # Should print 12.0\nprintln(\"Area of circle: \", area(c1))     # Should print 78.53981633974483\n\nArea of square: 9.0\nArea of circle: 78.53981633974483\n\n\n\n\n\n\n\nExercise 2: Working with Complex Numbers and Arrays\n\nCreate two complex numbers z1 and z2 of type Complex{Float64}.\nWrite a function add_complex(z1, z2) that adds two complex numbers and returns the result.\nCreate an array of complex numbers and use the map function to add 2.0 to the real part of each complex number.\nCreate a function max_real_part that returns the complex number with the largest real part from an array of complex numbers.\n\n\n\n\n\n\n\nHint for Exercise 2:\n\n\n\n\n\n\nUse the Complex{T} type to create complex numbers.\nYou can access the real and imaginary parts of a complex number with real(z) and imag(z).\nUse the map function to apply a transformation to each element of an array.\nCompare the real parts of the complex numbers using real(z) to find the maximum.\n\n\n\n\n\n\n\n\n\n\nCorrection of Exercise 2:\n\n\n\n\n\n\n# Create two complex numbers\nz1 = Complex{Float64}(3.0, 4.0)  # z1 = 3.0 + 4.0im\nz2 = Complex{Float64}(1.0, 2.0)  # z2 = 1.0 + 2.0im\n\n# Function to add two complex numbers\nfunction add_complex(z1, z2)\n    return z1 + z2\nend\n\n# Add 2.0 to the real part of each complex number in an array\narr = [Complex{Float64}(3.0, 4.0), Complex{Float64}(1.0, 2.0), Complex{Float64}(5.0, 6.0)]\nnew_arr = map(z -&gt; Complex(real(z) + 2.0, imag(z)), arr)\n\nprintln(\"New array with modified real parts: \", new_arr)\n\n# Function to find the complex number with the largest real part\nfunction max_real_part(arr)\n    max_z = arr[1]\n    for z in arr\n        if real(z) &gt; real(max_z)\n            max_z = z\n        end\n    end\n    return max_z\nend\n\n# Find the complex number with the largest real part\nmax_z = max_real_part(arr)\nprintln(\"Complex number with the largest real part: \", max_z)\n\nNew array with modified real parts: ComplexF64[5.0 + 4.0im, 3.0 + 2.0im, 7.0 + 6.0im]\nComplex number with the largest real part: 5.0 + 6.0im",
    "crumbs": [
      "Julia language",
      "Types"
    ]
  },
  {
    "objectID": "src/structure.html",
    "href": "src/structure.html",
    "title": "Structure your code",
    "section": "",
    "text": "Now, you got familiar with the basic syntax of Julia — the foundation for writing simple scripts. However, as programs grow in size and complexity, writing code in a flat, linear way becomes difficult to manage, debug, and reuse. This is why in this page you will learn to move from basic syntax to structured code. Introducing functions allows you to break the code into reusable, logical blocks, making it easier to read, test, and maintain. Incorporating error handling ensures your program can manage unexpected situations gracefully instead of crashing, which is crucial for reliability. Finally, using modules helps organize code across multiple files, encourages reusability, and separates concerns—for example, keeping database code apart from user interface code. Together, these practices lead to cleaner, more robust, and scalable programs, which is the goal of any serious software development effort.",
    "crumbs": [
      "Julia language",
      "Structure your code"
    ]
  },
  {
    "objectID": "src/structure.html#functions",
    "href": "src/structure.html#functions",
    "title": "Structure your code",
    "section": "Functions",
    "text": "Functions\nJulia offers flexible ways to define functions, with options for positional arguments, keyword arguments, optional arguments with default values, and variable-length arguments. Let’s explore each of these in detail.\n\nDefining Functions\nFunctions in Julia can be defined using either the function keyword or the assignment syntax.\n\n# Using the `function` keyword\nfunction add(a, b)\n    return a + b\nend\n\n# Using assignment syntax\nmultiply(a, b) = a * b\n\nadd(2, 3)\nmultiply(2, 3)\n\njulia&gt; add(2, 3) = 5\njulia&gt; multiply(2, 3) = 6\n\n\n\n\n\n\n\n\nWarning\n\n\n\nThe function add has been defined without any specification on the kind of data which is accepted. We expect, however, the + operator not to make sense for any combination of data. 5+2 looks reasonable while 2+\"hello\" seems confusing. If, for example, you wish to use add only for integers (let say of the Int64 kind), you would annotate the function in the following way: function add(a::Int64, b::Int64).\nIf you wish add to take integers or real numbers, you should use the kind of data referred as Union to annote the arguments. It is created by specifying a list of data kinds within Union{}, here Union{Int64, Float64}.\n\n\n\n\nPositional and Keyword Arguments\nIn Julia, functions can take both positional arguments and keyword arguments.\n\nPositional Arguments: These are listed first in the parameter list and must be provided in the correct order when the function is called. Positional arguments can have default values, but it’s not required.\nKeyword Arguments: Keyword arguments are specified after a semicolon (;) in the parameter list. These arguments must be provided by name when calling the function. Like positional arguments, keyword arguments can have default values, but they don’t have to.\n\n\nfunction greet(name; punctuation = \"!\")\n    return \"Hello, \" * name * punctuation\nend\n\nprintln(greet(\"Alice\"))\nprintln(greet(\"Alice\", punctuation = \"?\"))\n\nHello, Alice!\nHello, Alice?\n\n\nIn this example, punctuation is a keyword argument with a default value of \"!\". You could also define a keyword argument without a default value if needed.\n\n\n\n\n\n\nNote\n\n\n\nIn Julia, when you define a function with multiple positional arguments, those arguments are actually packed into a tuple when you call the function. This kind of data is reffered to as Tuple.\nKeyword arguments are different from positional arguments because they are explicitly named when the function is called. Keyword arguments are passed as a kind of data reffered to as NamedTuple. It is a special kind of tuple where each element is paired with a name (as the key) and a corresponding value.\n\n\n\n\nVariable Number of Arguments\nJulia functions can accept an arbitrary number of arguments using the splatting operator .... These arguments are gathered into a tuple.\n\nfunction sum_all(args...)\n    total = 0\n    for x in args\n        total += x\n    end\n    return total\nend\n\nsum_all(1, 2, 3, 4)\n\njulia&gt; sum_all(1, 2, 3, 4) = 10\n\n\n\n\nDefault Values for Optional Arguments\nIn Julia, you can assign default values to both positional and keyword arguments. When the function is called without specifying a value for an argument with a default, the default value is used.\n\nfunction power(base, exponent=2)\n    return base ^ exponent\nend\n\npower(3)      # Outputs: 9 (since exponent defaults to 2)\npower(3, 3)   # Outputs: 27\n\njulia&gt; power(3) = 9\njulia&gt; power(3, 3) = 27\n\n\n\n\nMultiple Optional Positional Arguments\nWhen a function has multiple optional positional arguments, Julia will use the default values for any arguments not provided, allowing flexible combinations.\n\nfunction calculate(a=1, b=2, c=3)\n    return a + b * c\nend\n\ncalculate()        # Outputs: 7  (1 + 2 * 3)\ncalculate(5)       # Outputs: 11 (5 + 2 * 3)\ncalculate(5, 4)    # Outputs: 17 (5 + 4 * 3)\ncalculate(5, 4, 1) # Outputs: 9  (5 + 4 * 1)\n\njulia&gt; calculate() = 7\njulia&gt; calculate(5) = 11\njulia&gt; calculate(5, 4) = 17\njulia&gt; calculate(5, 4, 1) = 9\n\n\nHere’s how the argument combinations work:\n\ncalculate() uses all default values: a=1, b=2, c=3.\ncalculate(5) overrides a, leaving b and c as defaults.\ncalculate(5, 4) overrides a and b, leaving c as the default.\ncalculate(5, 4, 1) overrides all arguments.\n\nThis flexibility makes it easy to call functions with varying levels of detail without explicitly specifying each parameter.\n\n\n\n\n\n\nTip\n\n\n\nIf a function has many optional arguments, consider using keyword arguments to improve readability and avoid confusion about the order of arguments.\n\n\n\n\nMutation and the Bang ! Convention\nIn Julia, functions that modify or mutate their arguments typically end with a !, following the “bang” convention. This is not enforced by the language but is a widely followed convention in Julia to indicate mutation.\n\nfunction add_one!(array)\n    for i in eachindex(array)\n        array[i] += 1\n    end\nend\n\narr = [1, 2, 3]\nadd_one!(arr)\narr  # Outputs: [2, 3, 4]\n\njulia&gt; arr = [1, 2, 3]\njulia&gt; add_one!(arr) = nothing\njulia&gt; arr = [2, 3, 4]\n\n\nIn this example, add_one! modifies the elements of the array arr. By convention, the ! at the end of the function name indicates that the function mutates its input.\n\n\nBroadcasting\nJulia supports broadcasting, a powerful feature that applies a function element-wise to arrays or other collections. Broadcasting is denoted by a . placed before the function call or operator.\n\n# Define a simple function\nfunction square(x)\n    return x^2\nend\n\n# Apply the function to a vector using broadcasting\nvec = [1, 2, 3, 4]\nsquared_vec = square.(vec)\n\nprintln(\"Original vector: \", vec)\nprintln(\"Squared vector: \", squared_vec)\n\nOriginal vector: [1, 2, 3, 4]\nSquared vector: [1, 4, 9, 16]\n\n\nIn this example:\n\nThe function square(x) is applied to each element of vec using the . operator.\nBroadcasting works seamlessly with both built-in and user-defined functions, making it easy to perform element-wise operations on arrays of any shape.\n\n\n\nReturn Values\nIn Julia, functions automatically return the last evaluated expression. However, you can use the return keyword to explicitly specify the output if needed.\nfunction multiply(a, b)\n    a * b  # Returns the result of a * b\nend\nIn the special case where a function does not return any data, the default return value in Julia is a kind of data called Nothing. It’s similar to void in languages like C or Java.",
    "crumbs": [
      "Julia language",
      "Structure your code"
    ]
  },
  {
    "objectID": "src/structure.html#errors-and-exception-handling",
    "href": "src/structure.html#errors-and-exception-handling",
    "title": "Structure your code",
    "section": "Errors and Exception Handling",
    "text": "Errors and Exception Handling\nJulia provides a powerful framework for managing and handling errors, which helps in writing robust programs. Error handling in Julia involves various built-in error types and mechanisms, including throw for raising errors and try/catch blocks for handling exceptions.\n\nCommon Error Types in Julia\nJulia has several built-in error types that are commonly used:\n\nArgumentError: Raised when a function receives an argument that is inappropriate or out of expected range.\nBoundsError: Occurs when trying to access an index that is out of bounds for an array or collection.\nDivideError: Raised when division by zero is attempted.\nDomainError: Raised when a mathematical function is called with an argument outside its domain. For instance, taking the square root of a negative number.\nMethodError: Occurs when a method is called with incorrect arguments or types.\n\n\n\nRaising Errors with throw\nIn Julia, you can explicitly raise an error using the throw function. This is useful for defining custom error conditions in your code. To throw an error, call throw with an instance of an error type:\n\nfunction divide(a, b)\n    if b == 0\n        throw(DivideError())\n    end\n    return a / b\nend\n\ndivide(10, 0)  # Will raise a DivideError\n\n\nDivideError: integer division error\n\nStacktrace:\n [1] divide(a::Int64, b::Int64)\n   @ Main ./In[10]:3\n [2] top-level scope\n   @ In[10]:8\n\n\n\nIn this example, the function divide will throw a DivideError if the second argument b is zero, making the function safer and more robust.\n\n\nHandling Errors with try/catch\nJulia provides try/catch blocks for managing exceptions gracefully. Code within a try block runs until an error is encountered. If an error is thrown, control passes to the catch block, where you can handle the error.\nHere’s an example of using try/catch with the divide function:\n\ntry\n    println(divide(10, 0))  # Will raise an error\ncatch e\n    println(\"Error: \", e)  # Handles the error\nend\n\nError: DivideError()\n\n\nIn this example:\n\nIf divide(10, 0) raises an error, the program catches it and prints a custom message instead of stopping execution.\nThe variable e holds the error, which can be printed or used for further handling.\n\n\n\nUsing finally for Cleanup\nIn Julia, finally is a block used in conjunction with try and catch to ensure that certain cleanup actions are executed regardless of whether an error occurs or not. This is useful for tasks like closing files, releasing resources, or resetting variables that need to be done after the execution of a try-catch block.\nThe code inside the finally block is always executed, even if an exception is thrown and caught. This makes it ideal for situations where you need to guarantee that some actions occur after the main code runs, like resource deallocation.\n\nSyntax:\n\ntry\n    # Code that might throw an error\ncatch exception\n    # Code to handle the error\nfinally\n    # Cleanup code that will always run\nend\n\n\n\nExample:\n\nfunction safe_file_read(filename::String)\n    file = nothing\n    try\n        file = open(filename, \"r\")\n        data = read(file, String)\n        return data\n    catch e\n        println(\"An error occurred: \", e)\n    finally\n        if file !== nothing\n            close(file)\n            println(\"File closed.\")\n        end\n    end\nend\n\n# Test with a valid file\nprintln(safe_file_read(\"example.txt\"))\n\n# Test with an invalid file\nprintln(safe_file_read(\"nonexistent.txt\"))\n\nAn error occurred: SystemError(\"opening file \\\"example.txt\\\"\", 2, nothing)\nnothing\nAn error occurred: SystemError(\"opening file \\\"nonexistent.txt\\\"\", 2, nothing)\nnothing\n\n\n\n\nExplanation:\n\nThe finally block ensures that the file is always closed after reading, even if an error occurs (e.g., file not found, read error).\nIf the open operation is successful, the finally block will still execute and close the file, ensuring proper resource management.\nIf an exception is thrown in the try block (like a non-existent file), it will be caught and handled by the catch block, but the finally block will still execute to close the file (if opened).\n\n\n\nUse Cases for finally:\n\nClosing files or network connections.\nReleasing resources (e.g., database connections, locks).\nResetting the program state to a known clean state.\n\n\n\n\nQuiz\n\n\n\n\n\n\nQuiz: Errors and Exception Handling in Julia\n\n\n\n\n\n\n\nQuestion 1. Which error type is raised when an index is out of bounds in an array?\n\n\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        BoundsError\n    \n    \n\n\n    \n    \n    \n    \n        DivisionByZeroError\n    \n    \n\n\n    \n    \n    \n    \n        IOError\n    \n    \n\n\n    \n    \n    \n    \n        ArgumentError\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 2. What does the following code do in Julia?\n\n\n\n\nfunction divide(a, b)\n    if b == 0\n        throw(DivideError())\n    end\n    return a / b\nend\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        It throws a BoundsError if a or b are not numbers.\n    \n    \n\n\n    \n    \n    \n    \n        It raises an ArgumentError when a or b is invalid.\n    \n    \n\n\n    \n    \n    \n    \n        It performs division and returns the result.\n    \n    \n\n\n    \n    \n    \n    \n        It raises a DivideError when b equals 0.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 3. What happens when the following try/catch block is executed?\n\n\n\n\ntry\n    println(divide(10, 0))  # Will raise an error\ncatch e\n    println(\"Error: \", e)  # Handles the error\nend\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        The program throws an error and stops execution.\n    \n    \n\n\n    \n    \n    \n    \n        The program prints the result of the division.\n    \n    \n\n\n    \n    \n    \n    \n        The error is caught and a custom error message is printed.\n    \n    \n\n\n    \n    \n    \n    \n        The program silently ignores the error.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 4. What is the purpose of the finally block in Julia’s exception handling?\n\n\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        To perform the main logic of the program.\n    \n    \n\n\n    \n    \n    \n    \n        To rethrow any errors that are caught.\n    \n    \n\n\n    \n    \n    \n    \n        To catch all errors and handle them.\n    \n    \n\n\n    \n    \n    \n    \n        To ensure that cleanup code runs regardless of whether an error occurs.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 5. What is the output of the following code?\n\n\n\n\nfunction safe_file_read(filename::String)\n    file = nothing\n    try\n        file = open(filename, \"r\")\n        data = read(file, String)\n        return data\n    catch e\n        println(\"An error occurred: \", e)\n    finally\n        if file !== nothing\n            close(file)\n            println(\"File closed.\")\n        end\n    end\nend\n\n# Test with a valid file\nprintln(safe_file_read(\"example.txt\"))\n\n# Test with an invalid file\nprintln(safe_file_read(\"nonexistent.txt\"))\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        The program prints data from the file and closes it.\n    \n    \n\n\n    \n    \n    \n    \n        The program tries to read a file, catches errors, and always closes the file.\n    \n    \n\n\n    \n    \n    \n    \n        The program raises an error and does not close the file.\n    \n    \n\n\n    \n    \n    \n    \n        The program prints the error but skips file closing.\n    \n    \n\n\n\n         \n    \n    \n    \n\n\n\n\n\n\n\n\nQuestion 6. Which of the following is an appropriate use case for the finally block?\n\n\n\n\n\n\n\n\n  \n    \n      \n\n    \n    \nSelect an item\n\n    \n    \n    \n    \n        To catch all exceptions without handling them.\n    \n    \n\n\n    \n    \n    \n    \n        To prevent specific types of errors from being raised.\n    \n    \n\n\n    \n    \n    \n    \n        To handle errors and return a value from the finally block.\n    \n    \n\n\n    \n    \n    \n    \n        Ensuring a file is closed after reading, regardless of errors.",
    "crumbs": [
      "Julia language",
      "Structure your code"
    ]
  },
  {
    "objectID": "src/structure.html#scoping-and-closure",
    "href": "src/structure.html#scoping-and-closure",
    "title": "Structure your code",
    "section": "Scoping and Closure",
    "text": "Scoping and Closure\nIn Julia, scoping rules determine the visibility and lifetime of variables. Understanding scope and closures is essential for writing efficient and error-free code.\n\nVariable Scope\nScope in Julia refers to the region of code where a variable is accessible. There are two primary scopes: global and local.\n\nGlobal Scope: Variables defined at the top level of a module or script are in the global scope and can be accessed from anywhere in that file. However, modifying global variables from within functions is generally discouraged.\n\n\nglobal_var = 10\n\nfunction access_global()\n    return global_var\nend\n\naccess_global()  # Outputs: 10\n\njulia&gt; access_global() = 10\n\n\n\nLocal Scope: Variables defined within a function or a block (e.g., loops or conditionals) have local scope and cannot be accessed outside of that block.\n\n\nfunction local_scope_example()\n    local_var = 5\n    return local_var\nend\n\nlocal_scope_example()\n\njulia&gt; local_scope_example() = 5\n\n\nIf you try to access local_var outside the function, you will get an error because it is not defined in the global scope.\n\nlocal_var  # This would cause an error, as local_var is not accessible here\n\nLoadError: UndefVarError: `local_var` not defined in `Main`\nSuggestion: check for spelling errors or missing imports.\nUndefVarError: `local_var` not defined in `Main`\nSuggestion: check for spelling errors or missing imports.\n\n\n\n\nScope of Variables in for Loops\nIn Julia, a for loop does create a new local scope for its loop variable when inside a function or another local scope. This means that a variable used as the loop variable will not overwrite an existing global variable with the same name in that context.\nHere’s an example:\n\ni = 10  # Define a global variable `i`\n\nfor i = 1:3\n    println(i)  # Prints 1, 2, and 3\nend\n\nprintln(\"Outside loop: i = \", i)  # Outputs: 10\n\n1\n2\n3\nOutside loop: i = 10\n\n\nIn this case, the initial value of i (10) is not affected by the loop because the for loop has its own local scope for i. After the loop completes, the global variable i retains its original value (10), demonstrating that the for loop did not alter it.\nHowever, if this code were inside a function, i would be entirely scoped within that function’s local environment, meaning any loop variables would only affect other variables within the function itself.\n\n\nNested Scopes\nJulia allows for nested functions, which can access variables in their enclosing scopes. This is known as lexical scoping.\n\nfunction outer_function(x)\n    y = 2\n    function inner_function(z)\n        return x + y + z\n    end\n    return inner_function\nend\n\nclosure = outer_function(3)\nclosure(4)  # Outputs: 9 (3 + 2 + 4)\n\njulia&gt; closure(4) = 9\n\n\nIn this example, inner_function forms a closure over the variables x and y, retaining access to them even after outer_function has finished executing.\n\n\nClosures\nA closure is a function that captures variables from its surrounding lexical scope, allowing the function to use these variables even after the scope where they were defined has ended. Closures are especially useful for creating customized functions or “function factories.”\n\nExample: Using a Global Variable vs. Capturing a Variable in a Closure\nTo illustrate the difference between referencing a global variable and capturing a variable in a closure, let’s first create a function that uses a global variable:\n\nfactor = 2\n\nfunction multiply_by_global(x)\n    return x * factor\nend\n\nmultiply_by_global(5)  # Outputs: 10\n\n# Update the global variable `factor`\nfactor = 3\nmultiply_by_global(5)  # Outputs: 15 (factor is now 3)\n\njulia&gt; factor = 2\njulia&gt; function multiply_by_global(x)\n    return x * factor\nend\njulia&gt; multiply_by_global(5) = 10\njulia&gt; factor = 3\njulia&gt; multiply_by_global(5) = 15\n\n\nIn this example, multiply_by_global uses the global variable factor, so whenever factor is updated, the result of calling multiply_by_global changes.\n\n\nExample: Capturing a Variable in a Closure\nNow, let’s use a closure to capture the factor variable inside a function. Here, the captured value of factor remains fixed at the time the closure was created, regardless of changes to the variable afterward.\n\nfunction make_multiplier(factor)\n    return (x) -&gt; x * factor  # Returns a closure that captures `factor`\nend\n\ndouble = make_multiplier(2)   # `factor` is captured as 2 in this closure\ntriple = make_multiplier(3)   # `factor` is captured as 3 in this closure\n\ndouble(5)  # Outputs: 10\ntriple(5)  # Outputs: 15\n\n# Even if we change `factor` globally, it doesn't affect the closure\nfactor = 4\ndouble(5)  # Still outputs: 10\ntriple(5)  # Still outputs: 15\n\njulia&gt; function make_multiplier(factor)\n    return (x-&gt;begin\n                x * factor\n            end)\nend\njulia&gt; double = make_multiplier(2)\njulia&gt; triple = make_multiplier(3)\njulia&gt; double(5) = 10\njulia&gt; triple(5) = 15\njulia&gt; factor = 4\njulia&gt; double(5) = 10\njulia&gt; triple(5) = 15\n\n\nIn this example, make_multiplier returns a function that captures the factor variable when the closure is created. This means that double will always multiply by 2, and triple will always multiply by 3, regardless of any subsequent changes to factor.\n\n\n\nSummary\nUsing closures in Julia allows you to “lock in” the values of variables from an outer scope at the time of the closure’s creation. This differs from referencing global variables directly, where any changes to the variable are reflected immediately. Closures are particularly useful for creating function factories or callbacks that need to retain specific values independently of changes in the global scope.\nUnderstanding scope is crucial for performance in Julia. Defining variables within a local scope, such as inside functions, can lead to more efficient code execution. Global variables can lead to performance penalties due to type instability.\nIn summary, scoping rules in Julia allow for clear management of variable accessibility and lifespan, while closures enable powerful programming patterns by capturing the context in which they are created. Understanding these concepts is key to writing effective Julia code.",
    "crumbs": [
      "Julia language",
      "Structure your code"
    ]
  },
  {
    "objectID": "src/structure.html#modules",
    "href": "src/structure.html#modules",
    "title": "Structure your code",
    "section": "Modules",
    "text": "Modules\nModules can be seen as “boxes” in which you organise related functions. Such a “box” can be reused in other program. To have access to the function from “box” B, you should add using B at the beginning of your program. To call some function f stored in B, you type B.f. Thus modules avoid conflicts on function names by providing a seperate namespace. This means that a function f from the main program will indeed be seen as a different function than B.f.\nFind bellow an example of the definition of a simple module.\n\nmodule MyModule\n\n# Defining a function inside the module\nfunction greet(name)\n    println(\"Hello, $name !\")\nend\n\n# Defining a constant inside the module\nconst Pi = 3.14159\n\nend  # End of the module\n\nMain.MyModule\n\n\nLet us now use the function and variable in another program.\n\nusing .MyModule  # Importing the module\n\nMyModule.greet(\"Alice\")  # Calling the function from MyModule\nprintln(MyModule.Pi)     # Accessing the constant from MyModule\n\nHello, Alice !\n3.14159",
    "crumbs": [
      "Julia language",
      "Structure your code"
    ]
  },
  {
    "objectID": "src/structure.html#exercices",
    "href": "src/structure.html#exercices",
    "title": "Structure your code",
    "section": "Exercices",
    "text": "Exercices\n\nExercise 1: Temperature Converter\nWrite a function convert_temperature that takes a temperature value and a keyword argument unit that can either be \"C\" for Celsius or \"F\" for Fahrenheit. The function should convert the temperature to the other unit and return the converted value. Use a conditional statement to determine the conversion formula:\n\nIf the unit is \"C\", convert to Fahrenheit using the formula: \n  F = C \\times \\frac{9}{5} + 32\n\nIf the unit is \"F\", convert to Celsius using the formula: \n  C = (F - 32) \\times \\frac{5}{9}\n\n\nExample Output:\nprintln(convert_temperature(100, unit=\"C\"))  # Outputs: 212.0\nprintln(convert_temperature(32, unit=\"F\"))    # Outputs: 0.0\n\n\n\n\n\n\nTo go further for Exercise 1: Temperature Converter\n\n\n\n\n\nIf the unit provided is not \"C\" or \"F\", you can raise an error using the throw statement along with ArgumentError. This way, you can inform the user that the input is invalid.\n\n\n\n\n\n\n\n\n\nCorrection of Exercise 1: Temperature Converter\n\n\n\n\n\n\nfunction convert_temperature(value; unit)\n    if unit == \"C\"\n        return value * 9/5 + 32  # Convert Celsius to Fahrenheit\n    elseif unit == \"F\"\n        return (value - 32) * 5/9  # Convert Fahrenheit to Celsius\n    else\n        throw(ArgumentError(\"Unit must be 'C' or 'F'\"))\n    end\nend\n\nprintln(convert_temperature(100, unit=\"C\"))  # Outputs: 212.0\nprintln(convert_temperature(32, unit=\"F\"))    # Outputs: 0.0\n\n212.0\n0.0\n\n\n\n\n\n\n\nExercise 2: Manipulating Tuples\n\nCreate a tuple t with three elements: a string, an integer, and a float.\nTry to mutate the first element of the tuple and handle any errors using a try-catch block.\nCreate a NamedTuple nt with fields name, age, and height, and initialize it with your details.\n\n\n\n\n\n\n\nHint for Exercise 2:\n\n\n\n\n\n\nRemember that tuples are immutable, so you can’t modify their elements.\nUse a try-catch block to catch errors if an operation fails.\n\n\n\n\n\n\n\n\n\n\nCorrection of Exercise 2:\n\n\n\n\n\n\n# Create a tuple with three elements: a string, an integer, and a float\nt = (\"John\", 25, 5.9)\n\n# Attempt to mutate the first element of the tuple with error handling\ntry\n    t[1] = \"Alice\"  # This will raise an error because tuples are immutable\ncatch e\n    println(\"Error: \", e)\nend\n\n# Create a NamedTuple with fields: name, age, and height\nnt = (name = \"John\", age = 25, height = 5.9)\n\nprintln(\"NamedTuple: \", nt)\n\nError: MethodError(setindex!, ((\"John\", 25, 5.9), \"Alice\", 1), 0x00000000000068f3)\nNamedTuple: (name = \"John\", age = 25, height = 5.9)\n\n\n\n\n\n\n\nExercise 3: Factorial Function with Closure\nCreate a function make_factorial that returns a closure. This closure should compute the factorial of a number. The closure should capture a variable that keeps track of the number of times it has been called. When the closure is called, it should return the factorial of the number and the call count.\nExample Output:\nfactorial_closure = make_factorial()\nresult, count = factorial_closure(5)\nprintln(result)  # Outputs: 120\nresult, count = factorial_closure(3)\nprintln(result)  # Outputs: 6\nprintln(\"Function called \", count, \" times\")  # Outputs: 2 times\n\n\n\n\n\n\nHint Exercise 3: Factorial Function with Closure\n\n\n\n\n\nWhen returning the results from the closure, you can return a pair of values by creating a tuple. In Julia, tuples are created using parentheses, like this: (value1, value2).\n\n\n\n\n\n\n\n\n\nCorrection of Exercise 3: Factorial Function with Closure\n\n\n\n\n\n\nfunction make_factorial()\n    counter = 0 # Variable to keep track of calls\n    function factorial(n::Int)\n        y = 1\n        for i ∈ 2:n\n            y *= i \n        end\n        counter += 1\n        return y, counter\n    end\n    return factorial \nend\n\nfactorial_closure = make_factorial()\nresult, count = factorial_closure(5)\nprintln(result)  # Outputs: 120\nresult, count = factorial_closure(3)\nprintln(result)  # Outputs: 6\nprintln(\"Function called \", count, \" times\")  # Outputs: 2 times\n\n120\n6\nFunction called 2 times\n\n\n\n\n\n\n\nExercise 4: Filter Even Numbers\nWrite a function filter_even that takes an array of integers as input and returns a new array containing only the even numbers from the input array. Use a loop and a conditional statement to check each number.\nAdditionally, implement a helper function is_even that checks if a number is even. Use the filter_even function to filter an array of numbers, and print the result.\nExample Output:\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\neven_numbers = filter_even(numbers)\nprintln(even_numbers)  # Outputs: [2, 4, 6, 8, 10]\n\n\n\n\n\n\nHint for Exercise 4: Filter Even Numbers\n\n\n\n\n\nTo add elements to an array in Julia, use the push! function. This function takes two arguments: the array you want to modify and the element to add to that array.\n\n\n\n\n\n\n\n\n\nCorrection of Exercise 4: Filter Even Numbers\n\n\n\n\n\n\nfunction is_even(x)\n    return x % 2 == 0\nend\n\nfunction filter_even(numbers)\n    even_numbers = []\n    for number in numbers\n        if is_even(number)\n            push!(even_numbers, number)\n        end\n    end\n    return even_numbers\nend\n\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\neven_numbers = filter_even(numbers)\nprintln(even_numbers)  # Outputs: [2, 4, 6, 8, 10]\n\nAny[2, 4, 6, 8, 10]\n\n\n\n\n\n\n\nExercise Instructions\n\nFor each exercise, implement the required functions in a new Julia script or interactive session.\nTest your functions with different inputs to ensure they work as expected.\nComment on your code to explain the logic behind each part, especially where you utilize control flow and scope.",
    "crumbs": [
      "Julia language",
      "Structure your code"
    ]
  }
]